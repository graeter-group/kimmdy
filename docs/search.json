[
  {
    "objectID": "guide/uml.html",
    "href": "guide/uml.html",
    "title": "UML",
    "section": "",
    "text": "(Re)render the diagrams with\nplantuml -tsvg uml.qmd\nor preview online with plantuml.\n\n\n\n\n@startuml\nclass           RunManager{\nconfig : Config\ntasks : Queue\nstate\nfile history\nchosen_recipe\nrun()\nrun_MD()\nquery_reactions()\ndecide_reaction()\nexecute_recipe(ConversionRecipe)\nnext()\n}\nclass          Config{\nfile paths\ntask sequence\n...\n__init__(configuration_file)\n}\nclass           ConversionRecipe{\ntype\natom_idx\n}\n\nabstract class           Reaction{\nget_reaction_result()\n}\nclass           HAT{\n}\nclass           HomolyticBreak{\n}\nclass           ChangeManager{\nmodify_connectivity()\n}\n\npackage GROMACS{\ninterface GROMACS_CLI{\n}\n}\n\nReaction --|&gt; HAT\nReaction --|&gt; HomolyticBreak\nRunManager -right- Config\nRunManager -right- GROMACS_CLI \nRunManager -- Reaction \nConversionRecipe - Reaction\nChangeManager - RunManager\nConfig -[hidden]-&gt; GROMACS_CLI\n@enduml\n\n\n\n\n\n@startuml classuml\nclass           RunManager{\nconfig : Config\nconfig_reactions\nstate : Enum\nMDparams\nrates \nrun_md_min()\nrun_md_eq()\nrun_md()\nquery_reactions()\nmake_decision()\nrun_recipe(ConversionRecipe)\nnext()\n}\nclass          Config{\npath\n...\nread_yaml()\n}\nclass           MDManager{\nwrite_mdp()\ndo_md()\n}\nclass           ConversionRecipe{\ntype\natom_idx\n}\nclass           DecisionStrategy{\n}\nclass           Reaction{\nrecipe: ConversionRecipe\nget_rates()\n}\nclass           HAT{\n\n}\nclass           CoordinateChanger{\n}\nclass           TopologyChanger{\n}\npackage GROMACS{\ninterface GROMACSCli{\n}\n}\n\nReaction --|&gt; HAT\nConfig -- RunManager : reads &lt;\nRunManager - MDManager : &gt; starts\nMDManager - GROMACSCli : &gt; interacts\nRunManager -- Reaction : &gt; starts\nRunManager -- DecisionStrategy : &gt; starts\nConversionRecipe - Reaction: &lt; generates\nCoordinateChanger - RunManager: &lt; starts\nTopologyChanger - RunManager: &lt; starts\nTopologyChanger -[hidden]-&gt; CoordinateChanger\nMDManager -[hidden]-&gt; DecisionStrategy\n@enduml\n\n@startuml flow\nstart\n:Read .yaml;\n:Run MD_eq;\nrepeat\n :Run MD_prod;\n :Query reactions;\n :Make reaction decision;\n :Change system coordinates;\n :Change system topology;\nrepeatwhile (itermax reached) is (no)\n-&gt; yes;\nstop\n@enduml\n\nlink\nlink"
  },
  {
    "objectID": "guide/uml.html#classes",
    "href": "guide/uml.html#classes",
    "title": "UML",
    "section": "",
    "text": "@startuml\nclass           RunManager{\nconfig : Config\ntasks : Queue\nstate\nfile history\nchosen_recipe\nrun()\nrun_MD()\nquery_reactions()\ndecide_reaction()\nexecute_recipe(ConversionRecipe)\nnext()\n}\nclass          Config{\nfile paths\ntask sequence\n...\n__init__(configuration_file)\n}\nclass           ConversionRecipe{\ntype\natom_idx\n}\n\nabstract class           Reaction{\nget_reaction_result()\n}\nclass           HAT{\n}\nclass           HomolyticBreak{\n}\nclass           ChangeManager{\nmodify_connectivity()\n}\n\npackage GROMACS{\ninterface GROMACS_CLI{\n}\n}\n\nReaction --|&gt; HAT\nReaction --|&gt; HomolyticBreak\nRunManager -right- Config\nRunManager -right- GROMACS_CLI \nRunManager -- Reaction \nConversionRecipe - Reaction\nChangeManager - RunManager\nConfig -[hidden]-&gt; GROMACS_CLI\n@enduml\n\n\n\n\n\n@startuml classuml\nclass           RunManager{\nconfig : Config\nconfig_reactions\nstate : Enum\nMDparams\nrates \nrun_md_min()\nrun_md_eq()\nrun_md()\nquery_reactions()\nmake_decision()\nrun_recipe(ConversionRecipe)\nnext()\n}\nclass          Config{\npath\n...\nread_yaml()\n}\nclass           MDManager{\nwrite_mdp()\ndo_md()\n}\nclass           ConversionRecipe{\ntype\natom_idx\n}\nclass           DecisionStrategy{\n}\nclass           Reaction{\nrecipe: ConversionRecipe\nget_rates()\n}\nclass           HAT{\n\n}\nclass           CoordinateChanger{\n}\nclass           TopologyChanger{\n}\npackage GROMACS{\ninterface GROMACSCli{\n}\n}\n\nReaction --|&gt; HAT\nConfig -- RunManager : reads &lt;\nRunManager - MDManager : &gt; starts\nMDManager - GROMACSCli : &gt; interacts\nRunManager -- Reaction : &gt; starts\nRunManager -- DecisionStrategy : &gt; starts\nConversionRecipe - Reaction: &lt; generates\nCoordinateChanger - RunManager: &lt; starts\nTopologyChanger - RunManager: &lt; starts\nTopologyChanger -[hidden]-&gt; CoordinateChanger\nMDManager -[hidden]-&gt; DecisionStrategy\n@enduml\n\n@startuml flow\nstart\n:Read .yaml;\n:Run MD_eq;\nrepeat\n :Run MD_prod;\n :Query reactions;\n :Make reaction decision;\n :Change system coordinates;\n :Change system topology;\nrepeatwhile (itermax reached) is (no)\n-&gt; yes;\nstop\n@enduml\n\nlink\nlink"
  },
  {
    "objectID": "guide/plugins.html",
    "href": "guide/plugins.html",
    "title": "Writing Reaction Plugins",
    "section": "",
    "text": "Writing Reaction Plugins\nTODO\n\n\n\n\n Back to top"
  },
  {
    "objectID": "_reference/tasks.html",
    "href": "_reference/tasks.html",
    "title": "tasks",
    "section": "",
    "text": "tasks\n\n\n\n\n\nName\nDescription\n\n\n\n\nTaskMapping\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nAutoFillDict\n\n\n\nTask\nA task to be performed as as a step in the RunManager.\n\n\nTaskFiles\nInput and Output files and directories.\n\n\n\n\n\ntasks.AutoFillDict(self, get_missing)\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_missing\n\n\n\n\n\n\n\n\ntasks.Task(self, f, kwargs={})\nA task to be performed as as a step in the RunManager.\nA task consists of a function and its keyword arguments and is itself callable. The function must return a TaskFiles object.\n\n\n\n\n\nName\nDescription\n\n\n\n\nf\n\n\n\nkwargs\n\n\n\nname\n\n\n\n\n\n\n\n\ntasks.TaskFiles(get_latest, input=field(default_factory=dict), output=field(default_factory=dict), outputdir=Path())\nInput and Output files and directories.\nHosts the input and output files belonging to a task. A function or method that wants to be callable as a Task has to return a TaskFiles object. The input defaultdict is populated on the fly using get_latest of the runmanager to find newest files. Files which can not be found by get_latest must be added manually.\n\n\n&gt;&gt;&gt; class run():\n&gt;&gt;&gt;     def get_latest(self, s):\n&gt;&gt;&gt;         return f\"latest {s}\"\n&gt;&gt;&gt; runmng = run()\n&gt;&gt;&gt; files = TaskFiles(runmng)\n&gt;&gt;&gt; files.input\n&gt;&gt;&gt; files.input[\"top\"]\n{'top': 'latest top'}\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_latest\n\n\n\ninput\n\n\n\noutput\n\n\n\noutputdir"
  },
  {
    "objectID": "_reference/tasks.html#attributes",
    "href": "_reference/tasks.html#attributes",
    "title": "tasks",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nTaskMapping"
  },
  {
    "objectID": "_reference/tasks.html#classes",
    "href": "_reference/tasks.html#classes",
    "title": "tasks",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAutoFillDict\n\n\n\nTask\nA task to be performed as as a step in the RunManager.\n\n\nTaskFiles\nInput and Output files and directories.\n\n\n\n\n\ntasks.AutoFillDict(self, get_missing)\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_missing\n\n\n\n\n\n\n\n\ntasks.Task(self, f, kwargs={})\nA task to be performed as as a step in the RunManager.\nA task consists of a function and its keyword arguments and is itself callable. The function must return a TaskFiles object.\n\n\n\n\n\nName\nDescription\n\n\n\n\nf\n\n\n\nkwargs\n\n\n\nname\n\n\n\n\n\n\n\n\ntasks.TaskFiles(get_latest, input=field(default_factory=dict), output=field(default_factory=dict), outputdir=Path())\nInput and Output files and directories.\nHosts the input and output files belonging to a task. A function or method that wants to be callable as a Task has to return a TaskFiles object. The input defaultdict is populated on the fly using get_latest of the runmanager to find newest files. Files which can not be found by get_latest must be added manually.\n\n\n&gt;&gt;&gt; class run():\n&gt;&gt;&gt;     def get_latest(self, s):\n&gt;&gt;&gt;         return f\"latest {s}\"\n&gt;&gt;&gt; runmng = run()\n&gt;&gt;&gt; files = TaskFiles(runmng)\n&gt;&gt;&gt; files.input\n&gt;&gt;&gt; files.input[\"top\"]\n{'top': 'latest top'}\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_latest\n\n\n\ninput\n\n\n\noutput\n\n\n\noutputdir"
  },
  {
    "objectID": "_reference/config.html",
    "href": "_reference/config.html",
    "title": "config",
    "section": "",
    "text": "config\nRead and validate kimmdy.yml configuration files and package into a parsed format for internal use.\n\n\n\n\n\nName\nDescription\n\n\n\n\ntype_scheme\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nChangerConfig\n\n\n\nConfig\nInternal representation of the configuration generated\n\n\nHomolysisConfig\n\n\n\nMDrefConfig\n\n\n\nMds\n\n\n\nPullConfig\n\n\n\nReactionsConfig\n\n\n\nSequence\nA sequence of tasks.\n\n\nSequenceConfig\n\n\n\n\n\n\nconfig.ChangerConfig()\n\n\n\n\n\nName\nDescription\n\n\n\n\ncoordinates\n\n\n\n\n\n\n\n\nconfig.Config(self, input_file=None, recursive_dict=None, type_scheme=type_scheme)\nInternal representation of the configuration generated from the input file, which enables validation before running and computationally expensive operations. All settings read from the input file are accessible through nested attributes.\nTODO: think about how much the type annotations on here can lie.\nAttributes run: int experiment: str name: str # TODO: obsolete?? dryrun: bool iterations: int out: Path gromacs_alias: str ff: Path ffpatch: Optional[Path] top: Path gro: Path ndx: Path mds: dict changer: ChangerConfig reactions: ReactionsConfig pull: PullConfig sequence: SequenceConfig\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_file\nPath\nPath to the config yaml file.\nNone\n\n\nrecursive_dict\ndict\nFor internal use only, used in reading settings in recursively.\nNone\n\n\ntype_scheme\ndict\ndict containing types for casting and validating settings.\ntype_scheme\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nchanger\n\n\n\ncwd\n\n\n\ndryrun\n\n\n\nexperiment\n\n\n\nff\n\n\n\nffpatch\n\n\n\ngro\n\n\n\ngromacs_alias\n\n\n\niterations\n\n\n\nmds\n\n\n\nname\n\n\n\nndx\n\n\n\nout\n\n\n\npull\n\n\n\nraw\n\n\n\nreactions\n\n\n\nrun\n\n\n\nsequence\n\n\n\ntop\n\n\n\ntype_scheme\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nattr\nGet the value of a specific attribute.\n\n\nget_attributes\nGet a list of all attributes\n\n\n\n\n\nconfig.Config.attr(self, attribute)\nGet the value of a specific attribute. Alias for self.__getattribute__\n\n\n\nconfig.Config.get_attributes(self)\nGet a list of all attributes\n\n\n\n\n\nconfig.HomolysisConfig()\n\n\n\n\n\nName\nDescription\n\n\n\n\ndat\n\n\n\nitp\n\n\n\n\n\n\n\n\nconfig.MDrefConfig()\n\n\n\n\n\nName\nDescription\n\n\n\n\nmd\n\n\n\nmd_parameter_growth\n\n\n\n\n\n\n\n\nconfig.Mds(self)\n\n\n\nconfig.PullConfig()\n\n\n\n\n\nName\nDescription\n\n\n\n\nmdp\n\n\n\n\n\n\n\n\nconfig.ReactionsConfig()\n\n\n\n\n\nName\nDescription\n\n\n\n\nhomolysis\n\n\n\n\n\n\n\n\nconfig.Sequence(self, tasks)\nA sequence of tasks.\n\n\n\nconfig.SequenceConfig()\n\n\n\n\n\nName\nDescription\n\n\n\n\ntasks\n\n\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_file_exists\n\n\n\n\n\n\nconfig.check_file_exists(p)"
  },
  {
    "objectID": "_reference/config.html#attributes",
    "href": "_reference/config.html#attributes",
    "title": "config",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ntype_scheme"
  },
  {
    "objectID": "_reference/config.html#classes",
    "href": "_reference/config.html#classes",
    "title": "config",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nChangerConfig\n\n\n\nConfig\nInternal representation of the configuration generated\n\n\nHomolysisConfig\n\n\n\nMDrefConfig\n\n\n\nMds\n\n\n\nPullConfig\n\n\n\nReactionsConfig\n\n\n\nSequence\nA sequence of tasks.\n\n\nSequenceConfig\n\n\n\n\n\n\nconfig.ChangerConfig()\n\n\n\n\n\nName\nDescription\n\n\n\n\ncoordinates\n\n\n\n\n\n\n\n\nconfig.Config(self, input_file=None, recursive_dict=None, type_scheme=type_scheme)\nInternal representation of the configuration generated from the input file, which enables validation before running and computationally expensive operations. All settings read from the input file are accessible through nested attributes.\nTODO: think about how much the type annotations on here can lie.\nAttributes run: int experiment: str name: str # TODO: obsolete?? dryrun: bool iterations: int out: Path gromacs_alias: str ff: Path ffpatch: Optional[Path] top: Path gro: Path ndx: Path mds: dict changer: ChangerConfig reactions: ReactionsConfig pull: PullConfig sequence: SequenceConfig\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_file\nPath\nPath to the config yaml file.\nNone\n\n\nrecursive_dict\ndict\nFor internal use only, used in reading settings in recursively.\nNone\n\n\ntype_scheme\ndict\ndict containing types for casting and validating settings.\ntype_scheme\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nchanger\n\n\n\ncwd\n\n\n\ndryrun\n\n\n\nexperiment\n\n\n\nff\n\n\n\nffpatch\n\n\n\ngro\n\n\n\ngromacs_alias\n\n\n\niterations\n\n\n\nmds\n\n\n\nname\n\n\n\nndx\n\n\n\nout\n\n\n\npull\n\n\n\nraw\n\n\n\nreactions\n\n\n\nrun\n\n\n\nsequence\n\n\n\ntop\n\n\n\ntype_scheme\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nattr\nGet the value of a specific attribute.\n\n\nget_attributes\nGet a list of all attributes\n\n\n\n\n\nconfig.Config.attr(self, attribute)\nGet the value of a specific attribute. Alias for self.__getattribute__\n\n\n\nconfig.Config.get_attributes(self)\nGet a list of all attributes\n\n\n\n\n\nconfig.HomolysisConfig()\n\n\n\n\n\nName\nDescription\n\n\n\n\ndat\n\n\n\nitp\n\n\n\n\n\n\n\n\nconfig.MDrefConfig()\n\n\n\n\n\nName\nDescription\n\n\n\n\nmd\n\n\n\nmd_parameter_growth\n\n\n\n\n\n\n\n\nconfig.Mds(self)\n\n\n\nconfig.PullConfig()\n\n\n\n\n\nName\nDescription\n\n\n\n\nmdp\n\n\n\n\n\n\n\n\nconfig.ReactionsConfig()\n\n\n\n\n\nName\nDescription\n\n\n\n\nhomolysis\n\n\n\n\n\n\n\n\nconfig.Sequence(self, tasks)\nA sequence of tasks.\n\n\n\nconfig.SequenceConfig()\n\n\n\n\n\nName\nDescription\n\n\n\n\ntasks"
  },
  {
    "objectID": "_reference/config.html#functions",
    "href": "_reference/config.html#functions",
    "title": "config",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_file_exists\n\n\n\n\n\n\nconfig.check_file_exists(p)"
  },
  {
    "objectID": "_reference/cmd.html",
    "href": "_reference/cmd.html",
    "title": "cmd",
    "section": "",
    "text": "cmd\nFunctions for starting KIMMDY either from python or the command line. Also initialized logging and configuration.\n\n\n\n\n\nName\nDescription\n\n\n\n\nconfigure_logging\nConfigure logging.\n\n\nget_cmdline_args\nParse command line arguments and configure logger.\n\n\nkimmdy\nRun KIMMDY from the command line.\n\n\nkimmdy_run\nRun KIMMDY from python.\n\n\n\n\n\ncmd.configure_logging(args, color=False)\nConfigure logging.\nConfigures the logging module with optional colorcodes for the terminal.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nargparse.Namespace\nCommand line arguments.\nrequired\n\n\ncolor\n\nShould logging output use colorcodes for terminal output?\nFalse\n\n\n\n\n\n\n\ncmd.get_cmdline_args()\nParse command line arguments and configure logger.\n\n\n\n\n\nType\nDescription\n\n\n\n\nNamespace\nparsed command line arguments\n\n\n\n\n\n\n\ncmd.kimmdy()\nRun KIMMDY from the command line.\nThe configuration is gathered from the input file, which is kimmdy.yml by default.\n\n\n\ncmd.kimmdy_run(input=Path('kimmdy.yml'), loglevel='DEBUG', logfile=Path('kimmdy.log'), checkpoint='', concat=False)\nRun KIMMDY from python.\nTODO: The concat option looks like we probably want an additional kimmdy analysis module, maybe with its own subcommand(s)? Like gromacs gmx &lt;command&gt;?\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nPath\nkimmdy input yml file.\nPath('kimmdy.yml')\n\n\nloglevel\nstr\nLoglevel. One of [“INFO”, “WARNING”, “MESSAGE”, “DEBUG”]\n'DEBUG'\n\n\nlogfile\nPath\nFile path of the logfile.\nPath('kimmdy.log')\n\n\ncheckpoint\nstr\nFile path if a kimmdy.cpt file to restart KIMMDY from a checkpoint.\n''\n\n\nconcat\nbool\nDon’t perform a full KIMMDY run but instead concatenate trajectories from a previous run.\nFalse"
  },
  {
    "objectID": "_reference/cmd.html#functions",
    "href": "_reference/cmd.html#functions",
    "title": "cmd",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconfigure_logging\nConfigure logging.\n\n\nget_cmdline_args\nParse command line arguments and configure logger.\n\n\nkimmdy\nRun KIMMDY from the command line.\n\n\nkimmdy_run\nRun KIMMDY from python.\n\n\n\n\n\ncmd.configure_logging(args, color=False)\nConfigure logging.\nConfigures the logging module with optional colorcodes for the terminal.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nargparse.Namespace\nCommand line arguments.\nrequired\n\n\ncolor\n\nShould logging output use colorcodes for terminal output?\nFalse\n\n\n\n\n\n\n\ncmd.get_cmdline_args()\nParse command line arguments and configure logger.\n\n\n\n\n\nType\nDescription\n\n\n\n\nNamespace\nparsed command line arguments\n\n\n\n\n\n\n\ncmd.kimmdy()\nRun KIMMDY from the command line.\nThe configuration is gathered from the input file, which is kimmdy.yml by default.\n\n\n\ncmd.kimmdy_run(input=Path('kimmdy.yml'), loglevel='DEBUG', logfile=Path('kimmdy.log'), checkpoint='', concat=False)\nRun KIMMDY from python.\nTODO: The concat option looks like we probably want an additional kimmdy analysis module, maybe with its own subcommand(s)? Like gromacs gmx &lt;command&gt;?\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nPath\nkimmdy input yml file.\nPath('kimmdy.yml')\n\n\nloglevel\nstr\nLoglevel. One of [“INFO”, “WARNING”, “MESSAGE”, “DEBUG”]\n'DEBUG'\n\n\nlogfile\nPath\nFile path of the logfile.\nPath('kimmdy.log')\n\n\ncheckpoint\nstr\nFile path if a kimmdy.cpt file to restart KIMMDY from a checkpoint.\n''\n\n\nconcat\nbool\nDon’t perform a full KIMMDY run but instead concatenate trajectories from a previous run.\nFalse"
  },
  {
    "objectID": "_reference/coordinates.html",
    "href": "_reference/coordinates.html",
    "title": "coordinates",
    "section": "",
    "text": "coordinates\nTODO: WIP\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_atomicobj\n\n\n\nget_keys\n\n\n\nis_parameterized\nParameterized topology entries have c0 and c1 attributes != None\n\n\nmerge_same\n\n\n\nmerge_top_parameter_growth\n\n\n\n\n\n\ncoordinates.get_atomicobj(key, type, top)\n\n\n\ncoordinates.get_keys(atomicA, atomicB)\n\n\n\ncoordinates.is_parameterized(entry)\nParameterized topology entries have c0 and c1 attributes != None\n\n\n\ncoordinates.merge_same(same, topA, topB, type)\n\n\n\ncoordinates.merge_top_parameter_growth(topA, topB, focus_nr=None)"
  },
  {
    "objectID": "_reference/coordinates.html#functions",
    "href": "_reference/coordinates.html#functions",
    "title": "coordinates",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_atomicobj\n\n\n\nget_keys\n\n\n\nis_parameterized\nParameterized topology entries have c0 and c1 attributes != None\n\n\nmerge_same\n\n\n\nmerge_top_parameter_growth\n\n\n\n\n\n\ncoordinates.get_atomicobj(key, type, top)\n\n\n\ncoordinates.get_keys(atomicA, atomicB)\n\n\n\ncoordinates.is_parameterized(entry)\nParameterized topology entries have c0 and c1 attributes != None\n\n\n\ncoordinates.merge_same(same, topA, topB, type)\n\n\n\ncoordinates.merge_top_parameter_growth(topA, topB, focus_nr=None)"
  },
  {
    "objectID": "_reference/runmanager.html",
    "href": "_reference/runmanager.html",
    "title": "runmanager",
    "section": "",
    "text": "runmanager\nThe Runmanager is the main entry point of the program.\nIt manages the queue of tasks, communicates with the rest of the program and keeps track of global state.\n\n\n\n\n\nName\nDescription\n\n\n\n\nAMBIGUOUS_SUFFS\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nRunManager\nThe Runmanager is the main entry point of the program.\n\n\nState\nState of the system.\n\n\n\n\n\nrunmanager.RunManager(self, config)\nThe Runmanager is the main entry point of the program.\nManages the queue of tasks, communicates with the rest of the program and keeps track of global state.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconfig\nConfig\nThe configuration object.\n\n\nfrom_checkpoint\nbool\nWhether the runmanager was initialized from a checkpoint.\n\n\ntasks\nqueue.Queue[kimmdy.tasks.Task]\nTasks from config.\n\n\ncrr_tasks\nqueue.Queue[kimmdy.tasks.Task]\nCurrent tasks.\n\n\niteration\nint\nCurrent iteration.\n\n\niterations\nint\nTotal number of iterations.\n\n\nstate\nState\nCurrent state of the system.\n\n\nrecipe_collection\nRecipeCollection\nCollection of recipes.\n\n\nlatest_files\ndict[str, pathlib.Path]\nDictionary of latest files.\n\n\nhistfile\nPath\nPath to history file.\n\n\ncptfile\nPath\nPath to checkpoint file.\n\n\nffpatch\n\nPath to force field patch file.\n\n\ntop\n\nTopology object.\n\n\nfilehist\nlist[dict[str, kimmdy.tasks.TaskFiles]]\nList of dictionaries of TaskFiles.\n\n\ntask_mapping\nTaskMapping\nMapping of task names to runmanager methods.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_latest\nReturns path to latest file of given type.\n\n\nrun\n\n\n\n\n\n\nrunmanager.RunManager.get_latest(self, suffix)\nReturns path to latest file of given type.\nFor .dat files (in general ambiguous extensions) use full file name. Errors if file is not found.\n\n\n\nrunmanager.RunManager.run(self)\n\n\n\n\n\nrunmanager.State()\nState of the system. one of IDLE, MD, REACTION, DONE.\n\n\n\n\n\nName\nDescription\n\n\n\n\nDONE\n\n\n\nIDLE\n\n\n\nMD\n\n\n\nREACTION\n\n\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_existing_files\nInitialize latest_files with every existing file defined in config\n\n\n\n\n\nrunmanager.get_existing_files(config)\nInitialize latest_files with every existing file defined in config"
  },
  {
    "objectID": "_reference/runmanager.html#attributes",
    "href": "_reference/runmanager.html#attributes",
    "title": "runmanager",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAMBIGUOUS_SUFFS"
  },
  {
    "objectID": "_reference/runmanager.html#classes",
    "href": "_reference/runmanager.html#classes",
    "title": "runmanager",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nRunManager\nThe Runmanager is the main entry point of the program.\n\n\nState\nState of the system.\n\n\n\n\n\nrunmanager.RunManager(self, config)\nThe Runmanager is the main entry point of the program.\nManages the queue of tasks, communicates with the rest of the program and keeps track of global state.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconfig\nConfig\nThe configuration object.\n\n\nfrom_checkpoint\nbool\nWhether the runmanager was initialized from a checkpoint.\n\n\ntasks\nqueue.Queue[kimmdy.tasks.Task]\nTasks from config.\n\n\ncrr_tasks\nqueue.Queue[kimmdy.tasks.Task]\nCurrent tasks.\n\n\niteration\nint\nCurrent iteration.\n\n\niterations\nint\nTotal number of iterations.\n\n\nstate\nState\nCurrent state of the system.\n\n\nrecipe_collection\nRecipeCollection\nCollection of recipes.\n\n\nlatest_files\ndict[str, pathlib.Path]\nDictionary of latest files.\n\n\nhistfile\nPath\nPath to history file.\n\n\ncptfile\nPath\nPath to checkpoint file.\n\n\nffpatch\n\nPath to force field patch file.\n\n\ntop\n\nTopology object.\n\n\nfilehist\nlist[dict[str, kimmdy.tasks.TaskFiles]]\nList of dictionaries of TaskFiles.\n\n\ntask_mapping\nTaskMapping\nMapping of task names to runmanager methods.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_latest\nReturns path to latest file of given type.\n\n\nrun\n\n\n\n\n\n\nrunmanager.RunManager.get_latest(self, suffix)\nReturns path to latest file of given type.\nFor .dat files (in general ambiguous extensions) use full file name. Errors if file is not found.\n\n\n\nrunmanager.RunManager.run(self)\n\n\n\n\n\nrunmanager.State()\nState of the system. one of IDLE, MD, REACTION, DONE.\n\n\n\n\n\nName\nDescription\n\n\n\n\nDONE\n\n\n\nIDLE\n\n\n\nMD\n\n\n\nREACTION"
  },
  {
    "objectID": "_reference/runmanager.html#functions",
    "href": "_reference/runmanager.html#functions",
    "title": "runmanager",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_existing_files\nInitialize latest_files with every existing file defined in config\n\n\n\n\n\nrunmanager.get_existing_files(config)\nInitialize latest_files with every existing file defined in config"
  },
  {
    "objectID": "_reference/misc_helper.html",
    "href": "_reference/misc_helper.html",
    "title": "misc_helper",
    "section": "",
    "text": "misc_helper\nMiscelaneous utilitiies that didn’t fit anywhere else for now.\n\n\n\n\n\nName\nDescription\n\n\n\n\nconcat_traj\nFind and concatenate trajectories from KIMMDY runs.\n\n\nedgelist_to_dot_graph\n\n\n\ntop_to_graph\n\n\n\ntopology_to_edgelist\n\n\n\n\n\n\nmisc_helper.concat_traj(run_dir, out=None, run_types=None)\nFind and concatenate trajectories from KIMMDY runs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrun_dir\npathlib.Path | str\nDirectory containing directories of multiple tasks.\nrequired\n\n\nout\nPath\nFile Path into the output trr will be written. Default concat.trr in given run_dir\nNone\n\n\nrun_types\nlist\nList of tasks to get trrs from. If a task is not in this list it will be skipped. By default None\nNone\n\n\n\n\n\n\n\nmisc_helper.edgelist_to_dot_graph(ls, overlap='true')\n\n\n\nmisc_helper.top_to_graph(top, overlap='true')\n\n\n\nmisc_helper.topology_to_edgelist(top)"
  },
  {
    "objectID": "_reference/misc_helper.html#functions",
    "href": "_reference/misc_helper.html#functions",
    "title": "misc_helper",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconcat_traj\nFind and concatenate trajectories from KIMMDY runs.\n\n\nedgelist_to_dot_graph\n\n\n\ntop_to_graph\n\n\n\ntopology_to_edgelist\n\n\n\n\n\n\nmisc_helper.concat_traj(run_dir, out=None, run_types=None)\nFind and concatenate trajectories from KIMMDY runs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrun_dir\npathlib.Path | str\nDirectory containing directories of multiple tasks.\nrequired\n\n\nout\nPath\nFile Path into the output trr will be written. Default concat.trr in given run_dir\nNone\n\n\nrun_types\nlist\nList of tasks to get trrs from. If a task is not in this list it will be skipped. By default None\nNone\n\n\n\n\n\n\n\nmisc_helper.edgelist_to_dot_graph(ls, overlap='true')\n\n\n\nmisc_helper.top_to_graph(top, overlap='true')\n\n\n\nmisc_helper.topology_to_edgelist(top)"
  },
  {
    "objectID": "_reference/utils.html",
    "href": "_reference/utils.html",
    "title": "utils",
    "section": "",
    "text": "utils\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_gmx_version\nCheck for an existing gromacs installation.\n\n\nget_atominfo_from_plumedid\nreturns atomtypes for a plumedid with information from the plumed and topology file\n\n\nget_bondprm_from_atomtypes\nreturns bond parameters (b0, kb, E_dis) for a set of atomtypes\n\n\nget_gmx_dir\nreturns the path to the gromacs installation\n\n\nget_shell_stdout\n\n\n\nincrement_logfile\n\n\n\nmorse_transition_rate\ncalculates energy barrier crossing rate [in ps]; barrier based on the model V = V_morse - F*X\n\n\nrun_gmx\n\n\n\nrun_shell_cmd\n\n\n\n\n\n\nutils.check_gmx_version(config)\nCheck for an existing gromacs installation.\nIf PLUMED is meant to be used it additionally checks for the keyword ‘MODIFIED’ in the version name.\n\n\n\nutils.get_atominfo_from_plumedid(plumedid, plumed, top)\nreturns atomtypes for a plumedid with information from the plumed and topology file\n\n\n\nutils.get_bondprm_from_atomtypes(atomtypes, ffbonded, lookup_edissoc_atomtype)\nreturns bond parameters (b0, kb, E_dis) for a set of atomtypes\n\n\n\nutils.get_gmx_dir()\nreturns the path to the gromacs installation\n\n\n\nutils.get_shell_stdout(s)\n\n\n\nutils.increment_logfile(f)\n\n\n\nutils.morse_transition_rate(r_curr, r_0, E_dis, k_f, k_0=0.288, kT=2.479)\ncalculates energy barrier crossing rate [in ps]; barrier based on the model V = V_morse - F*X\n\n\n\nutils.run_gmx(s, cwd=None)\n\n\n\nutils.run_shell_cmd(s, cwd=None)"
  },
  {
    "objectID": "_reference/utils.html#functions",
    "href": "_reference/utils.html#functions",
    "title": "utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_gmx_version\nCheck for an existing gromacs installation.\n\n\nget_atominfo_from_plumedid\nreturns atomtypes for a plumedid with information from the plumed and topology file\n\n\nget_bondprm_from_atomtypes\nreturns bond parameters (b0, kb, E_dis) for a set of atomtypes\n\n\nget_gmx_dir\nreturns the path to the gromacs installation\n\n\nget_shell_stdout\n\n\n\nincrement_logfile\n\n\n\nmorse_transition_rate\ncalculates energy barrier crossing rate [in ps]; barrier based on the model V = V_morse - F*X\n\n\nrun_gmx\n\n\n\nrun_shell_cmd\n\n\n\n\n\n\nutils.check_gmx_version(config)\nCheck for an existing gromacs installation.\nIf PLUMED is meant to be used it additionally checks for the keyword ‘MODIFIED’ in the version name.\n\n\n\nutils.get_atominfo_from_plumedid(plumedid, plumed, top)\nreturns atomtypes for a plumedid with information from the plumed and topology file\n\n\n\nutils.get_bondprm_from_atomtypes(atomtypes, ffbonded, lookup_edissoc_atomtype)\nreturns bond parameters (b0, kb, E_dis) for a set of atomtypes\n\n\n\nutils.get_gmx_dir()\nreturns the path to the gromacs installation\n\n\n\nutils.get_shell_stdout(s)\n\n\n\nutils.increment_logfile(f)\n\n\n\nutils.morse_transition_rate(r_curr, r_0, E_dis, k_f, k_0=0.288, kT=2.479)\ncalculates energy barrier crossing rate [in ps]; barrier based on the model V = V_morse - F*X\n\n\n\nutils.run_gmx(s, cwd=None)\n\n\n\nutils.run_shell_cmd(s, cwd=None)"
  },
  {
    "objectID": "_reference/kmc.html",
    "href": "_reference/kmc.html",
    "title": "kmc",
    "section": "",
    "text": "kmc\nKinetic Monte Carlo (KMC) classes and functions.\nIn our system, the reaction rate r = (deterministic) reaction constant k = stochastic reaction constant c (from gillespie 1977) = propensity a (from Anderson 2007) because of the fundamental premise of chemical kinetics and because we have one reactant molecule\n\n\n\n\n\nName\nDescription\n\n\n\n\nKMCResult\nThe result of a KMC step. Similar to a Recipe but for the concrete realization of a reaction.\n\n\n\n\n\nkmc.KMCResult(recipe_steps=None, reaction_probability=None, time_step=None)\nThe result of a KMC step. Similar to a Recipe but for the concrete realization of a reaction.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nrecipe_steps\ntyping.Union[list[kimmdy.reaction.RecipeStep], None]\nSingle sequence of RecipeSteps to build product\n\n\nreaction_probability\ntyping.Union[list[float], None]\nIntegral of reaction propensity with respect to time\n\n\ntime_step\ntyping.Union[float, None]\nTime step during which the reaction occurs\n\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrm\nFirst Reaction Method variant of Kinetic Monte Carlo.\n\n\nrf_kmc\nRejection-Free Monte Carlo.\n\n\n\n\n\nkmc.frm(recipe_collection, rng=default_rng(), MD_time=None)\nFirst Reaction Method variant of Kinetic Monte Carlo. takes RecipeCollection and choses a recipe based on which reaction would occur.\nCompare e.g. https://en.wikipedia.org/wiki/Kinetic_Monte_Carlo#Time-dependent_Algorithms\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnumpy.random.BitGenerator\nto generate random numbers in the KMC step\ndefault_rng()\n\n\nMD_time\ntyping.Union[float, None]\ntime [ps] to compare conformational events with reaction events in the time domain\nNone\n\n\n\n\n\n\n\nkmc.rf_kmc(recipe_collection, rng=default_rng())\nRejection-Free Monte Carlo. takes RecipeCollection and choses a recipe based on the relative propensity of the events.\nCompare e.g. https://en.wikipedia.org/wiki/Kinetic_Monte_Carlo#Rejection-free_KMC\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnumpy.random.BitGenerator\nfunction to generate random numbers in the KMC step\ndefault_rng()"
  },
  {
    "objectID": "_reference/kmc.html#classes",
    "href": "_reference/kmc.html#classes",
    "title": "kmc",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nKMCResult\nThe result of a KMC step. Similar to a Recipe but for the concrete realization of a reaction.\n\n\n\n\n\nkmc.KMCResult(recipe_steps=None, reaction_probability=None, time_step=None)\nThe result of a KMC step. Similar to a Recipe but for the concrete realization of a reaction.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nrecipe_steps\ntyping.Union[list[kimmdy.reaction.RecipeStep], None]\nSingle sequence of RecipeSteps to build product\n\n\nreaction_probability\ntyping.Union[list[float], None]\nIntegral of reaction propensity with respect to time\n\n\ntime_step\ntyping.Union[float, None]\nTime step during which the reaction occurs"
  },
  {
    "objectID": "_reference/kmc.html#functions",
    "href": "_reference/kmc.html#functions",
    "title": "kmc",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfrm\nFirst Reaction Method variant of Kinetic Monte Carlo.\n\n\nrf_kmc\nRejection-Free Monte Carlo.\n\n\n\n\n\nkmc.frm(recipe_collection, rng=default_rng(), MD_time=None)\nFirst Reaction Method variant of Kinetic Monte Carlo. takes RecipeCollection and choses a recipe based on which reaction would occur.\nCompare e.g. https://en.wikipedia.org/wiki/Kinetic_Monte_Carlo#Time-dependent_Algorithms\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnumpy.random.BitGenerator\nto generate random numbers in the KMC step\ndefault_rng()\n\n\nMD_time\ntyping.Union[float, None]\ntime [ps] to compare conformational events with reaction events in the time domain\nNone\n\n\n\n\n\n\n\nkmc.rf_kmc(recipe_collection, rng=default_rng())\nRejection-Free Monte Carlo. takes RecipeCollection and choses a recipe based on the relative propensity of the events.\nCompare e.g. https://en.wikipedia.org/wiki/Kinetic_Monte_Carlo#Rejection-free_KMC\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnumpy.random.BitGenerator\nfunction to generate random numbers in the KMC step\ndefault_rng()"
  },
  {
    "objectID": "_reference/parsing.html",
    "href": "_reference/parsing.html",
    "title": "parsing",
    "section": "",
    "text": "parsing\nAll read_&lt;…&gt; and write_&lt;…&gt; functions.\n\n\n\n\n\nName\nDescription\n\n\n\n\nGMX_BUILTIN_FF_DIR\nPath to gromacs data directory with the built-in forcefields.\n\n\nTopologyDict\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncreate_subsections\n\n\n\nis_not_comment\n\n\n\nread_distances_dat\nRead a distances.dat plumed output file.\n\n\nread_edissoc\nreads a edissoc file and turns it into a dict.\n\n\nread_plumed\nRead a plumed.dat configuration file.\n\n\nread_rtp\n\n\n\nread_top\nRead a topology file into a raw TopologyDict represenation.\n\n\nread_xml_ff\n\n\n\nresolve_includes\nResolve #include statements in a (top/itp) file.\n\n\nwrite_plumed\nWrite a plumed.dat configuration file.\n\n\nwrite_top\nWrite a TopologyDict to a topology file.\n\n\n\n\n\nparsing.create_subsections(ls)\n\n\n\nparsing.is_not_comment(c)\n\n\n\nparsing.read_distances_dat(distances_dat)\nRead a distances.dat plumed output file.\n\n\n\nparsing.read_edissoc(path)\nreads a edissoc file and turns it into a dict. the tuple of bond atoms make up the key, the dissociation energy E_dissoc [kJ mol-1] is the value\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the file. E.g. Path(“edissoc.dat”)\nrequired\n\n\n\n\n\n\n\nparsing.read_plumed(path)\nRead a plumed.dat configuration file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the file. E.g. “plumed.dat”\nrequired\n\n\n\n\n\n\n\nparsing.read_rtp(path)\n\n\n\nparsing.read_top(path)\nRead a topology file into a raw TopologyDict represenation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the topology file.\nrequired\n\n\n\n\n\n\n\n#include statements will be resolved\ncomments will be removed\nall lines are stripped of leading and trailing whitespace\n#undef is not supported\na section within ifdef may be a subsection of a section that was started outside of the ifdef\n#if..#endif statements only surround a full section or subsection, not individual lines within a section and a section may either be contained within if … else or it may not be, but it can not be duplicated with one part inside and one outside.\nif .. else can’t be nested\n#include s that don’t resolve to a valid file path are silently dropped\nsections that can have subsections can also exist multiple, separate times e.g. moleculetype will appear multiple times and they should not be merged\n\n\n\n\n\nparsing.read_xml_ff(path)\n\n\n\nparsing.resolve_includes(path)\n\n\npath : Filepath to read.\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[str]\nList of lines.\n\n\ntyping.Optional[pathlib.Path]\nPath to the ff directory if one of the includes used a file from it.\n\n\n\n\n\n\n\nparsing.write_plumed(d, path)\nWrite a plumed.dat configuration file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the file. E.g. “plumed.dat”\nrequired\n\n\n\n\n\n\n\nparsing.write_top(top, outfile)\nWrite a TopologyDict to a topology file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntop\nTopologyDict\nRaw dictionary represenation of the topology.\nrequired\n\n\noutfile\nPath\nPath to the topology file to write to.\nrequired"
  },
  {
    "objectID": "_reference/parsing.html#attributes",
    "href": "_reference/parsing.html#attributes",
    "title": "parsing",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nGMX_BUILTIN_FF_DIR\nPath to gromacs data directory with the built-in forcefields.\n\n\nTopologyDict"
  },
  {
    "objectID": "_reference/parsing.html#functions",
    "href": "_reference/parsing.html#functions",
    "title": "parsing",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncreate_subsections\n\n\n\nis_not_comment\n\n\n\nread_distances_dat\nRead a distances.dat plumed output file.\n\n\nread_edissoc\nreads a edissoc file and turns it into a dict.\n\n\nread_plumed\nRead a plumed.dat configuration file.\n\n\nread_rtp\n\n\n\nread_top\nRead a topology file into a raw TopologyDict represenation.\n\n\nread_xml_ff\n\n\n\nresolve_includes\nResolve #include statements in a (top/itp) file.\n\n\nwrite_plumed\nWrite a plumed.dat configuration file.\n\n\nwrite_top\nWrite a TopologyDict to a topology file.\n\n\n\n\n\nparsing.create_subsections(ls)\n\n\n\nparsing.is_not_comment(c)\n\n\n\nparsing.read_distances_dat(distances_dat)\nRead a distances.dat plumed output file.\n\n\n\nparsing.read_edissoc(path)\nreads a edissoc file and turns it into a dict. the tuple of bond atoms make up the key, the dissociation energy E_dissoc [kJ mol-1] is the value\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the file. E.g. Path(“edissoc.dat”)\nrequired\n\n\n\n\n\n\n\nparsing.read_plumed(path)\nRead a plumed.dat configuration file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the file. E.g. “plumed.dat”\nrequired\n\n\n\n\n\n\n\nparsing.read_rtp(path)\n\n\n\nparsing.read_top(path)\nRead a topology file into a raw TopologyDict represenation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the topology file.\nrequired\n\n\n\n\n\n\n\n#include statements will be resolved\ncomments will be removed\nall lines are stripped of leading and trailing whitespace\n#undef is not supported\na section within ifdef may be a subsection of a section that was started outside of the ifdef\n#if..#endif statements only surround a full section or subsection, not individual lines within a section and a section may either be contained within if … else or it may not be, but it can not be duplicated with one part inside and one outside.\nif .. else can’t be nested\n#include s that don’t resolve to a valid file path are silently dropped\nsections that can have subsections can also exist multiple, separate times e.g. moleculetype will appear multiple times and they should not be merged\n\n\n\n\n\nparsing.read_xml_ff(path)\n\n\n\nparsing.resolve_includes(path)\n\n\npath : Filepath to read.\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[str]\nList of lines.\n\n\ntyping.Optional[pathlib.Path]\nPath to the ff directory if one of the includes used a file from it.\n\n\n\n\n\n\n\nparsing.write_plumed(d, path)\nWrite a plumed.dat configuration file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the file. E.g. “plumed.dat”\nrequired\n\n\n\n\n\n\n\nparsing.write_top(top, outfile)\nWrite a TopologyDict to a topology file.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntop\nTopologyDict\nRaw dictionary represenation of the topology.\nrequired\n\n\noutfile\nPath\nPath to the topology file to write to.\nrequired"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "KIMMDY",
    "section": "",
    "text": "KIMMDY\nWelcome to KIMMDY\nGetting Started\n\n\n\n\n Back to top"
  },
  {
    "objectID": "_reference/topology.topology.html",
    "href": "_reference/topology.topology.html",
    "title": "topology.topology",
    "section": "",
    "text": "topology.topology\n\n\n\n\n\nName\nDescription\n\n\n\n\nPROTEIN_SECTION\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nTopology\nSmart container for parsed topology data.\n\n\n\n\n\ntopology.topology.Topology(self, top, ffpatch=None)\nSmart container for parsed topology data.\nA topology keeps track of connections and applies patches to parameters when bonds are broken or formed.\nAssumptions:\n\nthe topology of interest (the protein) is in section ‘moleculetype_0’.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntop\nTopologyDict\nA dictionary containing the parsed topology data.\nrequired\n\n\nffpatch\ntyping.Optional[pathlib.Path]\nPath to a force field patch file. If None, no patching is applied.\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nangles\n\n\n\natoms\n\n\n\nbonds\n\n\n\ndihedral_restraints\n\n\n\nff\n\n\n\nffpatches\n\n\n\nimproper_dihedrals\n\n\n\npairs\n\n\n\nposition_restraints\n\n\n\nproper_dihedrals\n\n\n\nprotein\n\n\n\nradicals\n\n\n\ntop\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbind_bond\nAdd a bond in topology.\n\n\nbreak_bond\nBreak bonds in topology.\n\n\nmove_hydrogen\nMove a singly bound atom to a new location.\n\n\npatch_parameters\n\n\n\nreindex_atomnrs\nReindex atom numbers in topology.\n\n\nto_dict\n\n\n\n\n\n\ntopology.topology.Topology.bind_bond(self, atompair_nrs)\nAdd a bond in topology.\nModifies the topology dictionary in place. It keeps track of affected terms in the topology via a graph representation of the topology and applies the necessary changes to bonds, angles and dihedrals (proper and improper). Furthermore, it modifies to function types in the topology to account for radicals.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natompair_nrs\ntuple[str, str]\nA tuple of integers with the atoms ids (id, starting at 1) with from, the atom being moved and to, the atom to which the from atom will be bound\nrequired\n\n\n\n\n\n\n\ntopology.topology.Topology.break_bond(self, atompair_nrs)\nBreak bonds in topology.\nremoves bond, angles and dihedrals where atompair was involved. Modifies the topology dictionary in place.\n\n\n\ntopology.topology.Topology.move_hydrogen(self, from_to)\nMove a singly bound atom to a new location.\nThis is typically H for Hydrogen Atom Transfer (HAT).\n\n\n\ntopology.topology.Topology.patch_parameters(self, focus_nr)\n\n\n\ntopology.topology.Topology.reindex_atomnrs(self)\nReindex atom numbers in topology.\nStarts at index 1. This also updates the numbers for bonds, angles, dihedrals and pairs.\n\n\n\ntopology.topology.Topology.to_dict(self)"
  },
  {
    "objectID": "_reference/topology.topology.html#attributes",
    "href": "_reference/topology.topology.html#attributes",
    "title": "topology.topology",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nPROTEIN_SECTION"
  },
  {
    "objectID": "_reference/topology.topology.html#classes",
    "href": "_reference/topology.topology.html#classes",
    "title": "topology.topology",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nTopology\nSmart container for parsed topology data.\n\n\n\n\n\ntopology.topology.Topology(self, top, ffpatch=None)\nSmart container for parsed topology data.\nA topology keeps track of connections and applies patches to parameters when bonds are broken or formed.\nAssumptions:\n\nthe topology of interest (the protein) is in section ‘moleculetype_0’.\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntop\nTopologyDict\nA dictionary containing the parsed topology data.\nrequired\n\n\nffpatch\ntyping.Optional[pathlib.Path]\nPath to a force field patch file. If None, no patching is applied.\nNone\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nangles\n\n\n\natoms\n\n\n\nbonds\n\n\n\ndihedral_restraints\n\n\n\nff\n\n\n\nffpatches\n\n\n\nimproper_dihedrals\n\n\n\npairs\n\n\n\nposition_restraints\n\n\n\nproper_dihedrals\n\n\n\nprotein\n\n\n\nradicals\n\n\n\ntop\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbind_bond\nAdd a bond in topology.\n\n\nbreak_bond\nBreak bonds in topology.\n\n\nmove_hydrogen\nMove a singly bound atom to a new location.\n\n\npatch_parameters\n\n\n\nreindex_atomnrs\nReindex atom numbers in topology.\n\n\nto_dict\n\n\n\n\n\n\ntopology.topology.Topology.bind_bond(self, atompair_nrs)\nAdd a bond in topology.\nModifies the topology dictionary in place. It keeps track of affected terms in the topology via a graph representation of the topology and applies the necessary changes to bonds, angles and dihedrals (proper and improper). Furthermore, it modifies to function types in the topology to account for radicals.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natompair_nrs\ntuple[str, str]\nA tuple of integers with the atoms ids (id, starting at 1) with from, the atom being moved and to, the atom to which the from atom will be bound\nrequired\n\n\n\n\n\n\n\ntopology.topology.Topology.break_bond(self, atompair_nrs)\nBreak bonds in topology.\nremoves bond, angles and dihedrals where atompair was involved. Modifies the topology dictionary in place.\n\n\n\ntopology.topology.Topology.move_hydrogen(self, from_to)\nMove a singly bound atom to a new location.\nThis is typically H for Hydrogen Atom Transfer (HAT).\n\n\n\ntopology.topology.Topology.patch_parameters(self, focus_nr)\n\n\n\ntopology.topology.Topology.reindex_atomnrs(self)\nReindex atom numbers in topology.\nStarts at index 1. This also updates the numbers for bonds, angles, dihedrals and pairs.\n\n\n\ntopology.topology.Topology.to_dict(self)"
  },
  {
    "objectID": "_reference/reaction.html",
    "href": "_reference/reaction.html",
    "title": "reaction",
    "section": "",
    "text": "reaction\nReactionPlugin protocoll and reaction recipes.\n\n\n\n\n\nName\nDescription\n\n\n\n\nBind\nChange topology to form a bond\n\n\nBreak\nChange topology to break a bond\n\n\nMove\nChange topology and/or coordinates to move an atom.\n\n\nReactionPlugin\nReaction base class\n\n\nRecipe\nA reaction path defined by one series of RecipeSteps.\n\n\nRecipeCollection\nA RecipeCollection encompasses a number of reaction paths.\n\n\nRecipeStep\nBase class for all RecipeSteps.\n\n\nSingleOperation\n\n\n\n\n\n\nreaction.Bind()\nChange topology to form a bond\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\natom_ix1/2\nint\n0-based atom indices as ints\n\n\natom_id1/2\nstr\natom indices between which a bond should be removed\n\n\n\n\n\n\n\nreaction.Break()\nChange topology to break a bond\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\natom_ix1/2\nint\n0-based atom indices as ints\n\n\natom_id1/2\nstr\natom indices between which a bond should be removed\n\n\n\n\n\n\n\nreaction.Move(self, ix_to_move, ix_to_bind=None, ix_to_break=None, new_coords=None)\nChange topology and/or coordinates to move an atom.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nix_to_move\nint\nIndex of atom to move. 0-based.\n\n\nix_to_bind\nint\nBonding partner to form bond with.\n\n\nix_to_break\nint\nBonding partner to break bond with, default None.\n\n\nnew_coords\ntyping.Union[tuple[tuple[float, float, float], float], None]\nOptional new xyz coordinates for atom to move to, and the associated time in ps default None.\n\n\nid_to_move\nstr\nIndex of atom to move. 1-based\n\n\nid_to_bind\nstr\nBonding partner to form bond with.\n\n\nid_to_break\nstr\nBonding partner to break bond with, default None.\n\n\n\n\n\n\n\nreaction.ReactionPlugin(self, name, runmng)\nReaction base class\nhast a type_scheme, which is a dict of types of possible entries in config. Used to read and check the input config. To not use this feature return empty dict.\nExample:\n{\"homolysis\": {\"edis\": Path, \"bonds\": Path}}\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName of the reaction\nrequired\n\n\nrunmng\nRunManager\nRunManager instance\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconfig\n\n\n\nname\n\n\n\nrunmng\n\n\n\ntype_scheme\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_recipe_collection\nGet a RecipeCollection as a result of the reaction.\n\n\n\n\n\nreaction.ReactionPlugin.get_recipe_collection(self, files)\nGet a RecipeCollection as a result of the reaction.\nThis is run as a Task in the RunManager. How the RecipeCollection is built is up to the reaction. It has access to the current state of the system via the runmanager self.runmng and the files.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfiles\nTaskFiles\nTaskFiles instance\nrequired\n\n\n\n\n\n\n\n\n\nreaction.Recipe(recipe_steps, rates, timespans)\nA reaction path defined by one series of RecipeSteps. Defines everything necessart to build the product state from the educt state.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nrecipe_steps\nlist[kimmdy.reaction.RecipeStep]\nSingle sequence of RecipeSteps to build product\n\n\nrates\nlist[float]\nReaction rates corresponding 1:1 to timespans.\n\n\ntimespans\nlist[list[float, float]]\nList of half-open timespans (t1, t2] in ps, at which this reaction path applies. Must have same number of timespans as rates. t1 can equal t2 for the first frame.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalc_averages\nCalulate average rates over some window size\n\n\ncheck_consistency\nRun consistency checks for correct size of variables\n\n\ncombine_with\nCombines this Recipe with another with the same RecipeSteps.\n\n\n\n\n\nreaction.Recipe.calc_averages(self, window_size)\nCalulate average rates over some window size\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwindow_size\nint\nSize of the window to average over, -1 to average over whole available range.\nrequired\n\n\n\n\n\n\n\nreaction.Recipe.check_consistency(self)\nRun consistency checks for correct size of variables\n\n\n\nreaction.Recipe.combine_with(self, other)\nCombines this Recipe with another with the same RecipeSteps.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nRecipe\n\nrequired\n\n\n\n\n\n\n\n\n\nreaction.RecipeCollection(recipes)\nA RecipeCollection encompasses a number of reaction paths. They can originate from multiple reaction plugins, but do not need to.\n\n\n\n\n\nName\nDescription\n\n\n\n\nrecipes\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\naggregate_reactions\nCombines reactions having the same sequence of RecipeSteps.\n\n\nfrom_dill\n\n\n\nto_csv\nWrite a ReactionResult as defined in the reaction module to a csv file\n\n\nto_dill\n\n\n\n\n\n\nreaction.RecipeCollection.aggregate_reactions(self)\nCombines reactions having the same sequence of RecipeSteps.\n\n\n\nreaction.RecipeCollection.from_dill(cls, path)\n\n\n\nreaction.RecipeCollection.to_csv(self, path)\nWrite a ReactionResult as defined in the reaction module to a csv file\n\n\n\nreaction.RecipeCollection.to_dill(self, path)\n\n\n\n\n\nreaction.RecipeStep()\nBase class for all RecipeSteps. Indices can be accessed as 0-based or 1-based. ix: 0-based, int id: 1-based, str\n\n\n\nreaction.SingleOperation(self, ix1, ix2)\n\n\n\n\n\nName\nDescription\n\n\n\n\natom_id_1\n\n\n\natom_id_2\n\n\n\natom_ix_1\n\n\n\natom_ix_2"
  },
  {
    "objectID": "_reference/reaction.html#classes",
    "href": "_reference/reaction.html#classes",
    "title": "reaction",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBind\nChange topology to form a bond\n\n\nBreak\nChange topology to break a bond\n\n\nMove\nChange topology and/or coordinates to move an atom.\n\n\nReactionPlugin\nReaction base class\n\n\nRecipe\nA reaction path defined by one series of RecipeSteps.\n\n\nRecipeCollection\nA RecipeCollection encompasses a number of reaction paths.\n\n\nRecipeStep\nBase class for all RecipeSteps.\n\n\nSingleOperation\n\n\n\n\n\n\nreaction.Bind()\nChange topology to form a bond\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\natom_ix1/2\nint\n0-based atom indices as ints\n\n\natom_id1/2\nstr\natom indices between which a bond should be removed\n\n\n\n\n\n\n\nreaction.Break()\nChange topology to break a bond\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\natom_ix1/2\nint\n0-based atom indices as ints\n\n\natom_id1/2\nstr\natom indices between which a bond should be removed\n\n\n\n\n\n\n\nreaction.Move(self, ix_to_move, ix_to_bind=None, ix_to_break=None, new_coords=None)\nChange topology and/or coordinates to move an atom.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nix_to_move\nint\nIndex of atom to move. 0-based.\n\n\nix_to_bind\nint\nBonding partner to form bond with.\n\n\nix_to_break\nint\nBonding partner to break bond with, default None.\n\n\nnew_coords\ntyping.Union[tuple[tuple[float, float, float], float], None]\nOptional new xyz coordinates for atom to move to, and the associated time in ps default None.\n\n\nid_to_move\nstr\nIndex of atom to move. 1-based\n\n\nid_to_bind\nstr\nBonding partner to form bond with.\n\n\nid_to_break\nstr\nBonding partner to break bond with, default None.\n\n\n\n\n\n\n\nreaction.ReactionPlugin(self, name, runmng)\nReaction base class\nhast a type_scheme, which is a dict of types of possible entries in config. Used to read and check the input config. To not use this feature return empty dict.\nExample:\n{\"homolysis\": {\"edis\": Path, \"bonds\": Path}}\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName of the reaction\nrequired\n\n\nrunmng\nRunManager\nRunManager instance\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconfig\n\n\n\nname\n\n\n\nrunmng\n\n\n\ntype_scheme\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_recipe_collection\nGet a RecipeCollection as a result of the reaction.\n\n\n\n\n\nreaction.ReactionPlugin.get_recipe_collection(self, files)\nGet a RecipeCollection as a result of the reaction.\nThis is run as a Task in the RunManager. How the RecipeCollection is built is up to the reaction. It has access to the current state of the system via the runmanager self.runmng and the files.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfiles\nTaskFiles\nTaskFiles instance\nrequired\n\n\n\n\n\n\n\n\n\nreaction.Recipe(recipe_steps, rates, timespans)\nA reaction path defined by one series of RecipeSteps. Defines everything necessart to build the product state from the educt state.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nrecipe_steps\nlist[kimmdy.reaction.RecipeStep]\nSingle sequence of RecipeSteps to build product\n\n\nrates\nlist[float]\nReaction rates corresponding 1:1 to timespans.\n\n\ntimespans\nlist[list[float, float]]\nList of half-open timespans (t1, t2] in ps, at which this reaction path applies. Must have same number of timespans as rates. t1 can equal t2 for the first frame.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalc_averages\nCalulate average rates over some window size\n\n\ncheck_consistency\nRun consistency checks for correct size of variables\n\n\ncombine_with\nCombines this Recipe with another with the same RecipeSteps.\n\n\n\n\n\nreaction.Recipe.calc_averages(self, window_size)\nCalulate average rates over some window size\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwindow_size\nint\nSize of the window to average over, -1 to average over whole available range.\nrequired\n\n\n\n\n\n\n\nreaction.Recipe.check_consistency(self)\nRun consistency checks for correct size of variables\n\n\n\nreaction.Recipe.combine_with(self, other)\nCombines this Recipe with another with the same RecipeSteps.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nRecipe\n\nrequired\n\n\n\n\n\n\n\n\n\nreaction.RecipeCollection(recipes)\nA RecipeCollection encompasses a number of reaction paths. They can originate from multiple reaction plugins, but do not need to.\n\n\n\n\n\nName\nDescription\n\n\n\n\nrecipes\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\naggregate_reactions\nCombines reactions having the same sequence of RecipeSteps.\n\n\nfrom_dill\n\n\n\nto_csv\nWrite a ReactionResult as defined in the reaction module to a csv file\n\n\nto_dill\n\n\n\n\n\n\nreaction.RecipeCollection.aggregate_reactions(self)\nCombines reactions having the same sequence of RecipeSteps.\n\n\n\nreaction.RecipeCollection.from_dill(cls, path)\n\n\n\nreaction.RecipeCollection.to_csv(self, path)\nWrite a ReactionResult as defined in the reaction module to a csv file\n\n\n\nreaction.RecipeCollection.to_dill(self, path)\n\n\n\n\n\nreaction.RecipeStep()\nBase class for all RecipeSteps. Indices can be accessed as 0-based or 1-based. ix: 0-based, int id: 1-based, str\n\n\n\nreaction.SingleOperation(self, ix1, ix2)\n\n\n\n\n\nName\nDescription\n\n\n\n\natom_id_1\n\n\n\natom_id_2\n\n\n\natom_ix_1\n\n\n\natom_ix_2"
  },
  {
    "objectID": "_reference/constants.html",
    "href": "_reference/constants.html",
    "title": "constants",
    "section": "",
    "text": "constants\nComstants used throughout KIMMDY\n\n\n\n\n\nName\nDescription\n\n\n\n\nATOMTYPE_BONDORDER\nTo determin if an atom is a radical.\n\n\nATOMTYPE_BONDORDER_FLAT\nTo determin if an atom is a radical."
  },
  {
    "objectID": "_reference/constants.html#attributes",
    "href": "_reference/constants.html#attributes",
    "title": "constants",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nATOMTYPE_BONDORDER\nTo determin if an atom is a radical.\n\n\nATOMTYPE_BONDORDER_FLAT\nTo determin if an atom is a radical."
  },
  {
    "objectID": "_reference/topology.atomic.html",
    "href": "_reference/topology.atomic.html",
    "title": "topology.atomic",
    "section": "",
    "text": "topology.atomic\nAtomic datatypes for the topology such as Atom, Bond, Angle, Dihedral, etc. The order of the fields comes from the gromacs topology file format. See https://manual.gromacs.org/current/reference-manual/topologies/topology-file-formats.html#topology-file\n\n\n\n\n\nName\nDescription\n\n\n\n\nAngleId\n\n\n\nAtomId\n\n\n\nAtomic\n\n\n\nAtomicType\n\n\n\nAtomicTypes\n\n\n\nBondId\n\n\n\nDihedralId\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nAngle\nInformation about one angle\n\n\nAngleType\nInformation about one angle\n\n\nAtom\nInformation about one atom\n\n\nAtomType\nInformation about one atom\n\n\nBond\nInformation about one bond\n\n\nBondType\nInformation about one bondtype\n\n\nDihedral\nInformation about one proper or improper dihedral\n\n\nDihedralRestraint\nInformation about one dihedral restraint.\n\n\nDihedralType\nInformation about one dihedral\n\n\nMultipleDihedralTypes\nMultiple DihedralTypess with the same ai, aj, ak, al\n\n\nMultipleDihedrals\nMultiple Dihedrals with the same ai, aj, ak, al\n\n\nPair\nInformation about one pair\n\n\nPositionRestraint\nInformation about one position restraint.\n\n\nResidueAtomSpec\nInformation about one atom in a residue\n\n\nResidueBondSpec\nInformation about one bond in a residue\n\n\nResidueImproperSpec\nInformation about one imroper dihedral in a residue\n\n\nResidueProperSpec\nInformation about one imroper dihedral in a residue\n\n\nResidueType\nInformation about one residuetype from aminoacids.rtp\n\n\n\n\n\ntopology.atomic.Angle(ai, aj, ak, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one angle\nA class containing angle information as in the angles section of the topology.\nFrom gromacs topology: ‘;’, ‘ai’, ‘aj’, ‘ak’, ‘funct’, ‘c0’, ‘c1’, ‘c2’, ‘c3’ With aj &lt; ai &lt; ak\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nak\n\n\n\nc0\n\n\n\nc1\n\n\n\nc2\n\n\n\nc3\n\n\n\nfunct\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.Angle.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.AngleType(i, j, k, id, id_sym, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one angle\nA class containing angle information as in the angles section of the topology.\nFrom gromacs topology: ‘;’, ‘i’, ‘j’, ‘k’, ‘funct’, ‘c0’, ‘c1’, ‘c2’, ‘c3’ where i,j,k are atomtypes\n\n\n\n\n\nName\nDescription\n\n\n\n\nc0\n\n\n\nc1\n\n\n\nc2\n\n\n\nc3\n\n\n\nfunct\n\n\n\ni\n\n\n\nid\n\n\n\nid_sym\n\n\n\nj\n\n\n\nk\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.AngleType.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.Atom(nr, type, resnr, residue, atom, cgnr, charge, mass, typeB=None, chargeB=None, massB=None, bound_to_nrs=field(default_factory=list), is_radical=False)\nInformation about one atom\nA class containing atom information as in the atoms section of the topology. An atom keeps a list of which atoms it is bound to.\nFrom gromacs topology: ; nr type resnr residue atom cgnr charge mass typeB chargeB massB\n\n\n\n\n\nName\nDescription\n\n\n\n\natom\n\n\n\nbound_to_nrs\n\n\n\ncgnr\n\n\n\ncharge\n\n\n\nchargeB\n\n\n\nis_radical\n\n\n\nmass\n\n\n\nmassB\n\n\n\nnr\n\n\n\nresidue\n\n\n\nresnr\n\n\n\ntype\n\n\n\ntypeB\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\nradical_type\n\n\n\n\n\n\ntopology.atomic.Atom.from_top_line(cls, l)\n\n\n\ntopology.atomic.Atom.radical_type(self)\n\n\n\n\n\ntopology.atomic.AtomType(type, id_sym, at_num, mass, charge, ptype, sigma, epsilon, id)\nInformation about one atom\nA class containing atom information as in the atoms section of the topology. An atom keeps a list of which atoms it is bound to.\nFrom gromacs version of the amber* ff: ; name at.num mass charge ptype sigma epsilon\n\n\n\n\n\nName\nDescription\n\n\n\n\nat_num\n\n\n\ncharge\n\n\n\nepsilon\n\n\n\nid\n\n\n\nid_sym\n\n\n\nmass\n\n\n\nptype\n\n\n\nsigma\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.AtomType.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.Bond(ai, aj, funct, c0=None, c1=None, c2=None, c3=None, c4=None, c5=None)\nInformation about one bond\nA class containing bond information as in the bonds section of the topology. From gromacs topology: ‘ai’, ‘aj’, ‘funct’, ‘c0’, ‘c1’, ‘c2’, ‘c3’, ‘c4’, ‘c5’ With ai &lt; aj\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nc0\n\n\n\nc1\n\n\n\nc2\n\n\n\nc3\n\n\n\nc4\n\n\n\nc5\n\n\n\nfunct\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.Bond.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.BondType(i, j, id, id_sym, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one bondtype\nA class containing bond information as in the bonds section of the topology. From gromacs topology: ‘i’, ‘j’, ‘funct’, ‘c0’, ‘c1’, ‘c2’, ’c3 Where i and j are atomtypes\n\n\n\n\n\nName\nDescription\n\n\n\n\nc0\n\n\n\nc1\n\n\n\nc2\n\n\n\nc3\n\n\n\nfunct\n\n\n\ni\n\n\n\nid\n\n\n\nid_sym\n\n\n\nj\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.BondType.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.Dihedral(ai, aj, ak, al, funct, c0=None, c1=None, periodicity='', c3=None, c4=None, c5=None)\nInformation about one proper or improper dihedral\nA class containing bond information as in the dihedrals section of the topology. Improper dihedrals have funct 4. Proper dihedrals have funct != 4. Mostly funct 9.\nNote that proper dihedrals of type 9 can be defined multiple times, for different periodicities. This is why would-be parameter c2 is called periodicity.\nFrom gromacs topology: ‘;’, ‘ai’, ‘aj’, ‘ak’, ‘al’, ‘funct’, ‘c0’, ‘c1’, ‘periodicity’, ‘c3’, ‘c4’, ‘c5’ For proper dihedrals (funct 9): aj &lt; ak\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nak\n\n\n\nal\n\n\n\nc0\n\n\n\nc1\n\n\n\nc3\n\n\n\nc4\n\n\n\nc5\n\n\n\nfunct\n\n\n\nperiodicity\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.Dihedral.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.DihedralRestraint(ai, aj, ak, al, type, phi, dphi, fc)\nInformation about one dihedral restraint.\nA class containing information as in the dihedral_restraints section of the topology.\nFrom gromacs topology: ; ai aj ak al type phi dphi fc\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nak\n\n\n\nal\n\n\n\ndphi\n\n\n\nfc\n\n\n\nphi\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.DihedralRestraint.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.DihedralType(i, j, k, l, id, id_sym, funct, c0, c1, periodicity, c3=None, c4=None, c5=None)\nInformation about one dihedral\nA class containing bond information as in the dihedrals section of the topology. Proper dihedrals have funct 9. Improper dihedrals have funct 4.\nNote that proper dihedrals of type 9 can be defined multiple times, for different periodicities. This is why would-be parameter c2 is called periodicity and part of the id.\nFrom gromacs topology: ‘;’, ‘i’, ‘j’, ‘k’, ‘l’, ‘funct’, ‘c0’, ‘c1’, ‘periodicity’, ‘c3’, ‘c4’, ‘c5’ Where i,j,k,l are atomtypes\n\n\n\n\n\nName\nDescription\n\n\n\n\nc0\n\n\n\nc1\n\n\n\nc3\n\n\n\nc4\n\n\n\nc5\n\n\n\nfunct\n\n\n\ni\n\n\n\nid\n\n\n\nid_sym\n\n\n\nj\n\n\n\nk\n\n\n\nl\n\n\n\nperiodicity\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.DihedralType.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.MultipleDihedralTypes(ai, aj, ak, al, funct, dihedral_types)\nMultiple DihedralTypess with the same ai, aj, ak, al but different periodicities. funct should always be “9” when the length of dihedrals is &gt; 1. The key of the dict is the periodicity (c2).\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nak\n\n\n\nal\n\n\n\ndihedral_types\n\n\n\nfunct\n\n\n\n\n\n\n\n\ntopology.atomic.MultipleDihedrals(ai, aj, ak, al, funct, dihedrals)\nMultiple Dihedrals with the same ai, aj, ak, al but different periodicities. funct should always be “9” when the length of dihedrals is &gt; 1. The key of the dict is the periodicity (c2).\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nak\n\n\n\nal\n\n\n\ndihedrals\n\n\n\nfunct\n\n\n\n\n\n\n\n\ntopology.atomic.Pair(ai, aj, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one pair\nA class containing pair information as in the pair section of the topology.\nFrom gromacs topology: ai’, ‘aj’, ‘funct’, ‘c0’, ‘c1’, ‘c2’, ‘c3’\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nc0\n\n\n\nc1\n\n\n\nc2\n\n\n\nc3\n\n\n\nfunct\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.Pair.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.PositionRestraint(ai, funct, fc, condition=None)\nInformation about one position restraint.\nA class containing information as in the position_restraints section of the topology.\nFrom gromacs topology: ; ai funct fc(x,y,z)\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\ncondition\n\n\n\nfc\n\n\n\nfunct\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.PositionRestraint.from_top_line(cls, l, condition=None)\n\n\n\n\n\ntopology.atomic.ResidueAtomSpec(name, type, charge, cgrp)\nInformation about one atom in a residue ; name type charge chargegroup\n\n\n\n\n\nName\nDescription\n\n\n\n\ncgrp\n\n\n\ncharge\n\n\n\nname\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.ResidueAtomSpec.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.ResidueBondSpec(atom1, atom2, b0=None, kb=None)\nInformation about one bond in a residue ; atom1 atom2 b0 kb\n\n\n\n\n\nName\nDescription\n\n\n\n\natom1\n\n\n\natom2\n\n\n\nb0\n\n\n\nkb\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.ResidueBondSpec.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.ResidueImproperSpec(atom1, atom2, atom3, atom4, q0, cq)\nInformation about one imroper dihedral in a residue ;atom1 atom2 atom3 atom4 q0 cq\n\n\n\n\n\nName\nDescription\n\n\n\n\natom1\n\n\n\natom2\n\n\n\natom3\n\n\n\natom4\n\n\n\ncq\n\n\n\nq0\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.ResidueImproperSpec.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.ResidueProperSpec(atom1, atom2, atom3, atom4, q0)\nInformation about one imroper dihedral in a residue ;atom1 atom2 atom3 atom4 q0 cq\n\n\n\n\n\nName\nDescription\n\n\n\n\natom1\n\n\n\natom2\n\n\n\natom3\n\n\n\natom4\n\n\n\nq0\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.ResidueProperSpec.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.ResidueType(residue, atoms, bonds, proper_dihedrals, improper_dihedrals)\nInformation about one residuetype from aminoacids.rtp\n\n\n\n\n\nName\nDescription\n\n\n\n\natoms\n\n\n\nbonds\n\n\n\nimproper_dihedrals\n\n\n\nproper_dihedrals\n\n\n\nresidue\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_section\n\n\n\n\n\n\ntopology.atomic.ResidueType.from_section(cls, residue, d)"
  },
  {
    "objectID": "_reference/topology.atomic.html#attributes",
    "href": "_reference/topology.atomic.html#attributes",
    "title": "topology.atomic",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAngleId\n\n\n\nAtomId\n\n\n\nAtomic\n\n\n\nAtomicType\n\n\n\nAtomicTypes\n\n\n\nBondId\n\n\n\nDihedralId"
  },
  {
    "objectID": "_reference/topology.atomic.html#classes",
    "href": "_reference/topology.atomic.html#classes",
    "title": "topology.atomic",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAngle\nInformation about one angle\n\n\nAngleType\nInformation about one angle\n\n\nAtom\nInformation about one atom\n\n\nAtomType\nInformation about one atom\n\n\nBond\nInformation about one bond\n\n\nBondType\nInformation about one bondtype\n\n\nDihedral\nInformation about one proper or improper dihedral\n\n\nDihedralRestraint\nInformation about one dihedral restraint.\n\n\nDihedralType\nInformation about one dihedral\n\n\nMultipleDihedralTypes\nMultiple DihedralTypess with the same ai, aj, ak, al\n\n\nMultipleDihedrals\nMultiple Dihedrals with the same ai, aj, ak, al\n\n\nPair\nInformation about one pair\n\n\nPositionRestraint\nInformation about one position restraint.\n\n\nResidueAtomSpec\nInformation about one atom in a residue\n\n\nResidueBondSpec\nInformation about one bond in a residue\n\n\nResidueImproperSpec\nInformation about one imroper dihedral in a residue\n\n\nResidueProperSpec\nInformation about one imroper dihedral in a residue\n\n\nResidueType\nInformation about one residuetype from aminoacids.rtp\n\n\n\n\n\ntopology.atomic.Angle(ai, aj, ak, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one angle\nA class containing angle information as in the angles section of the topology.\nFrom gromacs topology: ‘;’, ‘ai’, ‘aj’, ‘ak’, ‘funct’, ‘c0’, ‘c1’, ‘c2’, ‘c3’ With aj &lt; ai &lt; ak\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nak\n\n\n\nc0\n\n\n\nc1\n\n\n\nc2\n\n\n\nc3\n\n\n\nfunct\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.Angle.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.AngleType(i, j, k, id, id_sym, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one angle\nA class containing angle information as in the angles section of the topology.\nFrom gromacs topology: ‘;’, ‘i’, ‘j’, ‘k’, ‘funct’, ‘c0’, ‘c1’, ‘c2’, ‘c3’ where i,j,k are atomtypes\n\n\n\n\n\nName\nDescription\n\n\n\n\nc0\n\n\n\nc1\n\n\n\nc2\n\n\n\nc3\n\n\n\nfunct\n\n\n\ni\n\n\n\nid\n\n\n\nid_sym\n\n\n\nj\n\n\n\nk\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.AngleType.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.Atom(nr, type, resnr, residue, atom, cgnr, charge, mass, typeB=None, chargeB=None, massB=None, bound_to_nrs=field(default_factory=list), is_radical=False)\nInformation about one atom\nA class containing atom information as in the atoms section of the topology. An atom keeps a list of which atoms it is bound to.\nFrom gromacs topology: ; nr type resnr residue atom cgnr charge mass typeB chargeB massB\n\n\n\n\n\nName\nDescription\n\n\n\n\natom\n\n\n\nbound_to_nrs\n\n\n\ncgnr\n\n\n\ncharge\n\n\n\nchargeB\n\n\n\nis_radical\n\n\n\nmass\n\n\n\nmassB\n\n\n\nnr\n\n\n\nresidue\n\n\n\nresnr\n\n\n\ntype\n\n\n\ntypeB\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\nradical_type\n\n\n\n\n\n\ntopology.atomic.Atom.from_top_line(cls, l)\n\n\n\ntopology.atomic.Atom.radical_type(self)\n\n\n\n\n\ntopology.atomic.AtomType(type, id_sym, at_num, mass, charge, ptype, sigma, epsilon, id)\nInformation about one atom\nA class containing atom information as in the atoms section of the topology. An atom keeps a list of which atoms it is bound to.\nFrom gromacs version of the amber* ff: ; name at.num mass charge ptype sigma epsilon\n\n\n\n\n\nName\nDescription\n\n\n\n\nat_num\n\n\n\ncharge\n\n\n\nepsilon\n\n\n\nid\n\n\n\nid_sym\n\n\n\nmass\n\n\n\nptype\n\n\n\nsigma\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.AtomType.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.Bond(ai, aj, funct, c0=None, c1=None, c2=None, c3=None, c4=None, c5=None)\nInformation about one bond\nA class containing bond information as in the bonds section of the topology. From gromacs topology: ‘ai’, ‘aj’, ‘funct’, ‘c0’, ‘c1’, ‘c2’, ‘c3’, ‘c4’, ‘c5’ With ai &lt; aj\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nc0\n\n\n\nc1\n\n\n\nc2\n\n\n\nc3\n\n\n\nc4\n\n\n\nc5\n\n\n\nfunct\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.Bond.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.BondType(i, j, id, id_sym, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one bondtype\nA class containing bond information as in the bonds section of the topology. From gromacs topology: ‘i’, ‘j’, ‘funct’, ‘c0’, ‘c1’, ‘c2’, ’c3 Where i and j are atomtypes\n\n\n\n\n\nName\nDescription\n\n\n\n\nc0\n\n\n\nc1\n\n\n\nc2\n\n\n\nc3\n\n\n\nfunct\n\n\n\ni\n\n\n\nid\n\n\n\nid_sym\n\n\n\nj\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.BondType.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.Dihedral(ai, aj, ak, al, funct, c0=None, c1=None, periodicity='', c3=None, c4=None, c5=None)\nInformation about one proper or improper dihedral\nA class containing bond information as in the dihedrals section of the topology. Improper dihedrals have funct 4. Proper dihedrals have funct != 4. Mostly funct 9.\nNote that proper dihedrals of type 9 can be defined multiple times, for different periodicities. This is why would-be parameter c2 is called periodicity.\nFrom gromacs topology: ‘;’, ‘ai’, ‘aj’, ‘ak’, ‘al’, ‘funct’, ‘c0’, ‘c1’, ‘periodicity’, ‘c3’, ‘c4’, ‘c5’ For proper dihedrals (funct 9): aj &lt; ak\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nak\n\n\n\nal\n\n\n\nc0\n\n\n\nc1\n\n\n\nc3\n\n\n\nc4\n\n\n\nc5\n\n\n\nfunct\n\n\n\nperiodicity\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.Dihedral.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.DihedralRestraint(ai, aj, ak, al, type, phi, dphi, fc)\nInformation about one dihedral restraint.\nA class containing information as in the dihedral_restraints section of the topology.\nFrom gromacs topology: ; ai aj ak al type phi dphi fc\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nak\n\n\n\nal\n\n\n\ndphi\n\n\n\nfc\n\n\n\nphi\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.DihedralRestraint.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.DihedralType(i, j, k, l, id, id_sym, funct, c0, c1, periodicity, c3=None, c4=None, c5=None)\nInformation about one dihedral\nA class containing bond information as in the dihedrals section of the topology. Proper dihedrals have funct 9. Improper dihedrals have funct 4.\nNote that proper dihedrals of type 9 can be defined multiple times, for different periodicities. This is why would-be parameter c2 is called periodicity and part of the id.\nFrom gromacs topology: ‘;’, ‘i’, ‘j’, ‘k’, ‘l’, ‘funct’, ‘c0’, ‘c1’, ‘periodicity’, ‘c3’, ‘c4’, ‘c5’ Where i,j,k,l are atomtypes\n\n\n\n\n\nName\nDescription\n\n\n\n\nc0\n\n\n\nc1\n\n\n\nc3\n\n\n\nc4\n\n\n\nc5\n\n\n\nfunct\n\n\n\ni\n\n\n\nid\n\n\n\nid_sym\n\n\n\nj\n\n\n\nk\n\n\n\nl\n\n\n\nperiodicity\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.DihedralType.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.MultipleDihedralTypes(ai, aj, ak, al, funct, dihedral_types)\nMultiple DihedralTypess with the same ai, aj, ak, al but different periodicities. funct should always be “9” when the length of dihedrals is &gt; 1. The key of the dict is the periodicity (c2).\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nak\n\n\n\nal\n\n\n\ndihedral_types\n\n\n\nfunct\n\n\n\n\n\n\n\n\ntopology.atomic.MultipleDihedrals(ai, aj, ak, al, funct, dihedrals)\nMultiple Dihedrals with the same ai, aj, ak, al but different periodicities. funct should always be “9” when the length of dihedrals is &gt; 1. The key of the dict is the periodicity (c2).\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nak\n\n\n\nal\n\n\n\ndihedrals\n\n\n\nfunct\n\n\n\n\n\n\n\n\ntopology.atomic.Pair(ai, aj, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one pair\nA class containing pair information as in the pair section of the topology.\nFrom gromacs topology: ai’, ‘aj’, ‘funct’, ‘c0’, ‘c1’, ‘c2’, ‘c3’\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nc0\n\n\n\nc1\n\n\n\nc2\n\n\n\nc3\n\n\n\nfunct\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.Pair.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.PositionRestraint(ai, funct, fc, condition=None)\nInformation about one position restraint.\nA class containing information as in the position_restraints section of the topology.\nFrom gromacs topology: ; ai funct fc(x,y,z)\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\ncondition\n\n\n\nfc\n\n\n\nfunct\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.PositionRestraint.from_top_line(cls, l, condition=None)\n\n\n\n\n\ntopology.atomic.ResidueAtomSpec(name, type, charge, cgrp)\nInformation about one atom in a residue ; name type charge chargegroup\n\n\n\n\n\nName\nDescription\n\n\n\n\ncgrp\n\n\n\ncharge\n\n\n\nname\n\n\n\ntype\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.ResidueAtomSpec.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.ResidueBondSpec(atom1, atom2, b0=None, kb=None)\nInformation about one bond in a residue ; atom1 atom2 b0 kb\n\n\n\n\n\nName\nDescription\n\n\n\n\natom1\n\n\n\natom2\n\n\n\nb0\n\n\n\nkb\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.ResidueBondSpec.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.ResidueImproperSpec(atom1, atom2, atom3, atom4, q0, cq)\nInformation about one imroper dihedral in a residue ;atom1 atom2 atom3 atom4 q0 cq\n\n\n\n\n\nName\nDescription\n\n\n\n\natom1\n\n\n\natom2\n\n\n\natom3\n\n\n\natom4\n\n\n\ncq\n\n\n\nq0\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.ResidueImproperSpec.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.ResidueProperSpec(atom1, atom2, atom3, atom4, q0)\nInformation about one imroper dihedral in a residue ;atom1 atom2 atom3 atom4 q0 cq\n\n\n\n\n\nName\nDescription\n\n\n\n\natom1\n\n\n\natom2\n\n\n\natom3\n\n\n\natom4\n\n\n\nq0\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_top_line\n\n\n\n\n\n\ntopology.atomic.ResidueProperSpec.from_top_line(cls, l)\n\n\n\n\n\ntopology.atomic.ResidueType(residue, atoms, bonds, proper_dihedrals, improper_dihedrals)\nInformation about one residuetype from aminoacids.rtp\n\n\n\n\n\nName\nDescription\n\n\n\n\natoms\n\n\n\nbonds\n\n\n\nimproper_dihedrals\n\n\n\nproper_dihedrals\n\n\n\nresidue\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_section\n\n\n\n\n\n\ntopology.atomic.ResidueType.from_section(cls, residue, d)"
  },
  {
    "objectID": "_reference/topology.utils.html",
    "href": "_reference/topology.utils.html",
    "title": "topology.utils",
    "section": "",
    "text": "topology.utils\n\n\n\n\n\nName\nDescription\n\n\n\n\nattributes_to_list\n\n\n\nfield_or_none\n\n\n\nget_by_permutations\n\n\n\nget_element_id\n\n\n\nget_protein_section\nGet content of a section in the first moleculetype (protein) from a topology dict.\n\n\nget_top_section\nGet content of a section from a topology dict.\n\n\nis_not_none\n\n\n\nmatch_atomic_item_to_atomic_type\n\n\n\nmatch_attr\n\n\n\nmatch_id_to_patch\n\n\n\nmatch_multi_attr\n\n\n\nset_protein_section\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\nset_top_section\nSet content of a section from a topology dict.\n\n\n\n\n\ntopology.utils.attributes_to_list(obj)\n\n\n\ntopology.utils.field_or_none(l, i)\n\n\n\ntopology.utils.get_by_permutations(d, key)\n\n\n\ntopology.utils.get_element_id(e)\n\n\n\ntopology.utils.get_protein_section(top, name)\nGet content of a section in the first moleculetype (protein) from a topology dict.\n\n\n\ntopology.utils.get_top_section(top, name, moleculetype=None)\nGet content of a section from a topology dict. By resolving any #ifdef statements by check in the top[‘define’] dict and choosing the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.is_not_none(x)\n\n\n\ntopology.utils.match_atomic_item_to_atomic_type(id, types)\n\n\n\ntopology.utils.match_attr(patches, attr, m)\n\n\n\ntopology.utils.match_id_to_patch(id, patches)\n\n\n\ntopology.utils.match_multi_attr(patches, attrs, m)\n\n\n\ntopology.utils.set_protein_section(top, name, value)\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\n\ntopology.utils.set_top_section(top, name, value, moleculetype=None)\nSet content of a section from a topology dict. By resolving any #ifdef statements by check in the top[‘define’] dict and choosing the ‘content’ or ‘else_content’ depending on the result."
  },
  {
    "objectID": "_reference/topology.utils.html#functions",
    "href": "_reference/topology.utils.html#functions",
    "title": "topology.utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nattributes_to_list\n\n\n\nfield_or_none\n\n\n\nget_by_permutations\n\n\n\nget_element_id\n\n\n\nget_protein_section\nGet content of a section in the first moleculetype (protein) from a topology dict.\n\n\nget_top_section\nGet content of a section from a topology dict.\n\n\nis_not_none\n\n\n\nmatch_atomic_item_to_atomic_type\n\n\n\nmatch_attr\n\n\n\nmatch_id_to_patch\n\n\n\nmatch_multi_attr\n\n\n\nset_protein_section\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\nset_top_section\nSet content of a section from a topology dict.\n\n\n\n\n\ntopology.utils.attributes_to_list(obj)\n\n\n\ntopology.utils.field_or_none(l, i)\n\n\n\ntopology.utils.get_by_permutations(d, key)\n\n\n\ntopology.utils.get_element_id(e)\n\n\n\ntopology.utils.get_protein_section(top, name)\nGet content of a section in the first moleculetype (protein) from a topology dict.\n\n\n\ntopology.utils.get_top_section(top, name, moleculetype=None)\nGet content of a section from a topology dict. By resolving any #ifdef statements by check in the top[‘define’] dict and choosing the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.is_not_none(x)\n\n\n\ntopology.utils.match_atomic_item_to_atomic_type(id, types)\n\n\n\ntopology.utils.match_attr(patches, attr, m)\n\n\n\ntopology.utils.match_id_to_patch(id, patches)\n\n\n\ntopology.utils.match_multi_attr(patches, attrs, m)\n\n\n\ntopology.utils.set_protein_section(top, name, value)\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\n\ntopology.utils.set_top_section(top, name, value, moleculetype=None)\nSet content of a section from a topology dict. By resolving any #ifdef statements by check in the top[‘define’] dict and choosing the ‘content’ or ‘else_content’ depending on the result."
  },
  {
    "objectID": "_reference/reactions.homolysis.html",
    "href": "_reference/reactions.homolysis.html",
    "title": "reactions.homolysis",
    "section": "",
    "text": "reactions.homolysis\n\n\n\n\n\nName\nDescription\n\n\n\n\nHomolysis\nHomolytic bond breaking leading to 2 radicals.\n\n\n\n\n\nreactions.homolysis.Homolysis()\nHomolytic bond breaking leading to 2 radicals. Implementation for time-varying rates\n\n\n\n\n\nName\nDescription\n\n\n\n\ntype_scheme\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_recipe_collection\n\n\n\n\n\n\nreactions.homolysis.Homolysis.get_recipe_collection(self, files)"
  },
  {
    "objectID": "_reference/reactions.homolysis.html#classes",
    "href": "_reference/reactions.homolysis.html#classes",
    "title": "reactions.homolysis",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nHomolysis\nHomolytic bond breaking leading to 2 radicals.\n\n\n\n\n\nreactions.homolysis.Homolysis()\nHomolytic bond breaking leading to 2 radicals. Implementation for time-varying rates\n\n\n\n\n\nName\nDescription\n\n\n\n\ntype_scheme\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_recipe_collection\n\n\n\n\n\n\nreactions.homolysis.Homolysis.get_recipe_collection(self, files)"
  },
  {
    "objectID": "_reference/changemanager.html",
    "href": "_reference/changemanager.html",
    "title": "changemanager",
    "section": "",
    "text": "changemanager\nThe changemanager module holds functions that modify the system to accomodate recipes. This includes the topolgy and coordinates as well miscelaneaous files used by e.g. the gromacs extension PLUMED as input.\nTODO: some functions in here take TaskFiles, some take their inputs directly. Need to unify.\n\n\n\n\n\nName\nDescription\n\n\n\n\nbreak_bond_plumed\n\n\n\nmodify_coords\nModify the coordinates of the system according to the recipe steps.\n\n\nmodify_plumed\nModify plumed input files.\n\n\nmodify_top\nModify the topology of the system according to the recipe steps.\n\n\n\n\n\nchangemanager.break_bond_plumed(plumeddat, breakpair, plumeddist)\n\n\n\nchangemanager.modify_coords(recipe_steps, files, topA, topB)\nModify the coordinates of the system according to the recipe steps.\nNew coordinates are generated by merging topA and topB and interpolating between them in a MD simulation.\nTODO: the previous sentence is a lie right now, the MD step happens in a different function as its own task, so this function does not actually modify any coordinates, contrary to its name. We should either change the name or make it do what it says it does.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_steps\nlist[kimmdy.reaction.RecipeStep]\nA list of Task RecipeStep where each steps contains a new_coords parameter.\nrequired\n\n\nfiles\nTaskFiles\nInput and output files for this Task. files.input: - trr - tpr files.outputdir files.output: - trr - gro\nrequired\n\n\ntopA\nTopology\nPrevious Topology\nrequired\n\n\ntopB\nTopology\nParameter-adjusted Topology\nrequired\n\n\n\n\n\n\n\nchangemanager.modify_plumed(recipe_steps, oldplumeddat, newplumeddat, plumeddist)\nModify plumed input files.\nTODO: finish this function.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_steps\nlist[kimmdy.reaction.RecipeStep]\nA list of RecipeSteps. parameter.\nrequired\n\n\n\n\n\n\n\nchangemanager.modify_top(recipe_steps, files, ffpatch, topology)\nModify the topology of the system according to the recipe steps.\nModifies the topology in place and also writes the new topology to a file to be used by external programs (gromacs).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_steps\nlist[kimmdy.reaction.RecipeStep]\nA list of RecipeSteps. parameter.\nrequired\n\n\nfiles\nTaskFiles\nInput and output files for this Task. files.input: - top files.output: - top\nrequired\n\n\nffpatch\ntyping.Optional[pathlib.Path]\nTODO: deprecate\nrequired\n\n\ntopology\ntyping.Optional[kimmdy.topology.topology.Topology]\nTODO: make this required instead of optional\nrequired"
  },
  {
    "objectID": "_reference/changemanager.html#functions",
    "href": "_reference/changemanager.html#functions",
    "title": "changemanager",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbreak_bond_plumed\n\n\n\nmodify_coords\nModify the coordinates of the system according to the recipe steps.\n\n\nmodify_plumed\nModify plumed input files.\n\n\nmodify_top\nModify the topology of the system according to the recipe steps.\n\n\n\n\n\nchangemanager.break_bond_plumed(plumeddat, breakpair, plumeddist)\n\n\n\nchangemanager.modify_coords(recipe_steps, files, topA, topB)\nModify the coordinates of the system according to the recipe steps.\nNew coordinates are generated by merging topA and topB and interpolating between them in a MD simulation.\nTODO: the previous sentence is a lie right now, the MD step happens in a different function as its own task, so this function does not actually modify any coordinates, contrary to its name. We should either change the name or make it do what it says it does.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_steps\nlist[kimmdy.reaction.RecipeStep]\nA list of Task RecipeStep where each steps contains a new_coords parameter.\nrequired\n\n\nfiles\nTaskFiles\nInput and output files for this Task. files.input: - trr - tpr files.outputdir files.output: - trr - gro\nrequired\n\n\ntopA\nTopology\nPrevious Topology\nrequired\n\n\ntopB\nTopology\nParameter-adjusted Topology\nrequired\n\n\n\n\n\n\n\nchangemanager.modify_plumed(recipe_steps, oldplumeddat, newplumeddat, plumeddist)\nModify plumed input files.\nTODO: finish this function.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_steps\nlist[kimmdy.reaction.RecipeStep]\nA list of RecipeSteps. parameter.\nrequired\n\n\n\n\n\n\n\nchangemanager.modify_top(recipe_steps, files, ffpatch, topology)\nModify the topology of the system according to the recipe steps.\nModifies the topology in place and also writes the new topology to a file to be used by external programs (gromacs).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_steps\nlist[kimmdy.reaction.RecipeStep]\nA list of RecipeSteps. parameter.\nrequired\n\n\nfiles\nTaskFiles\nInput and output files for this Task. files.input: - top files.output: - top\nrequired\n\n\nffpatch\ntyping.Optional[pathlib.Path]\nTODO: deprecate\nrequired\n\n\ntopology\ntyping.Optional[kimmdy.topology.topology.Topology]\nTODO: make this required instead of optional\nrequired"
  },
  {
    "objectID": "_reference/topology.ff.html",
    "href": "_reference/topology.ff.html",
    "title": "topology.ff",
    "section": "",
    "text": "topology.ff\n\n\n\n\n\nName\nDescription\n\n\n\n\nPatch\n\n\n\nPatches\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nAnglePatch\nInstructions to patch one angle\n\n\nAtomPatch\nInstructions to patch one atom\n\n\nBondPatch\nInstructions to patch one bond\n\n\nDihedralPatch\nInstructions to patch one dihedral\n\n\nFF\nConainer for parsed forcefield data.\n\n\nFFPatches\nA container for forcefield patches\n\n\nPairPatch\nInstructions to patch one pair\n\n\nParamPatch\n\n\n\n\n\n\ntopology.ff.AnglePatch(self, elem)\nInstructions to patch one angle\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nak\n\n\n\nid\n\n\n\nid_sym\n\n\n\nparams\n\n\n\n\n\n\n\n\ntopology.ff.AtomPatch(self, elem)\nInstructions to patch one atom\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\nid\n\n\n\nid_sym\n\n\n\nparams\n\n\n\n\n\n\n\n\ntopology.ff.BondPatch(self, elem)\nInstructions to patch one bond\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nid\n\n\n\nid_sym\n\n\n\nparams\n\n\n\n\n\n\n\n\ntopology.ff.DihedralPatch(self, elem)\nInstructions to patch one dihedral\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nak\n\n\n\nal\n\n\n\nfunc\n\n\n\nid\n\n\n\nid_sym\n\n\n\nparams\n\n\n\nperiodicity\n\n\n\n\n\n\n\n\ntopology.ff.FF(self, top)\nConainer for parsed forcefield data.\n\n\n\n\n\nName\nDescription\n\n\n\n\nangletypes\n\n\n\natomtypes\n\n\n\nbondtypes\n\n\n\nimproper_dihedraltypes\n\n\n\nproper_dihedraltypes\n\n\n\nresiduetypes\n\n\n\n\n\n\n\n\ntopology.ff.FFPatches(self, path)\nA container for forcefield patches\n\n\n\n\n\nName\nDescription\n\n\n\n\nanglepatches\n\n\n\natompatches\n\n\n\nbondpatches\n\n\n\ndihedralpatches\n\n\n\npairpatches\n\n\n\n\n\n\n\n\ntopology.ff.PairPatch(self, elem)\nInstructions to patch one pair\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nid\n\n\n\nid_sym\n\n\n\nparams\n\n\n\n\n\n\n\n\ntopology.ff.ParamPatch()\n\n\n\n\n\nName\nDescription\n\n\n\n\nfactor\n\n\n\noffset\n\n\n\nvalue\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\napply\n\n\n\nupdate\n\n\n\n\n\n\ntopology.ff.ParamPatch.apply(self, initial)\n\n\n\ntopology.ff.ParamPatch.update(self, new)\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nprops_to_patches\n\n\n\n\n\n\ntopology.ff.props_to_patches(props)"
  },
  {
    "objectID": "_reference/topology.ff.html#attributes",
    "href": "_reference/topology.ff.html#attributes",
    "title": "topology.ff",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nPatch\n\n\n\nPatches"
  },
  {
    "objectID": "_reference/topology.ff.html#classes",
    "href": "_reference/topology.ff.html#classes",
    "title": "topology.ff",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAnglePatch\nInstructions to patch one angle\n\n\nAtomPatch\nInstructions to patch one atom\n\n\nBondPatch\nInstructions to patch one bond\n\n\nDihedralPatch\nInstructions to patch one dihedral\n\n\nFF\nConainer for parsed forcefield data.\n\n\nFFPatches\nA container for forcefield patches\n\n\nPairPatch\nInstructions to patch one pair\n\n\nParamPatch\n\n\n\n\n\n\ntopology.ff.AnglePatch(self, elem)\nInstructions to patch one angle\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nak\n\n\n\nid\n\n\n\nid_sym\n\n\n\nparams\n\n\n\n\n\n\n\n\ntopology.ff.AtomPatch(self, elem)\nInstructions to patch one atom\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\nid\n\n\n\nid_sym\n\n\n\nparams\n\n\n\n\n\n\n\n\ntopology.ff.BondPatch(self, elem)\nInstructions to patch one bond\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nid\n\n\n\nid_sym\n\n\n\nparams\n\n\n\n\n\n\n\n\ntopology.ff.DihedralPatch(self, elem)\nInstructions to patch one dihedral\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nak\n\n\n\nal\n\n\n\nfunc\n\n\n\nid\n\n\n\nid_sym\n\n\n\nparams\n\n\n\nperiodicity\n\n\n\n\n\n\n\n\ntopology.ff.FF(self, top)\nConainer for parsed forcefield data.\n\n\n\n\n\nName\nDescription\n\n\n\n\nangletypes\n\n\n\natomtypes\n\n\n\nbondtypes\n\n\n\nimproper_dihedraltypes\n\n\n\nproper_dihedraltypes\n\n\n\nresiduetypes\n\n\n\n\n\n\n\n\ntopology.ff.FFPatches(self, path)\nA container for forcefield patches\n\n\n\n\n\nName\nDescription\n\n\n\n\nanglepatches\n\n\n\natompatches\n\n\n\nbondpatches\n\n\n\ndihedralpatches\n\n\n\npairpatches\n\n\n\n\n\n\n\n\ntopology.ff.PairPatch(self, elem)\nInstructions to patch one pair\n\n\n\n\n\nName\nDescription\n\n\n\n\nai\n\n\n\naj\n\n\n\nid\n\n\n\nid_sym\n\n\n\nparams\n\n\n\n\n\n\n\n\ntopology.ff.ParamPatch()\n\n\n\n\n\nName\nDescription\n\n\n\n\nfactor\n\n\n\noffset\n\n\n\nvalue\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\napply\n\n\n\nupdate\n\n\n\n\n\n\ntopology.ff.ParamPatch.apply(self, initial)\n\n\n\ntopology.ff.ParamPatch.update(self, new)"
  },
  {
    "objectID": "_reference/topology.ff.html#functions",
    "href": "_reference/topology.ff.html#functions",
    "title": "topology.ff",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nprops_to_patches\n\n\n\n\n\n\ntopology.ff.props_to_patches(props)"
  },
  {
    "objectID": "_reference/index.html",
    "href": "_reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "Start KIMMDY from a python script or the command line\n\n\n\ncmd\nFunctions for starting KIMMDY either from python or the command line.\n\n\n\n\n\n\nTopology modules\n\n\n\ntopology.topology\n\n\n\ntopology.ff\n\n\n\ntopology.utils\n\n\n\ntopology.atomic\nAtomic datatypes for the topology such as Atom, Bond, Angle, Dihedral, etc.\n\n\n\n\n\n\nReaction plugins bundled with KIMMDY and the protocol to add a new reaction plugin to KIMMDY\n\n\n\nreaction\nReactionPlugin protocoll and reaction recipes.\n\n\nreactions.homolysis\n\n\n\n\n\n\n\nModules\n\n\n\nchangemanager\nThe changemanager module holds functions that modify the system\n\n\nconstants\nComstants used throughout KIMMDY\n\n\ncoordinates\nTODO: WIP\n\n\nconfig\nRead and validate kimmdy.yml configuration files\n\n\nkmc\nKinetic Monte Carlo (KMC) classes and functions.\n\n\nmisc_helper\nMiscelaneous utilitiies that didn’t fit anywhere else for now.\n\n\nparsing\nAll read_&lt;…&gt; and write_&lt;…&gt; functions.\n\n\nrunmanager\nThe Runmanager is the main entry point of the program.\n\n\ntasks\n\n\n\nutils"
  },
  {
    "objectID": "_reference/index.html#api",
    "href": "_reference/index.html#api",
    "title": "Function reference",
    "section": "",
    "text": "Start KIMMDY from a python script or the command line\n\n\n\ncmd\nFunctions for starting KIMMDY either from python or the command line."
  },
  {
    "objectID": "_reference/index.html#topology",
    "href": "_reference/index.html#topology",
    "title": "Function reference",
    "section": "",
    "text": "Topology modules\n\n\n\ntopology.topology\n\n\n\ntopology.ff\n\n\n\ntopology.utils\n\n\n\ntopology.atomic\nAtomic datatypes for the topology such as Atom, Bond, Angle, Dihedral, etc."
  },
  {
    "objectID": "_reference/index.html#reaction-plugins",
    "href": "_reference/index.html#reaction-plugins",
    "title": "Function reference",
    "section": "",
    "text": "Reaction plugins bundled with KIMMDY and the protocol to add a new reaction plugin to KIMMDY\n\n\n\nreaction\nReactionPlugin protocoll and reaction recipes.\n\n\nreactions.homolysis"
  },
  {
    "objectID": "_reference/index.html#modules",
    "href": "_reference/index.html#modules",
    "title": "Function reference",
    "section": "",
    "text": "Modules\n\n\n\nchangemanager\nThe changemanager module holds functions that modify the system\n\n\nconstants\nComstants used throughout KIMMDY\n\n\ncoordinates\nTODO: WIP\n\n\nconfig\nRead and validate kimmdy.yml configuration files\n\n\nkmc\nKinetic Monte Carlo (KMC) classes and functions.\n\n\nmisc_helper\nMiscelaneous utilitiies that didn’t fit anywhere else for now.\n\n\nparsing\nAll read_&lt;…&gt; and write_&lt;…&gt; functions.\n\n\nrunmanager\nThe Runmanager is the main entry point of the program.\n\n\ntasks\n\n\n\nutils"
  },
  {
    "objectID": "guide/getting-started.html",
    "href": "guide/getting-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "Let’s jump right in!\n\n\n\n\n\npython3.9 or higher\ngromacs (tested with version 2021.4, gmx should be available in the PATH)\n\nOptional:\n\nplumed-patched version of gromacs\n\n\n\n\n\nLet’s first create a virtual environment for kimmdy:\nmkdir kimmdy-tutorial\ncd kimmdy-tutorial\npython -m venv .venv\nsource .venv/bin/activate\nBecause we’ll be using optional reaction plugins directly from the git repository, we’ll need to install kimmdy from GitHub with the plugins extra:\n# TODO: update with https instead of ssh when repo is public\npip install 'git+ssh://git@github.com/hits-mbm-dev/kimmdy.git#egg=kimmdy'\npip install 'git+ssh://git@github.com/hits-mbm-dev/kimmdy.git#egg&subdirectory=plugins'\npip install '../../plugins'\n\n\n\nDownload the example kimmdy.yml file to this directory. It should look like this:\n\n\nkimmdy.yml\n\ndryrun: false\niterations: 100\nname: 'hat_tf_000'\ngromacs_alias: 'gmx'\ntop: 'Ala_out.top'\ngro: 'npt.gro'\nndx: 'index.ndx'\nmds:\n  equilibrium:\n    mdp: 'md.mdp'\n  relax:\n    mdp: 'md_slow.mdp'\nchanger:\n  coordinates:\n    md: 'relax'      \nreactions:\n  hat_reaction:\n    frequency_factor: 100000000\n    h_cutoff: 3\n    polling_rate: 1\n\nsequence:\n- equilibrium\n- mult: 2\n  tasks:\n  - equilibrium\n  - reactions\n\nLet’s also fetch the other input files:\n\nAla_out.top\nnpt.gro\ncat-center.gro\nindex.ndx\nmd.mdp\nmd_slow.mdp\nminim.mdp\n\nOr from the command line:\n# TODO: update when repo is public\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/Ala_out.top\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/npt.gro\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/cat-center.gro\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/index.ndx\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/md.mdp\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/md_slow.mdp\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/minim.mdp\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/kimmdy.yml\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/amber99sb-star-ildnp.ff\n\n# TODO: while dev, copy from example dir\ncp ../../example/example_ala/Ala_out.top .\ncp ../../example/example_ala/npt.gro .\ncp ../../example/example_ala/cat-center.gro .\ncp ../../example/example_ala/index.ndx .\ncp ../../example/example_ala/md.mdp .\ncp ../../example/example_ala/md_slow.mdp .\ncp ../../example/example_ala/minim.mdp .\ncp ../../example/example_ala/kimmdy.yml .\ncp -r ../../example/example_ala/amber99sb-star-ildnp.ff .\nOur starting structure is a simple ACE/NME-capped Alanine molecule in a box of water.\n    \n    \n    \nStart a KIMMDY run with kimmdy command:\n\n\n\nkimmdy\nYou can also run kimmdy directly from python with\nfrom kimmdy.cmd import kimmdy_run\nkimmdy_run()\n\n\n\nConcatenate the trajectories from the individual steps into one for viewing:\nkimmdy --concat\nor from python:\nkimmdy_run(concat = True)"
  },
  {
    "objectID": "guide/getting-started.html#installation",
    "href": "guide/getting-started.html#installation",
    "title": "Getting Started",
    "section": "",
    "text": "python3.9 or higher\ngromacs (tested with version 2021.4, gmx should be available in the PATH)\n\nOptional:\n\nplumed-patched version of gromacs"
  },
  {
    "objectID": "guide/getting-started.html#installation-1",
    "href": "guide/getting-started.html#installation-1",
    "title": "Getting Started",
    "section": "",
    "text": "Let’s first create a virtual environment for kimmdy:\nmkdir kimmdy-tutorial\ncd kimmdy-tutorial\npython -m venv .venv\nsource .venv/bin/activate\nBecause we’ll be using optional reaction plugins directly from the git repository, we’ll need to install kimmdy from GitHub with the plugins extra:\n# TODO: update with https instead of ssh when repo is public\npip install 'git+ssh://git@github.com/hits-mbm-dev/kimmdy.git#egg=kimmdy'\npip install 'git+ssh://git@github.com/hits-mbm-dev/kimmdy.git#egg&subdirectory=plugins'\npip install '../../plugins'"
  },
  {
    "objectID": "guide/getting-started.html#setup-the-simulation",
    "href": "guide/getting-started.html#setup-the-simulation",
    "title": "Getting Started",
    "section": "",
    "text": "Download the example kimmdy.yml file to this directory. It should look like this:\n\n\nkimmdy.yml\n\ndryrun: false\niterations: 100\nname: 'hat_tf_000'\ngromacs_alias: 'gmx'\ntop: 'Ala_out.top'\ngro: 'npt.gro'\nndx: 'index.ndx'\nmds:\n  equilibrium:\n    mdp: 'md.mdp'\n  relax:\n    mdp: 'md_slow.mdp'\nchanger:\n  coordinates:\n    md: 'relax'      \nreactions:\n  hat_reaction:\n    frequency_factor: 100000000\n    h_cutoff: 3\n    polling_rate: 1\n\nsequence:\n- equilibrium\n- mult: 2\n  tasks:\n  - equilibrium\n  - reactions\n\nLet’s also fetch the other input files:\n\nAla_out.top\nnpt.gro\ncat-center.gro\nindex.ndx\nmd.mdp\nmd_slow.mdp\nminim.mdp\n\nOr from the command line:\n# TODO: update when repo is public\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/Ala_out.top\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/npt.gro\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/cat-center.gro\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/index.ndx\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/md.mdp\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/md_slow.mdp\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/minim.mdp\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/kimmdy.yml\nwget https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/example/example_ala/amber99sb-star-ildnp.ff\n\n# TODO: while dev, copy from example dir\ncp ../../example/example_ala/Ala_out.top .\ncp ../../example/example_ala/npt.gro .\ncp ../../example/example_ala/cat-center.gro .\ncp ../../example/example_ala/index.ndx .\ncp ../../example/example_ala/md.mdp .\ncp ../../example/example_ala/md_slow.mdp .\ncp ../../example/example_ala/minim.mdp .\ncp ../../example/example_ala/kimmdy.yml .\ncp -r ../../example/example_ala/amber99sb-star-ildnp.ff .\nOur starting structure is a simple ACE/NME-capped Alanine molecule in a box of water.\n    \n    \n    \nStart a KIMMDY run with kimmdy command:"
  },
  {
    "objectID": "guide/getting-started.html#run-the-simulation",
    "href": "guide/getting-started.html#run-the-simulation",
    "title": "Getting Started",
    "section": "",
    "text": "kimmdy\nYou can also run kimmdy directly from python with\nfrom kimmdy.cmd import kimmdy_run\nkimmdy_run()"
  },
  {
    "objectID": "guide/getting-started.html#analyse-the-simulation",
    "href": "guide/getting-started.html#analyse-the-simulation",
    "title": "Getting Started",
    "section": "",
    "text": "Concatenate the trajectories from the individual steps into one for viewing:\nkimmdy --concat\nor from python:\nkimmdy_run(concat = True)"
  },
  {
    "objectID": "guide/topology.html",
    "href": "guide/topology.html",
    "title": "Hexala topology",
    "section": "",
    "text": "Hexala\n\nfrom kimmdy.parsing import read_top\nfrom kimmdy.topology.topology import Topology\nfrom pathlib import Path\nfrom kimmdy.misc_helper import top_to_graph\n\n\nala_top = read_top(Path('../tests/test_files/test_topology/hexala.top'))\ntop = Topology(ala_top)\n\nls = top_to_graph(top) \nwith open(\"ala-top.dot\", \"w\") as f:\n  f.writelines(ls)\n\n\n\n\n\n\n\n\n\nG\n\n  \n\n1 CT\n\n 1 CT   \n\n2 HC\n\n 2 HC   \n\n1 CT–2 HC\n\n   \n\n3 HC\n\n 3 HC   \n\n1 CT–3 HC\n\n   \n\n4 HC\n\n 4 HC   \n\n1 CT–4 HC\n\n   \n\n5 C\n\n 5 C   \n\n1 CT–5 C\n\n   \n\n6 O\n\n 6 O   \n\n5 C–6 O\n\n   \n\n7 N\n\n 7 N   \n\n5 C–7 N\n\n   \n\n8 H\n\n 8 H   \n\n7 N–8 H\n\n   \n\n9 CT\n\n 9 CT   \n\n7 N–9 CT\n\n   \n\n10 H1\n\n 10 H1   \n\n9 CT–10 H1\n\n   \n\n11 CT\n\n 11 CT   \n\n9 CT–11 CT\n\n   \n\n15 C\n\n 15 C   \n\n9 CT–15 C\n\n   \n\n12 HC\n\n 12 HC   \n\n11 CT–12 HC\n\n   \n\n13 HC\n\n 13 HC   \n\n11 CT–13 HC\n\n   \n\n14 HC\n\n 14 HC   \n\n11 CT–14 HC\n\n   \n\n16 O\n\n 16 O   \n\n15 C–16 O\n\n   \n\n17 N\n\n 17 N   \n\n15 C–17 N\n\n   \n\n18 H\n\n 18 H   \n\n17 N–18 H\n\n   \n\n19 CT\n\n 19 CT   \n\n17 N–19 CT\n\n   \n\n20 H1\n\n 20 H1   \n\n19 CT–20 H1\n\n   \n\n21 CT\n\n 21 CT   \n\n19 CT–21 CT\n\n   \n\n25 C\n\n 25 C   \n\n19 CT–25 C\n\n   \n\n22 HC\n\n 22 HC   \n\n21 CT–22 HC\n\n   \n\n23 HC\n\n 23 HC   \n\n21 CT–23 HC\n\n   \n\n24 HC\n\n 24 HC   \n\n21 CT–24 HC\n\n   \n\n26 O\n\n 26 O   \n\n25 C–26 O\n\n   \n\n27 N\n\n 27 N   \n\n25 C–27 N\n\n   \n\n28 H\n\n 28 H   \n\n27 N–28 H\n\n   \n\n29 CT\n\n 29 CT   \n\n27 N–29 CT\n\n   \n\n30 H1\n\n 30 H1   \n\n29 CT–30 H1\n\n   \n\n31 CT\n\n 31 CT   \n\n29 CT–31 CT\n\n   \n\n35 C\n\n 35 C   \n\n29 CT–35 C\n\n   \n\n32 HC\n\n 32 HC   \n\n31 CT–32 HC\n\n   \n\n33 HC\n\n 33 HC   \n\n31 CT–33 HC\n\n   \n\n34 HC\n\n 34 HC   \n\n31 CT–34 HC\n\n   \n\n36 O\n\n 36 O   \n\n35 C–36 O\n\n   \n\n37 N\n\n 37 N   \n\n35 C–37 N\n\n   \n\n38 H\n\n 38 H   \n\n37 N–38 H\n\n   \n\n39 CT\n\n 39 CT   \n\n37 N–39 CT\n\n   \n\n40 H1\n\n 40 H1   \n\n39 CT–40 H1\n\n   \n\n41 CT\n\n 41 CT   \n\n39 CT–41 CT\n\n   \n\n45 C\n\n 45 C   \n\n39 CT–45 C\n\n   \n\n42 HC\n\n 42 HC   \n\n41 CT–42 HC\n\n   \n\n43 HC\n\n 43 HC   \n\n41 CT–43 HC\n\n   \n\n44 HC\n\n 44 HC   \n\n41 CT–44 HC\n\n   \n\n46 O\n\n 46 O   \n\n45 C–46 O\n\n   \n\n47 N\n\n 47 N   \n\n45 C–47 N\n\n   \n\n48 H\n\n 48 H   \n\n47 N–48 H\n\n   \n\n49 CT\n\n 49 CT   \n\n47 N–49 CT\n\n   \n\n50 H1\n\n 50 H1   \n\n49 CT–50 H1\n\n   \n\n51 CT\n\n 51 CT   \n\n49 CT–51 CT\n\n   \n\n55 C\n\n 55 C   \n\n49 CT–55 C\n\n   \n\n52 HC\n\n 52 HC   \n\n51 CT–52 HC\n\n   \n\n53 HC\n\n 53 HC   \n\n51 CT–53 HC\n\n   \n\n54 HC\n\n 54 HC   \n\n51 CT–54 HC\n\n   \n\n56 O\n\n 56 O   \n\n55 C–56 O\n\n   \n\n57 N\n\n 57 N   \n\n55 C–57 N\n\n   \n\n58 H\n\n 58 H   \n\n57 N–58 H\n\n   \n\n59 CT\n\n 59 CT   \n\n57 N–59 CT\n\n   \n\n60 H1\n\n 60 H1   \n\n59 CT–60 H1\n\n   \n\n61 CT\n\n 61 CT   \n\n59 CT–61 CT\n\n   \n\n65 C\n\n 65 C   \n\n59 CT–65 C\n\n   \n\n62 HC\n\n 62 HC   \n\n61 CT–62 HC\n\n   \n\n63 HC\n\n 63 HC   \n\n61 CT–63 HC\n\n   \n\n64 HC\n\n 64 HC   \n\n61 CT–64 HC\n\n   \n\n66 O\n\n 66 O   \n\n65 C–66 O\n\n   \n\n67 N\n\n 67 N   \n\n65 C–67 N\n\n   \n\n68 H\n\n 68 H   \n\n67 N–68 H\n\n   \n\n69 CT\n\n 69 CT   \n\n67 N–69 CT\n\n   \n\n70 H1\n\n 70 H1   \n\n69 CT–70 H1\n\n   \n\n71 H1\n\n 71 H1   \n\n69 CT–71 H1\n\n   \n\n72 H1\n\n 72 H1   \n\n69 CT–72 H1\n\n  \n\n\nFigure 1: A diagram of the ala topology\n\n\n\n\n\n\n\n\n Back to top"
  }
]