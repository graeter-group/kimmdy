[
  {
    "objectID": "guide/explanation/index.html",
    "href": "guide/explanation/index.html",
    "title": "Explanations",
    "section": "",
    "text": "Pages that help you understand the inner workings of KIMMDY\n\n\n\n Back to top"
  },
  {
    "objectID": "guide/index.html",
    "href": "guide/index.html",
    "title": "Guide",
    "section": "",
    "text": "Welcome to the KIMMDY documentation. Here you will find all the information you need to get started with KIMMDY.\n\n\n\n Back to top"
  },
  {
    "objectID": "guide/tutorials/index.html",
    "href": "guide/tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "Tutorials to help you get familiar with KIMMDY.\n\n\n\n Back to top"
  },
  {
    "objectID": "guide/how_to/topology.html",
    "href": "guide/how_to/topology.html",
    "title": "Visualize Topologies",
    "section": "",
    "text": "Hexala\n\nfrom kimmdy.parsing import read_top\nfrom kimmdy.topology.topology import Topology\nfrom pathlib import Path\nfrom kimmdy.tools import top_to_graph\nfrom kimmdy.topology.utils import get_protein_section\n\n\nala_top = read_top(Path('../../tests/test_files/test_topology/urea.top'), use_gmx_dir=False)\ntop = Topology(ala_top)\n\nls = top_to_graph(top) \nwith open(\"ala-top.dot\", \"w\") as f:\n  f.writelines(ls)\n\n\n\n\n\n\n\n\n\nG\n\n  \n\n1 C\n\n 1 C   \n\n2 O\n\n 2 O   \n\n1 C–2 O\n\n   \n\n3 N\n\n 3 N   \n\n1 C–3 N\n\n   \n\n6 N\n\n 6 N   \n\n1 C–6 N\n\n   \n\n4 H\n\n 4 H   \n\n3 N–4 H\n\n   \n\n5 H\n\n 5 H   \n\n3 N–5 H\n\n   \n\n7 H\n\n 7 H   \n\n6 N–7 H\n\n   \n\n8 H\n\n 8 H   \n\n6 N–8 H\n\n  \n\n\nFigure 1: A diagram of the ala topology\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "guide/how_to/hcp.html",
    "href": "guide/how_to/hcp.html",
    "title": "High Performance Computing",
    "section": "",
    "text": "You need an installation of python (&gt;= 3.10) and (possibly PLUMED patched) GROMACS in your HPC environment.\nExample setup:\nsrun -t 1400:00 --mem=16000 -n20 --pty /bin/bash\nml EasyBuild\neb ./assets/Python-3.10.8.eb\nPrepare a bash script _modules.sh that loads the required modules and activates the python environment in which KIMMDY is installed.\nRun\nkimmdy --generate-jobscript\nto generate a file jobscript.sh that can be submitted to the HPC cluster.\nThis commands generates a kimmdy checkpoint and prepares the output folder. KIMMDY can then be started and re-started from the checkpoint via the jobscript, which uses\n# -c = continue, same  as --from-latest-checkpoint\nkimmdy -c"
  },
  {
    "objectID": "guide/how_to/hcp.html#setup",
    "href": "guide/how_to/hcp.html#setup",
    "title": "High Performance Computing",
    "section": "",
    "text": "You need an installation of python (&gt;= 3.10) and (possibly PLUMED patched) GROMACS in your HPC environment.\nExample setup:\nsrun -t 1400:00 --mem=16000 -n20 --pty /bin/bash\nml EasyBuild\neb ./assets/Python-3.10.8.eb\nPrepare a bash script _modules.sh that loads the required modules and activates the python environment in which KIMMDY is installed.\nRun\nkimmdy --generate-jobscript\nto generate a file jobscript.sh that can be submitted to the HPC cluster.\nThis commands generates a kimmdy checkpoint and prepares the output folder. KIMMDY can then be started and re-started from the checkpoint via the jobscript, which uses\n# -c = continue, same  as --from-latest-checkpoint\nkimmdy -c"
  },
  {
    "objectID": "guide/how_to/index.html",
    "href": "guide/how_to/index.html",
    "title": "How-To",
    "section": "",
    "text": "How-To Guides\n\n\n\n Back to top"
  },
  {
    "objectID": "_reference/cmd.html",
    "href": "_reference/cmd.html",
    "title": "cmd",
    "section": "",
    "text": "cmd\nFunctions for starting KIMMDY either from python or the command line. Other entry points such as kimmdy-analysis also live here.\n\n\n\n\n\nName\nDescription\n\n\n\n\nconfigure_logger\nConfigure logging.\n\n\nentry_point_kimmdy\nRun KIMMDY from the command line.\n\n\nget_cmdline_args\nParse command line arguments.\n\n\nkimmdy_run\nRun KIMMDY from python.\n\n\n\n\n\ncmd.configure_logger(config)\nConfigure logging.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconfig\nConfig\nconfiguration that contains log.level and log.file\nrequired\n\n\n\n\n\n\n\ncmd.entry_point_kimmdy()\nRun KIMMDY from the command line.\nThe configuration is gathered from the input file, which is kimmdy.yml by default. See get_cmdline_args or kimmdy --help for the descriptions of the arguments.\n\n\n\ncmd.get_cmdline_args()\nParse command line arguments.\n\n\n\n\n\nType\nDescription\n\n\n\n\nParsed command line arguments\n\n\n\n\n\n\n\n\ncmd.kimmdy_run(input=Path('kimmdy.yml'), loglevel=None, logfile=None, checkpoint='', show_plugins=False, show_schema_path=False, generate_jobscript=False, debug=False)\nRun KIMMDY from python.\nAlso see See get_cmdline_args or kimmdy --help for the descriptions of the arguments.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nPath\nkimmdy input yml file.\nPath('kimmdy.yml')\n\n\nloglevel\nOptional[str]\nLoglevel. One of [“INFO”, “WARNING”, “MESSAGE”, “DEBUG”]\nNone\n\n\nlogfile\nOptional[Path]\nFile path of the logfile.\nNone\n\n\ncheckpoint\nstr\nFile path of a kimmdy.cpt file to restart KIMMDY from a checkpoint. If a directory is given, the file kimmdy.cpt in that directory is used.\n''\n\n\nshow_plugins\nbool\nShow available plugins and exit.\nFalse\n\n\nshow_schema_path\nbool\nPrint path to yaml schema for use with yaml-language-server e.g. in VSCode and Neovim\nFalse\n\n\ngenerate_jobscript\nbool\nInstead of running KIMMDY directly, generate at jobscript.sh for slurm HPC clusters\nFalse"
  },
  {
    "objectID": "_reference/cmd.html#functions",
    "href": "_reference/cmd.html#functions",
    "title": "cmd",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconfigure_logger\nConfigure logging.\n\n\nentry_point_kimmdy\nRun KIMMDY from the command line.\n\n\nget_cmdline_args\nParse command line arguments.\n\n\nkimmdy_run\nRun KIMMDY from python.\n\n\n\n\n\ncmd.configure_logger(config)\nConfigure logging.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconfig\nConfig\nconfiguration that contains log.level and log.file\nrequired\n\n\n\n\n\n\n\ncmd.entry_point_kimmdy()\nRun KIMMDY from the command line.\nThe configuration is gathered from the input file, which is kimmdy.yml by default. See get_cmdline_args or kimmdy --help for the descriptions of the arguments.\n\n\n\ncmd.get_cmdline_args()\nParse command line arguments.\n\n\n\n\n\nType\nDescription\n\n\n\n\nParsed command line arguments\n\n\n\n\n\n\n\n\ncmd.kimmdy_run(input=Path('kimmdy.yml'), loglevel=None, logfile=None, checkpoint='', show_plugins=False, show_schema_path=False, generate_jobscript=False, debug=False)\nRun KIMMDY from python.\nAlso see See get_cmdline_args or kimmdy --help for the descriptions of the arguments.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nPath\nkimmdy input yml file.\nPath('kimmdy.yml')\n\n\nloglevel\nOptional[str]\nLoglevel. One of [“INFO”, “WARNING”, “MESSAGE”, “DEBUG”]\nNone\n\n\nlogfile\nOptional[Path]\nFile path of the logfile.\nNone\n\n\ncheckpoint\nstr\nFile path of a kimmdy.cpt file to restart KIMMDY from a checkpoint. If a directory is given, the file kimmdy.cpt in that directory is used.\n''\n\n\nshow_plugins\nbool\nShow available plugins and exit.\nFalse\n\n\nshow_schema_path\nbool\nPrint path to yaml schema for use with yaml-language-server e.g. in VSCode and Neovim\nFalse\n\n\ngenerate_jobscript\nbool\nInstead of running KIMMDY directly, generate at jobscript.sh for slurm HPC clusters\nFalse"
  },
  {
    "objectID": "_reference/constants.html",
    "href": "_reference/constants.html",
    "title": "constants",
    "section": "",
    "text": "constants\nComstants used throughout KIMMDY\n\n\n\n\n\nName\nDescription\n\n\n\n\nATOMTYPE_BONDORDER\nTo determin if an atom is a radical.\n\n\nATOMTYPE_BONDORDER_FLAT\nTo determin if an atom is a radical."
  },
  {
    "objectID": "_reference/constants.html#attributes",
    "href": "_reference/constants.html#attributes",
    "title": "constants",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nATOMTYPE_BONDORDER\nTo determin if an atom is a radical.\n\n\nATOMTYPE_BONDORDER_FLAT\nTo determin if an atom is a radical."
  },
  {
    "objectID": "_reference/runmanager.html",
    "href": "_reference/runmanager.html",
    "title": "runmanager",
    "section": "",
    "text": "runmanager\nThe Runmanager is the main entry point of the program.\nIt manages the queue of tasks, communicates with the rest of the program and keeps track of global state.\n\n\n\n\n\nName\nDescription\n\n\n\n\nRunManager\nThe Runmanager is the main entry point of the program.\n\n\nState\nState of the system.\n\n\n\n\n\nrunmanager.RunManager(self, config)\nThe Runmanager is the main entry point of the program.\nManages the queue of tasks, communicates with the rest of the program and keeps track of global state.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconfig\nConfig\nThe configuration object.\n\n\nfrom_checkpoint\nbool\nWhether the runmanager was initialized from a checkpoint.\n\n\ntasks\nqueue.Queue[Task]\nTasks from config.\n\n\ncrr_tasks\nqueue.Queue[Task]\nCurrent tasks.\n\n\niteration\nint\nCurrent iteration.\n\n\nstate\nState\nCurrent state of the system.\n\n\nrecipe_collection\nRecipeCollection\nCollection of recipes.\n\n\nlatest_files\ndict[str, Path]\nDictionary of latest files.\n\n\nhistfile\nPath\nPath to history file.\n\n\ncptfile\nPath\nPath to checkpoint file.\n\n\ntop\n\nTopology object.\n\n\nfilehist\nlist[dict[str, TaskFiles]]\nList of dictionaries of TaskFiles.\n\n\ntask_mapping\n\nMapping of task names to runmanager methods.\n\n\nreaction_plugins\nlist[ReactionPlugin]\nList of initialized reaction plugins used in the sequence.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_latest\nReturns path to latest file of given type.\n\n\nwrite_one_checkpoint\nJust write the first checkpoint and then exit\n\n\n\n\n\nrunmanager.RunManager.get_latest(suffix)\nReturns path to latest file of given type.\nFor .dat files (in general ambiguous extensions) use full file name. Errors if file is not found.\n\n\n\nrunmanager.RunManager.write_one_checkpoint()\nJust write the first checkpoint and then exit\nUsed to generate a starting point for jobscripts on hpc clusters that can easily self-submit after a timelimit was exceeded.\n\n\n\n\n\nrunmanager.State()\nState of the system. one of IDLE, MD, REACTION, DONE.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_existing_files\nInitialize latest_files with every existing file defined in config\n\n\n\n\n\nrunmanager.get_existing_files(config, section='root')\nInitialize latest_files with every existing file defined in config"
  },
  {
    "objectID": "_reference/runmanager.html#classes",
    "href": "_reference/runmanager.html#classes",
    "title": "runmanager",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nRunManager\nThe Runmanager is the main entry point of the program.\n\n\nState\nState of the system.\n\n\n\n\n\nrunmanager.RunManager(self, config)\nThe Runmanager is the main entry point of the program.\nManages the queue of tasks, communicates with the rest of the program and keeps track of global state.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconfig\nConfig\nThe configuration object.\n\n\nfrom_checkpoint\nbool\nWhether the runmanager was initialized from a checkpoint.\n\n\ntasks\nqueue.Queue[Task]\nTasks from config.\n\n\ncrr_tasks\nqueue.Queue[Task]\nCurrent tasks.\n\n\niteration\nint\nCurrent iteration.\n\n\nstate\nState\nCurrent state of the system.\n\n\nrecipe_collection\nRecipeCollection\nCollection of recipes.\n\n\nlatest_files\ndict[str, Path]\nDictionary of latest files.\n\n\nhistfile\nPath\nPath to history file.\n\n\ncptfile\nPath\nPath to checkpoint file.\n\n\ntop\n\nTopology object.\n\n\nfilehist\nlist[dict[str, TaskFiles]]\nList of dictionaries of TaskFiles.\n\n\ntask_mapping\n\nMapping of task names to runmanager methods.\n\n\nreaction_plugins\nlist[ReactionPlugin]\nList of initialized reaction plugins used in the sequence.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_latest\nReturns path to latest file of given type.\n\n\nwrite_one_checkpoint\nJust write the first checkpoint and then exit\n\n\n\n\n\nrunmanager.RunManager.get_latest(suffix)\nReturns path to latest file of given type.\nFor .dat files (in general ambiguous extensions) use full file name. Errors if file is not found.\n\n\n\nrunmanager.RunManager.write_one_checkpoint()\nJust write the first checkpoint and then exit\nUsed to generate a starting point for jobscripts on hpc clusters that can easily self-submit after a timelimit was exceeded.\n\n\n\n\n\nrunmanager.State()\nState of the system. one of IDLE, MD, REACTION, DONE."
  },
  {
    "objectID": "_reference/runmanager.html#functions",
    "href": "_reference/runmanager.html#functions",
    "title": "runmanager",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_existing_files\nInitialize latest_files with every existing file defined in config\n\n\n\n\n\nrunmanager.get_existing_files(config, section='root')\nInitialize latest_files with every existing file defined in config"
  },
  {
    "objectID": "_reference/tasks.html",
    "href": "_reference/tasks.html",
    "title": "tasks",
    "section": "",
    "text": "tasks\nThe tasks module holds the TaskFiles class which organizes input and output paths and the Task class for steps in the runmanager.\n\n\n\n\n\nName\nDescription\n\n\n\n\nAutoFillDict\nDictionary that gets populated by calling get_missing.\n\n\nTask\nA task to be performed as as a step in the RunManager.\n\n\nTaskFiles\nClass for Task input and output files and directories.\n\n\n\n\n\ntasks.AutoFillDict(self, get_missing)\nDictionary that gets populated by calling get_missing.\n\n\n\ntasks.Task(self, runmng, f, kwargs=None, out=None)\n\n\nrunmng Runmanager instance from which the task is called f Function that will be called when the task is called kwargs kwargs to be passed to f out If not None, an output dir will be created with this name\n\n\n\n\ntasks.TaskFiles(get_latest, input=field(default_factory=dict), output=field(default_factory=dict), outputdir=Path(), logger=logging.getLogger('kimmdy.basetask'))\n\n\nget_latest: Runmanager.get_latest function that returns paths to the latest file of given type. input: Input file paths for a Task. Is populated by get_latest or manually. output: Output file paths for a Task. Is populated by runmanager._discover_output_files or manually. outputdir: Output directory for a Task. Typically populated by create_task_directory called by Task. logger: Logger for a Task. Initialized in create_task_directory.\n\n\n\n&gt;&gt;&gt; class run():\n&gt;&gt;&gt;     def get_latest(self, s):\n&gt;&gt;&gt;         return f\"latest {s}\"\n&gt;&gt;&gt; runmng = run()\n&gt;&gt;&gt; files = TaskFiles(runmng)\n&gt;&gt;&gt; files.input\n&gt;&gt;&gt; files.input[\"top\"]\n{'top': 'latest top'}\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncreate_task_directory\nCreates TaskFiles object, output directory, logger and symlinks ff.\n\n\n\n\n\ntasks.create_task_directory(runmng, postfix)\nCreates TaskFiles object, output directory, logger and symlinks ff.\nGets called when a Task is called (from the runmanager.tasks queue)."
  },
  {
    "objectID": "_reference/tasks.html#classes",
    "href": "_reference/tasks.html#classes",
    "title": "tasks",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAutoFillDict\nDictionary that gets populated by calling get_missing.\n\n\nTask\nA task to be performed as as a step in the RunManager.\n\n\nTaskFiles\nClass for Task input and output files and directories.\n\n\n\n\n\ntasks.AutoFillDict(self, get_missing)\nDictionary that gets populated by calling get_missing.\n\n\n\ntasks.Task(self, runmng, f, kwargs=None, out=None)\n\n\nrunmng Runmanager instance from which the task is called f Function that will be called when the task is called kwargs kwargs to be passed to f out If not None, an output dir will be created with this name\n\n\n\n\ntasks.TaskFiles(get_latest, input=field(default_factory=dict), output=field(default_factory=dict), outputdir=Path(), logger=logging.getLogger('kimmdy.basetask'))\n\n\nget_latest: Runmanager.get_latest function that returns paths to the latest file of given type. input: Input file paths for a Task. Is populated by get_latest or manually. output: Output file paths for a Task. Is populated by runmanager._discover_output_files or manually. outputdir: Output directory for a Task. Typically populated by create_task_directory called by Task. logger: Logger for a Task. Initialized in create_task_directory.\n\n\n\n&gt;&gt;&gt; class run():\n&gt;&gt;&gt;     def get_latest(self, s):\n&gt;&gt;&gt;         return f\"latest {s}\"\n&gt;&gt;&gt; runmng = run()\n&gt;&gt;&gt; files = TaskFiles(runmng)\n&gt;&gt;&gt; files.input\n&gt;&gt;&gt; files.input[\"top\"]\n{'top': 'latest top'}"
  },
  {
    "objectID": "_reference/tasks.html#functions",
    "href": "_reference/tasks.html#functions",
    "title": "tasks",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncreate_task_directory\nCreates TaskFiles object, output directory, logger and symlinks ff.\n\n\n\n\n\ntasks.create_task_directory(runmng, postfix)\nCreates TaskFiles object, output directory, logger and symlinks ff.\nGets called when a Task is called (from the runmanager.tasks queue)."
  },
  {
    "objectID": "_reference/hat_naive.reaction.NaiveHAT.html",
    "href": "_reference/hat_naive.reaction.NaiveHAT.html",
    "title": "hat_naive.reaction.NaiveHAT",
    "section": "",
    "text": "hat_naive.reaction.NaiveHAT\nreaction.NaiveHAT()\nNaive HAT reaction, selects hydrogens at random\n\n\n\n\n Back to top"
  },
  {
    "objectID": "_reference/config.html",
    "href": "_reference/config.html",
    "title": "config",
    "section": "",
    "text": "config\nRead and validate kimmdy.yml configuration files and package into a parsed format for internal use.\n\n\n\n\n\nName\nDescription\n\n\n\n\nConfig\nInternal representation of the configuration generated\n\n\n\n\n\nconfig.Config(self, input_file=None, recursive_dict=None, scheme=None, section='config', logfile=None, loglevel=None)\nInternal representation of the configuration generated from the input file, which enables validation before running and computationally expensive operations.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_file\nPath | None\nPath to the config yaml file.\nNone\n\n\nrecursive_dict\ndict | None\nFor internal use only, used in reading settings in recursively.\nNone\n\n\nscheme\ndict | None\ndict containing types and defaults for casting and validating settings.\nNone\n\n\nsection\nstr\ncurrent section e.g. to determine the level of recursion in nested configs e.g. “config”, “config.mds” or “config.reactions.homolysis”\n'config'\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nattr\nGet the value of a specific attribute.\n\n\nget_attributes\nGet a list of all attributes without hidden ones (_&lt;…&gt;).\n\n\n\n\n\nconfig.Config.attr(attribute)\nGet the value of a specific attribute. Alias for self.__getattribute__\n\n\n\nconfig.Config.get_attributes()\nGet a list of all attributes without hidden ones (_&lt;…&gt;)."
  },
  {
    "objectID": "_reference/config.html#classes",
    "href": "_reference/config.html#classes",
    "title": "config",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nConfig\nInternal representation of the configuration generated\n\n\n\n\n\nconfig.Config(self, input_file=None, recursive_dict=None, scheme=None, section='config', logfile=None, loglevel=None)\nInternal representation of the configuration generated from the input file, which enables validation before running and computationally expensive operations.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_file\nPath | None\nPath to the config yaml file.\nNone\n\n\nrecursive_dict\ndict | None\nFor internal use only, used in reading settings in recursively.\nNone\n\n\nscheme\ndict | None\ndict containing types and defaults for casting and validating settings.\nNone\n\n\nsection\nstr\ncurrent section e.g. to determine the level of recursion in nested configs e.g. “config”, “config.mds” or “config.reactions.homolysis”\n'config'\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nattr\nGet the value of a specific attribute.\n\n\nget_attributes\nGet a list of all attributes without hidden ones (_&lt;…&gt;).\n\n\n\n\n\nconfig.Config.attr(attribute)\nGet the value of a specific attribute. Alias for self.__getattribute__\n\n\n\nconfig.Config.get_attributes()\nGet a list of all attributes without hidden ones (_&lt;…&gt;)."
  },
  {
    "objectID": "_reference/index.html",
    "href": "_reference/index.html",
    "title": "Reference",
    "section": "",
    "text": "Start KIMMDY from a python script or the command line\n\n\n\ncmd\nFunctions for starting KIMMDY either from python or the command line.\n\n\n\n\n\n\nTopology modules\n\n\n\ntopology.topology\n\n\n\ntopology.ff\n\n\n\ntopology.utils\n\n\n\ntopology.atomic\nAtomic datatypes for the topology such as Atom, Bond, Angle, Dihedral, etc.\n\n\nparsing.TopologyDict\nA raw representation of a topology file returned by read_top.\n\n\n\n\n\n\nModules\n\n\n\nanalysis\nAnalysis tools for KIMMDY runs.\n\n\ncmd\nFunctions for starting KIMMDY either from python or the command line.\n\n\nconfig\nRead and validate kimmdy.yml configuration files\n\n\nconstants\nComstants used throughout KIMMDY\n\n\ncoordinates\ncoordinate, topology and plumed modification functions\n\n\nkmc\nKinetic Monte Carlo (KMC) classes and functions.\n\n\nparsing\nAll read_&lt;…&gt; and write_&lt;…&gt; functions.\n\n\nplugins\nPlugin base classes and basic instances thereof.\n\n\nrecipe\nContains the Reaction Recipe, RecipeStep and RecipeCollection.\n\n\nrunmanager\nThe Runmanager is the main entry point of the program.\n\n\nschema\nHandle the schema for the config file.\n\n\ntasks\nThe tasks module holds the TaskFiles class which organizes input and\n\n\ntools\nStandalone tools that are complementary to KIMMDY.\n\n\nutils\nUtilities for building plugins, shell convenience functions and GROMACS related functions\n\n\n\n\n\n\nReaction plugins bundled with KIMMDY and the protocol to add a new reaction plugin to KIMMDY\n\n\n\nhomolysis.reaction.Homolysis\nHomolytic bond breaking leading to 2 radicals.\n\n\nhat_naive.reaction.NaiveHAT\nNaive HAT reaction, selects hydrogens at random\n\n\ndummyreaction.reaction.DummyReaction\nDummy reaction, returns empty RecipeCollection"
  },
  {
    "objectID": "_reference/index.html#api",
    "href": "_reference/index.html#api",
    "title": "Reference",
    "section": "",
    "text": "Start KIMMDY from a python script or the command line\n\n\n\ncmd\nFunctions for starting KIMMDY either from python or the command line."
  },
  {
    "objectID": "_reference/index.html#topology",
    "href": "_reference/index.html#topology",
    "title": "Reference",
    "section": "",
    "text": "Topology modules\n\n\n\ntopology.topology\n\n\n\ntopology.ff\n\n\n\ntopology.utils\n\n\n\ntopology.atomic\nAtomic datatypes for the topology such as Atom, Bond, Angle, Dihedral, etc.\n\n\nparsing.TopologyDict\nA raw representation of a topology file returned by read_top."
  },
  {
    "objectID": "_reference/index.html#modules",
    "href": "_reference/index.html#modules",
    "title": "Reference",
    "section": "",
    "text": "Modules\n\n\n\nanalysis\nAnalysis tools for KIMMDY runs.\n\n\ncmd\nFunctions for starting KIMMDY either from python or the command line.\n\n\nconfig\nRead and validate kimmdy.yml configuration files\n\n\nconstants\nComstants used throughout KIMMDY\n\n\ncoordinates\ncoordinate, topology and plumed modification functions\n\n\nkmc\nKinetic Monte Carlo (KMC) classes and functions.\n\n\nparsing\nAll read_&lt;…&gt; and write_&lt;…&gt; functions.\n\n\nplugins\nPlugin base classes and basic instances thereof.\n\n\nrecipe\nContains the Reaction Recipe, RecipeStep and RecipeCollection.\n\n\nrunmanager\nThe Runmanager is the main entry point of the program.\n\n\nschema\nHandle the schema for the config file.\n\n\ntasks\nThe tasks module holds the TaskFiles class which organizes input and\n\n\ntools\nStandalone tools that are complementary to KIMMDY.\n\n\nutils\nUtilities for building plugins, shell convenience functions and GROMACS related functions"
  },
  {
    "objectID": "_reference/index.html#reaction-plugins",
    "href": "_reference/index.html#reaction-plugins",
    "title": "Reference",
    "section": "",
    "text": "Reaction plugins bundled with KIMMDY and the protocol to add a new reaction plugin to KIMMDY\n\n\n\nhomolysis.reaction.Homolysis\nHomolytic bond breaking leading to 2 radicals.\n\n\nhat_naive.reaction.NaiveHAT\nNaive HAT reaction, selects hydrogens at random\n\n\ndummyreaction.reaction.DummyReaction\nDummy reaction, returns empty RecipeCollection"
  },
  {
    "objectID": "_reference/homolysis.reaction.Homolysis.html",
    "href": "_reference/homolysis.reaction.Homolysis.html",
    "title": "homolysis.reaction.Homolysis",
    "section": "",
    "text": "homolysis.reaction.Homolysis\nreaction.Homolysis()\nHomolytic bond breaking leading to 2 radicals. Implementation for time-varying rates\n\n\n\n\n Back to top"
  },
  {
    "objectID": "_reference/topology.topology.html",
    "href": "_reference/topology.topology.html",
    "title": "topology.topology",
    "section": "",
    "text": "topology.topology\n\n\n\n\n\nName\nDescription\n\n\n\n\nMoleculeType\nOne moleculetype in the topology\n\n\nTopology\nSmart container for parsed topology data.\n\n\n\n\n\ntopology.topology.MoleculeType(self, header, atomics)\nOne moleculetype in the topology\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\natoms\ndict[str, Atom]\n\n\n\nbonds\ndict[tuple[str, str], Bond]\n\n\n\npairs\ndict[tuple[str, str], Pair]\n\n\n\nangles\ndict[tuple[str, str, str], Angle]\n\n\n\nproper_dihedrals\ndict[tuple[str, str, str, str], MultipleDihedrals]\n\n\n\nimproper_dihedrals\ndict[tuple[str, str, str, str], Dihedral]\n\n\n\nposition_restraints\ndict[str, PositionRestraint]\n\n\n\ndihedral_restraints\ndict[tuple[str, str, str, str], DihedralRestraint]\n\n\n\nradicals\ndict[str, Atom]\ndict mapping atom indices to atom objects for storing all radical atoms\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nreindex_atomnrs\nReindex atom numbers in topology.\n\n\ntest_for_radicals\nUpdates radical status per atom and in topology.\n\n\n\n\n\ntopology.topology.MoleculeType.reindex_atomnrs()\nReindex atom numbers in topology.\nStarts at index 1. This also updates the numbers for bonds, angles, dihedrals and pairs. Returns a dict, mapping of old atom number strings to new ones\n\n\n\ntopology.topology.MoleculeType.test_for_radicals()\nUpdates radical status per atom and in topology.\nIterate over all atoms and designate them as radicals if they have fewer bounds than their natural bond order.\n\n\n\n\n\ntopology.topology.Topology(self, top, parametrizer=BasicParameterizer())\nSmart container for parsed topology data.\nA topology keeps track of connections when bonds are broken or formed. Reparametrization is triggerd automatically if to_dict is called after bonds have changed.\nAssumptions:\n\nthe topology of interest (the protein) is in section ‘moleculetype_0’.\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntop\nTopologyDict\nA dictionary containing the parsed topology data, produced by kimmdy.parsing.read_top\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbind_bond\nAdd a bond in topology.\n\n\nbreak_bond\nBreak bonds in topology homolytically.\n\n\ndel_atom\nDeletes atom\n\n\nreindex_atomnrs\nReindex atom numbers in topology.\n\n\nvalidate_bond\nValidates bond consistency between both atoms and top\n\n\n\n\n\ntopology.topology.Topology.bind_bond(atompair_addresses)\nAdd a bond in topology.\nModifies the topology dictionary in place. It keeps track of affected terms in the topology via a graph representation of the topology and applies the necessary changes to bonds, angles and dihedrals (proper and improper). Furthermore, it modifies to function types in the topology to account for radicals.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natompair_addresses\ntuple[TopologyAtomAddress, TopologyAtomAddress]\nAtoms to bind together.\nrequired\n\n\n\n\n\n\n\ntopology.topology.Topology.break_bond(atompair_addresses)\nBreak bonds in topology homolytically.\nRemoves bond, angles and dihedrals where atompair was involved. Modifies the topology dictionary in place. Atom pairs become radicals.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natompair_addresses\ntuple[TopologyAtomAddress, TopologyAtomAddress]\nBetween which atoms to break the bond.\nrequired\n\n\n\n\n\n\n\ntopology.topology.Topology.del_atom(atom_nr, parameterize=True)\nDeletes atom\nDeletes atom and all attached bonds. Reindexes the top and updates the parameters if requested.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_nr\nstr\n1-based atom number as string to delete\nrequired\n\n\nparameterize\nbool\nIf true and bonds are removed triggers reparameterization, by default True\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nupdate_map\nDict, mapping of old atom number strings to new ones.\n\n\n\n\n\n\n\ntopology.topology.Topology.reindex_atomnrs()\nReindex atom numbers in topology.\nStarts at index 1. This also updates the numbers for bonds, angles, dihedrals and pairs. Returns a dict of all moleculetypes to their update maps (old -&gt; new).\n\n\n\ntopology.topology.Topology.validate_bond(atm1, atm2)\nValidates bond consistency between both atoms and top Returns True if bond exists, False if not. Raises RuntimeError if bond is not consistent."
  },
  {
    "objectID": "_reference/topology.topology.html#classes",
    "href": "_reference/topology.topology.html#classes",
    "title": "topology.topology",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nMoleculeType\nOne moleculetype in the topology\n\n\nTopology\nSmart container for parsed topology data.\n\n\n\n\n\ntopology.topology.MoleculeType(self, header, atomics)\nOne moleculetype in the topology\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\natoms\ndict[str, Atom]\n\n\n\nbonds\ndict[tuple[str, str], Bond]\n\n\n\npairs\ndict[tuple[str, str], Pair]\n\n\n\nangles\ndict[tuple[str, str, str], Angle]\n\n\n\nproper_dihedrals\ndict[tuple[str, str, str, str], MultipleDihedrals]\n\n\n\nimproper_dihedrals\ndict[tuple[str, str, str, str], Dihedral]\n\n\n\nposition_restraints\ndict[str, PositionRestraint]\n\n\n\ndihedral_restraints\ndict[tuple[str, str, str, str], DihedralRestraint]\n\n\n\nradicals\ndict[str, Atom]\ndict mapping atom indices to atom objects for storing all radical atoms\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nreindex_atomnrs\nReindex atom numbers in topology.\n\n\ntest_for_radicals\nUpdates radical status per atom and in topology.\n\n\n\n\n\ntopology.topology.MoleculeType.reindex_atomnrs()\nReindex atom numbers in topology.\nStarts at index 1. This also updates the numbers for bonds, angles, dihedrals and pairs. Returns a dict, mapping of old atom number strings to new ones\n\n\n\ntopology.topology.MoleculeType.test_for_radicals()\nUpdates radical status per atom and in topology.\nIterate over all atoms and designate them as radicals if they have fewer bounds than their natural bond order.\n\n\n\n\n\ntopology.topology.Topology(self, top, parametrizer=BasicParameterizer())\nSmart container for parsed topology data.\nA topology keeps track of connections when bonds are broken or formed. Reparametrization is triggerd automatically if to_dict is called after bonds have changed.\nAssumptions:\n\nthe topology of interest (the protein) is in section ‘moleculetype_0’.\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntop\nTopologyDict\nA dictionary containing the parsed topology data, produced by kimmdy.parsing.read_top\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbind_bond\nAdd a bond in topology.\n\n\nbreak_bond\nBreak bonds in topology homolytically.\n\n\ndel_atom\nDeletes atom\n\n\nreindex_atomnrs\nReindex atom numbers in topology.\n\n\nvalidate_bond\nValidates bond consistency between both atoms and top\n\n\n\n\n\ntopology.topology.Topology.bind_bond(atompair_addresses)\nAdd a bond in topology.\nModifies the topology dictionary in place. It keeps track of affected terms in the topology via a graph representation of the topology and applies the necessary changes to bonds, angles and dihedrals (proper and improper). Furthermore, it modifies to function types in the topology to account for radicals.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natompair_addresses\ntuple[TopologyAtomAddress, TopologyAtomAddress]\nAtoms to bind together.\nrequired\n\n\n\n\n\n\n\ntopology.topology.Topology.break_bond(atompair_addresses)\nBreak bonds in topology homolytically.\nRemoves bond, angles and dihedrals where atompair was involved. Modifies the topology dictionary in place. Atom pairs become radicals.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natompair_addresses\ntuple[TopologyAtomAddress, TopologyAtomAddress]\nBetween which atoms to break the bond.\nrequired\n\n\n\n\n\n\n\ntopology.topology.Topology.del_atom(atom_nr, parameterize=True)\nDeletes atom\nDeletes atom and all attached bonds. Reindexes the top and updates the parameters if requested.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_nr\nstr\n1-based atom number as string to delete\nrequired\n\n\nparameterize\nbool\nIf true and bonds are removed triggers reparameterization, by default True\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nupdate_map\nDict, mapping of old atom number strings to new ones.\n\n\n\n\n\n\n\ntopology.topology.Topology.reindex_atomnrs()\nReindex atom numbers in topology.\nStarts at index 1. This also updates the numbers for bonds, angles, dihedrals and pairs. Returns a dict of all moleculetypes to their update maps (old -&gt; new).\n\n\n\ntopology.topology.Topology.validate_bond(atm1, atm2)\nValidates bond consistency between both atoms and top Returns True if bond exists, False if not. Raises RuntimeError if bond is not consistent."
  },
  {
    "objectID": "_reference/kmc.html",
    "href": "_reference/kmc.html",
    "title": "kmc",
    "section": "",
    "text": "kmc\nKinetic Monte Carlo (KMC) classes and functions.\nIn our system, the reaction rate r = (deterministic) reaction constant k = stochastic reaction constant c (from gillespie 1977) = propensity a (from Anderson 2007) because of the fundamental premise of chemical kinetics and because we have one reactant molecule\n\n\n\n\n\nName\nDescription\n\n\n\n\nKMCResult\nThe result of a KMC step. Similar to a Recipe but for the concrete realization of a reaction.\n\n\n\n\n\nkmc.KMCResult(recipe=field(default_factory=lambda : Recipe([], [], [])), reaction_probability=None, time_delta=None, time_start=None)\nThe result of a KMC step. Similar to a Recipe but for the concrete realization of a reaction.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nrecipe\nRecipe\nSingle sequence of RecipeSteps to build product\n\n\nreaction_probability\nUnion[list[float], None]\nIntegral of reaction propensity with respect to time\n\n\ntime_delta\nUnion[float, None]\nMC time jump during which the reaction occurs [ps]\n\n\ntime_start\nUnion[float, None]\nTime, from which the reaction starts. The reaction changes the geometry/topology of this timestep and continues from there.\n\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrm\nFirst Reaction Method variant of Kinetic Monte Carlo.\n\n\nrf_kmc\nRejection-Free Monte Carlo.\n\n\n\n\n\nkmc.frm(recipe_collection, rng=default_rng(), MD_time=None)\nFirst Reaction Method variant of Kinetic Monte Carlo. takes RecipeCollection and choses a recipe based on which reaction would occur.\nCompare e.g. Wikipedia KMC - time dependent\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnp.random.BitGenerator\nto generate random numbers in the KMC step\ndefault_rng()\n\n\nMD_time\nUnion[float, None]\ntime [ps] to compare conformational events with reaction events in the time domain\nNone\n\n\n\n\n\n\n\nkmc.rf_kmc(recipe_collection, rng=default_rng())\nRejection-Free Monte Carlo. takes RecipeCollection and choses a recipe based on the relative propensity of the events.\nCompare e.g. Wikipedia KMC - rejection free\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnp.random.BitGenerator\nfunction to generate random numbers in the KMC step\ndefault_rng()"
  },
  {
    "objectID": "_reference/kmc.html#classes",
    "href": "_reference/kmc.html#classes",
    "title": "kmc",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nKMCResult\nThe result of a KMC step. Similar to a Recipe but for the concrete realization of a reaction.\n\n\n\n\n\nkmc.KMCResult(recipe=field(default_factory=lambda : Recipe([], [], [])), reaction_probability=None, time_delta=None, time_start=None)\nThe result of a KMC step. Similar to a Recipe but for the concrete realization of a reaction.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nrecipe\nRecipe\nSingle sequence of RecipeSteps to build product\n\n\nreaction_probability\nUnion[list[float], None]\nIntegral of reaction propensity with respect to time\n\n\ntime_delta\nUnion[float, None]\nMC time jump during which the reaction occurs [ps]\n\n\ntime_start\nUnion[float, None]\nTime, from which the reaction starts. The reaction changes the geometry/topology of this timestep and continues from there."
  },
  {
    "objectID": "_reference/kmc.html#functions",
    "href": "_reference/kmc.html#functions",
    "title": "kmc",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfrm\nFirst Reaction Method variant of Kinetic Monte Carlo.\n\n\nrf_kmc\nRejection-Free Monte Carlo.\n\n\n\n\n\nkmc.frm(recipe_collection, rng=default_rng(), MD_time=None)\nFirst Reaction Method variant of Kinetic Monte Carlo. takes RecipeCollection and choses a recipe based on which reaction would occur.\nCompare e.g. Wikipedia KMC - time dependent\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnp.random.BitGenerator\nto generate random numbers in the KMC step\ndefault_rng()\n\n\nMD_time\nUnion[float, None]\ntime [ps] to compare conformational events with reaction events in the time domain\nNone\n\n\n\n\n\n\n\nkmc.rf_kmc(recipe_collection, rng=default_rng())\nRejection-Free Monte Carlo. takes RecipeCollection and choses a recipe based on the relative propensity of the events.\nCompare e.g. Wikipedia KMC - rejection free\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnp.random.BitGenerator\nfunction to generate random numbers in the KMC step\ndefault_rng()"
  },
  {
    "objectID": "_reference/plugins.html",
    "href": "_reference/plugins.html",
    "title": "plugins",
    "section": "",
    "text": "plugins\nPlugin base classes and basic instances thereof.\nAlso discovers and loads KIMMDY plugins.\n\n\n\n\n\nName\nDescription\n\n\n\n\nBasicParameterizer\nreconstruct base force field state\n\n\nReactionPlugin\nReaction base class\n\n\n\n\n\nplugins.BasicParameterizer()\nreconstruct base force field state\n\n\n\n\n\nName\nDescription\n\n\n\n\nparameterize_topology\nDo nothing,\n\n\n\n\n\nplugins.BasicParameterizer.parameterize_topology(current_topology)\nDo nothing, all necessary actions should already have happened in bind_bond and break_bond of Topology\n\n\n\n\n\nplugins.ReactionPlugin(self, name, runmng)\nReaction base class\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName of the reaction\nrequired\n\n\nrunmng\nRunmanager\nRunManager instance\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_recipe_collection\nGet a RecipeCollection as a result of the reaction.\n\n\n\n\n\nplugins.ReactionPlugin.get_recipe_collection(files)\nGet a RecipeCollection as a result of the reaction.\nThis is run as a Task in the RunManager. How the RecipeCollection is built is up to the reaction. It has access to the current state of the system via the runmanager self.runmng and the files.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfiles\nTaskFiles\nTaskFiles instance\nrequired"
  },
  {
    "objectID": "_reference/plugins.html#classes",
    "href": "_reference/plugins.html#classes",
    "title": "plugins",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBasicParameterizer\nreconstruct base force field state\n\n\nReactionPlugin\nReaction base class\n\n\n\n\n\nplugins.BasicParameterizer()\nreconstruct base force field state\n\n\n\n\n\nName\nDescription\n\n\n\n\nparameterize_topology\nDo nothing,\n\n\n\n\n\nplugins.BasicParameterizer.parameterize_topology(current_topology)\nDo nothing, all necessary actions should already have happened in bind_bond and break_bond of Topology\n\n\n\n\n\nplugins.ReactionPlugin(self, name, runmng)\nReaction base class\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName of the reaction\nrequired\n\n\nrunmng\nRunmanager\nRunManager instance\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_recipe_collection\nGet a RecipeCollection as a result of the reaction.\n\n\n\n\n\nplugins.ReactionPlugin.get_recipe_collection(files)\nGet a RecipeCollection as a result of the reaction.\nThis is run as a Task in the RunManager. How the RecipeCollection is built is up to the reaction. It has access to the current state of the system via the runmanager self.runmng and the files.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfiles\nTaskFiles\nTaskFiles instance\nrequired"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "KIMMDY",
    "section": "",
    "text": "KIMMDY\nWelcome to KIMMDY!\nHead over to the Getting Started section to jump right in.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "_reference/analysis.html",
    "href": "_reference/analysis.html",
    "title": "analysis",
    "section": "",
    "text": "analysis\nAnalysis tools for KIMMDY runs. For command line usage, run kimmdy-analysis -h.\n\n\n\n\n\nName\nDescription\n\n\n\n\nconcat_traj\nFind and concatenate trajectories (.xtc files) from a KIMMDY run into one trajectory.\n\n\nentry_point_analysis\nAnalyse existing KIMMDY runs.\n\n\nget_analysis_cmdline_args\nParse command line arguments.\n\n\nget_analysis_dir\nGet analysis directory for a KIMMDY run.\n\n\nget_step_directories\ncreate list of subdirectories that match the steps.\n\n\nplot_energy\nPlot GROMACS energy for a KIMMDY run.\n\n\nplot_rates\nPlot rates of all possible reactions for each ‘decide_recipe’ step.\n\n\nradical_population\nPlot population of radicals for a KIMMDY run.\n\n\n\n\n\nanalysis.concat_traj(dir, steps, open_vmd=False)\nFind and concatenate trajectories (.xtc files) from a KIMMDY run into one trajectory. The concatenated trajectory is centered and pbc corrected.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory to search for subdirectories\nrequired\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories\nrequired\n\n\nopen_vmd\nbool\nOpen concatenated trajectory in VMD\nFalse\n\n\n\n\n\n\n\nanalysis.entry_point_analysis()\nAnalyse existing KIMMDY runs.\n\n\n\nanalysis.get_analysis_cmdline_args()\nParse command line arguments.\n\n\n\n\n\nType\nDescription\n\n\n\n\nParsed command line arguments\n\n\n\n\n\n\n\n\nanalysis.get_analysis_dir(dir)\nGet analysis directory for a KIMMDY run.\nCreates the directory if it does not exist.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nPath\nDirectory of KIMMDY run\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nPath to analysis directory\n\n\n\n\n\n\n\n\nanalysis.get_step_directories(dir, steps='all')\ncreate list of subdirectories that match the steps. If steps is “all”, all subdirectories are returned.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nPath\nDirectory to search for subdirectories\nrequired\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories\n'all'\n\n\n\n\n\n\n\nanalysis.plot_energy(dir, steps, terms, open_plot=False)\nPlot GROMACS energy for a KIMMDY run.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory to search for subdirectories\nrequired\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories. Default is “all”.\nrequired\n\n\nterms\nlist[str]\nTerms from gmx energy that will be plotted. Uses ‘Potential’ by default.\nrequired\n\n\nopen_plot\nbool\nOpen plot in default system viewer.\nFalse\n\n\n\n\n\n\n\nanalysis.plot_rates(dir)\nPlot rates of all possible reactions for each ‘decide_recipe’ step.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory of KIMMDY run\nrequired\n\n\n\n\n\n\n\nanalysis.radical_population(dir, steps='all', select_atoms='protein', open_plot=False, open_vmd=False)\nPlot population of radicals for a KIMMDY run.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nKIMMDY run directory to be analysed.\nrequired\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories. Default is “all”.\n'all'\n\n\nselect_atoms\nstr\nAtoms chosen for radical population analysis, default is protein (uses MDAnalysis selection syntax)\n'protein'\n\n\nopen_plot\nbool\nOpen plot in default system viewer.\nFalse\n\n\nopen_vmd\nbool\nOpen a pdb in VMD with the radical occupation as B-factors.\nFalse"
  },
  {
    "objectID": "_reference/analysis.html#functions",
    "href": "_reference/analysis.html#functions",
    "title": "analysis",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconcat_traj\nFind and concatenate trajectories (.xtc files) from a KIMMDY run into one trajectory.\n\n\nentry_point_analysis\nAnalyse existing KIMMDY runs.\n\n\nget_analysis_cmdline_args\nParse command line arguments.\n\n\nget_analysis_dir\nGet analysis directory for a KIMMDY run.\n\n\nget_step_directories\ncreate list of subdirectories that match the steps.\n\n\nplot_energy\nPlot GROMACS energy for a KIMMDY run.\n\n\nplot_rates\nPlot rates of all possible reactions for each ‘decide_recipe’ step.\n\n\nradical_population\nPlot population of radicals for a KIMMDY run.\n\n\n\n\n\nanalysis.concat_traj(dir, steps, open_vmd=False)\nFind and concatenate trajectories (.xtc files) from a KIMMDY run into one trajectory. The concatenated trajectory is centered and pbc corrected.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory to search for subdirectories\nrequired\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories\nrequired\n\n\nopen_vmd\nbool\nOpen concatenated trajectory in VMD\nFalse\n\n\n\n\n\n\n\nanalysis.entry_point_analysis()\nAnalyse existing KIMMDY runs.\n\n\n\nanalysis.get_analysis_cmdline_args()\nParse command line arguments.\n\n\n\n\n\nType\nDescription\n\n\n\n\nParsed command line arguments\n\n\n\n\n\n\n\n\nanalysis.get_analysis_dir(dir)\nGet analysis directory for a KIMMDY run.\nCreates the directory if it does not exist.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nPath\nDirectory of KIMMDY run\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nPath to analysis directory\n\n\n\n\n\n\n\n\nanalysis.get_step_directories(dir, steps='all')\ncreate list of subdirectories that match the steps. If steps is “all”, all subdirectories are returned.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nPath\nDirectory to search for subdirectories\nrequired\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories\n'all'\n\n\n\n\n\n\n\nanalysis.plot_energy(dir, steps, terms, open_plot=False)\nPlot GROMACS energy for a KIMMDY run.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory to search for subdirectories\nrequired\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories. Default is “all”.\nrequired\n\n\nterms\nlist[str]\nTerms from gmx energy that will be plotted. Uses ‘Potential’ by default.\nrequired\n\n\nopen_plot\nbool\nOpen plot in default system viewer.\nFalse\n\n\n\n\n\n\n\nanalysis.plot_rates(dir)\nPlot rates of all possible reactions for each ‘decide_recipe’ step.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory of KIMMDY run\nrequired\n\n\n\n\n\n\n\nanalysis.radical_population(dir, steps='all', select_atoms='protein', open_plot=False, open_vmd=False)\nPlot population of radicals for a KIMMDY run.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nKIMMDY run directory to be analysed.\nrequired\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories. Default is “all”.\n'all'\n\n\nselect_atoms\nstr\nAtoms chosen for radical population analysis, default is protein (uses MDAnalysis selection syntax)\n'protein'\n\n\nopen_plot\nbool\nOpen plot in default system viewer.\nFalse\n\n\nopen_vmd\nbool\nOpen a pdb in VMD with the radical occupation as B-factors.\nFalse"
  },
  {
    "objectID": "_reference/coordinates.html",
    "href": "_reference/coordinates.html",
    "title": "coordinates",
    "section": "",
    "text": "coordinates\ncoordinate, topology and plumed modification functions\n\n\n\n\n\nName\nDescription\n\n\n\n\nbreak_bond_plumed\nBreak bond in plumed configuration file.\n\n\nget_explicit_MultipleDihedrals\nTakes a valid dihedral key and returns explicit\n\n\nget_explicit_or_type\nTakes an Interaction and associated key, InteractionTypes, Topology\n\n\nis_parameterized\nParameterized topology entries have c0 and c1 attributes != None\n\n\nmerge_dihedrals\nMerge one to two Dihedrals or -Types into a Dihedral in free-energy syntax\n\n\nmerge_top_moleculetypes_slow_growth\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation\n\n\nmerge_top_slow_growth\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation.\n\n\nplace_atom\nPlace an atom to new coords at the last time point of the recipe timespans\n\n\n\n\n\ncoordinates.break_bond_plumed(files, breakpair, newplumed)\nBreak bond in plumed configuration file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfiles\nTaskFiles\n\nrequired\n\n\nbreakpair\ntuple[str, str]\n\nrequired\n\n\n\n\n\n\n\ncoordinates.get_explicit_MultipleDihedrals(dihedral_key, mol, dihedrals_in, ff, periodicity_max=6)\nTakes a valid dihedral key and returns explicit dihedral parameters for a given topology\n\n\n\ncoordinates.get_explicit_or_type(key, interaction, interaction_types, mol, periodicity='')\nTakes an Interaction and associated key, InteractionTypes, Topology and Periodicity (for dihedrals) and returns an object with the parameters of this Interaction\n\n\n\ncoordinates.is_parameterized(entry)\nParameterized topology entries have c0 and c1 attributes != None\n\n\n\ncoordinates.merge_dihedrals(dihedral_key, interactionA, interactionB, interaction_typesA, interaction_typesB, molA, molB, funct, periodicity)\nMerge one to two Dihedrals or -Types into a Dihedral in free-energy syntax\n\n\n\ncoordinates.merge_top_moleculetypes_slow_growth(molA, molB, ff, focus_nr=None)\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation\n\n\n\ncoordinates.merge_top_slow_growth(topA, topB, focus_nr=None)\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation.\nTODO: for now this assumes that only one moleculeype (the first, index 0) is of interest.\n\n\n\ncoordinates.place_atom(files, step, timespan)\nPlace an atom to new coords at the last time point of the recipe timespans"
  },
  {
    "objectID": "_reference/coordinates.html#functions",
    "href": "_reference/coordinates.html#functions",
    "title": "coordinates",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbreak_bond_plumed\nBreak bond in plumed configuration file.\n\n\nget_explicit_MultipleDihedrals\nTakes a valid dihedral key and returns explicit\n\n\nget_explicit_or_type\nTakes an Interaction and associated key, InteractionTypes, Topology\n\n\nis_parameterized\nParameterized topology entries have c0 and c1 attributes != None\n\n\nmerge_dihedrals\nMerge one to two Dihedrals or -Types into a Dihedral in free-energy syntax\n\n\nmerge_top_moleculetypes_slow_growth\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation\n\n\nmerge_top_slow_growth\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation.\n\n\nplace_atom\nPlace an atom to new coords at the last time point of the recipe timespans\n\n\n\n\n\ncoordinates.break_bond_plumed(files, breakpair, newplumed)\nBreak bond in plumed configuration file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfiles\nTaskFiles\n\nrequired\n\n\nbreakpair\ntuple[str, str]\n\nrequired\n\n\n\n\n\n\n\ncoordinates.get_explicit_MultipleDihedrals(dihedral_key, mol, dihedrals_in, ff, periodicity_max=6)\nTakes a valid dihedral key and returns explicit dihedral parameters for a given topology\n\n\n\ncoordinates.get_explicit_or_type(key, interaction, interaction_types, mol, periodicity='')\nTakes an Interaction and associated key, InteractionTypes, Topology and Periodicity (for dihedrals) and returns an object with the parameters of this Interaction\n\n\n\ncoordinates.is_parameterized(entry)\nParameterized topology entries have c0 and c1 attributes != None\n\n\n\ncoordinates.merge_dihedrals(dihedral_key, interactionA, interactionB, interaction_typesA, interaction_typesB, molA, molB, funct, periodicity)\nMerge one to two Dihedrals or -Types into a Dihedral in free-energy syntax\n\n\n\ncoordinates.merge_top_moleculetypes_slow_growth(molA, molB, ff, focus_nr=None)\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation\n\n\n\ncoordinates.merge_top_slow_growth(topA, topB, focus_nr=None)\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation.\nTODO: for now this assumes that only one moleculeype (the first, index 0) is of interest.\n\n\n\ncoordinates.place_atom(files, step, timespan)\nPlace an atom to new coords at the last time point of the recipe timespans"
  },
  {
    "objectID": "_reference/tools.html",
    "href": "_reference/tools.html",
    "title": "tools",
    "section": "",
    "text": "tools\nStandalone tools that are complementary to KIMMDY.\n\n\n\n\n\nName\nDescription\n\n\n\n\nentry_point_build_examples\nBuild examples from the command line.\n\n\nentry_point_remove_hydrogen\nRemove hydrogen by atom nr in a gro and topology file\n\n\nget_build_example_cmdline_args\nParse command line arguments.\n\n\nget_remove_hydrogen_cmdline_args\nparse cmdline args for remove_hydrogen\n\n\nremove_hydrogen\nremove hydrogen from a gro and top file\n\n\n\n\n\ntools.entry_point_build_examples()\nBuild examples from the command line.\n\n\n\ntools.entry_point_remove_hydrogen()\nRemove hydrogen by atom nr in a gro and topology file\n\n\n\ntools.get_build_example_cmdline_args()\nParse command line arguments.\n\n\n\n\n\nType\nDescription\n\n\n\n\nNamespace\nparsed command line arguments\n\n\n\n\n\n\n\ntools.get_remove_hydrogen_cmdline_args()\nparse cmdline args for remove_hydrogen\n\n\n\ntools.remove_hydrogen(gro, top, nr, parameterize, equilibrate, gmx_mdrun_flags='')\nremove hydrogen from a gro and top file"
  },
  {
    "objectID": "_reference/tools.html#functions",
    "href": "_reference/tools.html#functions",
    "title": "tools",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nentry_point_build_examples\nBuild examples from the command line.\n\n\nentry_point_remove_hydrogen\nRemove hydrogen by atom nr in a gro and topology file\n\n\nget_build_example_cmdline_args\nParse command line arguments.\n\n\nget_remove_hydrogen_cmdline_args\nparse cmdline args for remove_hydrogen\n\n\nremove_hydrogen\nremove hydrogen from a gro and top file\n\n\n\n\n\ntools.entry_point_build_examples()\nBuild examples from the command line.\n\n\n\ntools.entry_point_remove_hydrogen()\nRemove hydrogen by atom nr in a gro and topology file\n\n\n\ntools.get_build_example_cmdline_args()\nParse command line arguments.\n\n\n\n\n\nType\nDescription\n\n\n\n\nNamespace\nparsed command line arguments\n\n\n\n\n\n\n\ntools.get_remove_hydrogen_cmdline_args()\nparse cmdline args for remove_hydrogen\n\n\n\ntools.remove_hydrogen(gro, top, nr, parameterize, equilibrate, gmx_mdrun_flags='')\nremove hydrogen from a gro and top file"
  },
  {
    "objectID": "_reference/topology.atomic.html",
    "href": "_reference/topology.atomic.html",
    "title": "topology.atomic",
    "section": "",
    "text": "topology.atomic\nAtomic datatypes for the topology such as Atom, Bond, Angle, Dihedral, etc. The order of the fields comes from the gromacs topology file format. See gromacs manual\n\n\n\n\n\nName\nDescription\n\n\n\n\nAngle\nInformation about one angle\n\n\nAngleType\nInformation about one angletype\n\n\nAtom\nInformation about one atom\n\n\nAtomType\nInformation about one atom type\n\n\nBond\nInformation about one bond\n\n\nBondType\nInformation about one bondtype\n\n\nDihedral\nInformation about one proper or improper dihedral\n\n\nDihedralRestraint\nInformation about one dihedral restraint.\n\n\nDihedralType\nInformation about one dihedraltype\n\n\nMultipleDihedralTypes\nMultiple DihedralTypess with the same ai, aj, ak, al\n\n\nMultipleDihedrals\nMultiple Dihedrals with the same ai, aj, ak, al\n\n\nPair\nInformation about one pair\n\n\nPositionRestraint\nInformation about one position restraint.\n\n\nResidueAtomSpec\nInformation about one atom in a residue\n\n\nResidueBondSpec\nInformation about one bond in a residue\n\n\nResidueImproperSpec\nInformation about one imroper dihedral in a residue\n\n\nResidueProperSpec\nInformation about one imroper dihedral in a residue\n\n\nResidueType\nInformation about one residuetype from aminoacids.rtp\n\n\n\n\n\ntopology.atomic.Angle(ai, aj, ak, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one angle\nA class containing angle information as in the angles section of the topology.\nFrom gromacs topology: ; ai aj ak funct c0 c1 c2 c3 With aj &lt; ai &lt; ak\n\n\n\ntopology.atomic.AngleType(i, j, k, id, id_sym, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one angletype\nA class containing angle type information as in the angletypes section of the forcefield.\nFrom gromacs version of the amber* ff: ; i j k func th0 cth\n\n\n\ntopology.atomic.Atom(nr, type, resnr, residue, atom, cgnr, charge, mass=None, typeB=None, chargeB=None, massB=None, bound_to_nrs=field(default_factory=list), is_radical=False)\nInformation about one atom\nA class containing atom information as in the atoms section of the topology. An atom keeps a list of which atoms it is bound to and its radical state.\nFrom gromacs topology: ; nr type resnr residue atom cgnr charge mass typeB chargeB massB\n\n\n\ntopology.atomic.AtomType(type, id_sym, at_num, mass, charge, ptype, sigma, epsilon, id)\nInformation about one atom type\nA class containing atom type information as in the atomtypes section of the forcefield.\nFrom gromacs version of the amber* ff: ; name at.num mass charge ptype sigma epsilon\n\n\n\ntopology.atomic.Bond(ai, aj, funct, c0=None, c1=None, c2=None, c3=None, c4=None, c5=None)\nInformation about one bond\nA class containing bond information as in the bonds section of the topology.\nFrom gromacs topology: ; ai aj funct c0 c1 c2 c3 c4 c5 With ai &lt; aj\n\n\n\ntopology.atomic.BondType(i, j, id, id_sym, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one bondtype\nA class containing bond information as in the bondtype section of the forcefield.\nFrom gromacs version of the amber* ff: ; i j func b0 kb Where i and j are atomtypes\n\n\n\ntopology.atomic.Dihedral(ai, aj, ak, al, funct, c0=None, c1=None, periodicity='', c3=None, c4=None, c5=None)\nInformation about one proper or improper dihedral\nA class containing dihedral information as in the dihedrals section of the topology. Improper dihedrals have funct 4. Proper dihedrals have funct != 4, mostly funct 9.\nNote that proper dihedrals of type 9 can be defined multiple times, for different periodicities. This is why would-be parameter c2 is called periodicity.\nFrom gromacs topology: ; ai aj ak al funct c0 c1 c2 c3 c4 c5 For proper dihedrals (funct 9): aj &lt; ak\n\n\n\ntopology.atomic.DihedralRestraint(ai, aj, ak, al, type, phi, dphi, fc)\nInformation about one dihedral restraint.\nA class containing information as in the dihedral_restraints section of the topology.\nFrom gromacs topology: ; ai aj ak al type phi dphi fc\n\n\n\ntopology.atomic.DihedralType(i, j, k, l, id, id_sym, funct, c0, c1, periodicity, c3=None, c4=None, c5=None)\nInformation about one dihedraltype\nA class containing dihedral type information as in the dihedraltypes section of the forcefield. Improper dihedrals have funct 4. Proper dihedrals have funct 9.\nNote that proper dihedrals of type 9 can be defined multiple times, for different periodicities. This is why would-be parameter c2 is called periodicity and part of the id.\nFrom gromacs version of the amber* ff: ; i j k l func phase kd pn\n\n\n\ntopology.atomic.MultipleDihedralTypes(ai, aj, ak, al, funct, dihedral_types)\nMultiple DihedralTypess with the same ai, aj, ak, al but different periodicities. funct should always be “9” when the length of dihedrals is &gt; 1. The key of the dihedral_types dict is the periodicity (c2).\n\n\n\ntopology.atomic.MultipleDihedrals(ai, aj, ak, al, funct, dihedrals)\nMultiple Dihedrals with the same ai, aj, ak, al but different periodicities. funct should always be “9” when the length of dihedrals is &gt; 1. The key of the dihedrals dict is the periodicity (c2).\n\n\n\ntopology.atomic.Pair(ai, aj, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one pair\nA class containing pair information as in the pair section of the topology.\nFrom gromacs topology: ; ai aj funct c0 c1 c2 c3\n\n\n\ntopology.atomic.PositionRestraint(ai, funct, fc, condition=None)\nInformation about one position restraint.\nA class containing information as in the position_restraints section of the topology.\nFrom gromacs topology: ; ai funct fc(x,y,z)\n\n\n\ntopology.atomic.ResidueAtomSpec(name, type, charge, cgrp)\nInformation about one atom in a residue\n; name type charge chargegroup\n\n\n\ntopology.atomic.ResidueBondSpec(atom1, atom2, b0=None, kb=None)\nInformation about one bond in a residue\n; atom1 atom2 b0 kb\n\n\n\ntopology.atomic.ResidueImproperSpec(atom1, atom2, atom3, atom4, q0, cq)\nInformation about one imroper dihedral in a residue\n; atom1 atom2 atom3 atom4 q0 cq\n\n\n\ntopology.atomic.ResidueProperSpec(atom1, atom2, atom3, atom4, q0)\nInformation about one imroper dihedral in a residue\n; atom1 atom2 atom3 atom4 q0 cq\n\n\n\ntopology.atomic.ResidueType(residue, atoms, bonds, proper_dihedrals, improper_dihedrals)\nInformation about one residuetype from aminoacids.rtp"
  },
  {
    "objectID": "_reference/topology.atomic.html#classes",
    "href": "_reference/topology.atomic.html#classes",
    "title": "topology.atomic",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAngle\nInformation about one angle\n\n\nAngleType\nInformation about one angletype\n\n\nAtom\nInformation about one atom\n\n\nAtomType\nInformation about one atom type\n\n\nBond\nInformation about one bond\n\n\nBondType\nInformation about one bondtype\n\n\nDihedral\nInformation about one proper or improper dihedral\n\n\nDihedralRestraint\nInformation about one dihedral restraint.\n\n\nDihedralType\nInformation about one dihedraltype\n\n\nMultipleDihedralTypes\nMultiple DihedralTypess with the same ai, aj, ak, al\n\n\nMultipleDihedrals\nMultiple Dihedrals with the same ai, aj, ak, al\n\n\nPair\nInformation about one pair\n\n\nPositionRestraint\nInformation about one position restraint.\n\n\nResidueAtomSpec\nInformation about one atom in a residue\n\n\nResidueBondSpec\nInformation about one bond in a residue\n\n\nResidueImproperSpec\nInformation about one imroper dihedral in a residue\n\n\nResidueProperSpec\nInformation about one imroper dihedral in a residue\n\n\nResidueType\nInformation about one residuetype from aminoacids.rtp\n\n\n\n\n\ntopology.atomic.Angle(ai, aj, ak, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one angle\nA class containing angle information as in the angles section of the topology.\nFrom gromacs topology: ; ai aj ak funct c0 c1 c2 c3 With aj &lt; ai &lt; ak\n\n\n\ntopology.atomic.AngleType(i, j, k, id, id_sym, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one angletype\nA class containing angle type information as in the angletypes section of the forcefield.\nFrom gromacs version of the amber* ff: ; i j k func th0 cth\n\n\n\ntopology.atomic.Atom(nr, type, resnr, residue, atom, cgnr, charge, mass=None, typeB=None, chargeB=None, massB=None, bound_to_nrs=field(default_factory=list), is_radical=False)\nInformation about one atom\nA class containing atom information as in the atoms section of the topology. An atom keeps a list of which atoms it is bound to and its radical state.\nFrom gromacs topology: ; nr type resnr residue atom cgnr charge mass typeB chargeB massB\n\n\n\ntopology.atomic.AtomType(type, id_sym, at_num, mass, charge, ptype, sigma, epsilon, id)\nInformation about one atom type\nA class containing atom type information as in the atomtypes section of the forcefield.\nFrom gromacs version of the amber* ff: ; name at.num mass charge ptype sigma epsilon\n\n\n\ntopology.atomic.Bond(ai, aj, funct, c0=None, c1=None, c2=None, c3=None, c4=None, c5=None)\nInformation about one bond\nA class containing bond information as in the bonds section of the topology.\nFrom gromacs topology: ; ai aj funct c0 c1 c2 c3 c4 c5 With ai &lt; aj\n\n\n\ntopology.atomic.BondType(i, j, id, id_sym, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one bondtype\nA class containing bond information as in the bondtype section of the forcefield.\nFrom gromacs version of the amber* ff: ; i j func b0 kb Where i and j are atomtypes\n\n\n\ntopology.atomic.Dihedral(ai, aj, ak, al, funct, c0=None, c1=None, periodicity='', c3=None, c4=None, c5=None)\nInformation about one proper or improper dihedral\nA class containing dihedral information as in the dihedrals section of the topology. Improper dihedrals have funct 4. Proper dihedrals have funct != 4, mostly funct 9.\nNote that proper dihedrals of type 9 can be defined multiple times, for different periodicities. This is why would-be parameter c2 is called periodicity.\nFrom gromacs topology: ; ai aj ak al funct c0 c1 c2 c3 c4 c5 For proper dihedrals (funct 9): aj &lt; ak\n\n\n\ntopology.atomic.DihedralRestraint(ai, aj, ak, al, type, phi, dphi, fc)\nInformation about one dihedral restraint.\nA class containing information as in the dihedral_restraints section of the topology.\nFrom gromacs topology: ; ai aj ak al type phi dphi fc\n\n\n\ntopology.atomic.DihedralType(i, j, k, l, id, id_sym, funct, c0, c1, periodicity, c3=None, c4=None, c5=None)\nInformation about one dihedraltype\nA class containing dihedral type information as in the dihedraltypes section of the forcefield. Improper dihedrals have funct 4. Proper dihedrals have funct 9.\nNote that proper dihedrals of type 9 can be defined multiple times, for different periodicities. This is why would-be parameter c2 is called periodicity and part of the id.\nFrom gromacs version of the amber* ff: ; i j k l func phase kd pn\n\n\n\ntopology.atomic.MultipleDihedralTypes(ai, aj, ak, al, funct, dihedral_types)\nMultiple DihedralTypess with the same ai, aj, ak, al but different periodicities. funct should always be “9” when the length of dihedrals is &gt; 1. The key of the dihedral_types dict is the periodicity (c2).\n\n\n\ntopology.atomic.MultipleDihedrals(ai, aj, ak, al, funct, dihedrals)\nMultiple Dihedrals with the same ai, aj, ak, al but different periodicities. funct should always be “9” when the length of dihedrals is &gt; 1. The key of the dihedrals dict is the periodicity (c2).\n\n\n\ntopology.atomic.Pair(ai, aj, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one pair\nA class containing pair information as in the pair section of the topology.\nFrom gromacs topology: ; ai aj funct c0 c1 c2 c3\n\n\n\ntopology.atomic.PositionRestraint(ai, funct, fc, condition=None)\nInformation about one position restraint.\nA class containing information as in the position_restraints section of the topology.\nFrom gromacs topology: ; ai funct fc(x,y,z)\n\n\n\ntopology.atomic.ResidueAtomSpec(name, type, charge, cgrp)\nInformation about one atom in a residue\n; name type charge chargegroup\n\n\n\ntopology.atomic.ResidueBondSpec(atom1, atom2, b0=None, kb=None)\nInformation about one bond in a residue\n; atom1 atom2 b0 kb\n\n\n\ntopology.atomic.ResidueImproperSpec(atom1, atom2, atom3, atom4, q0, cq)\nInformation about one imroper dihedral in a residue\n; atom1 atom2 atom3 atom4 q0 cq\n\n\n\ntopology.atomic.ResidueProperSpec(atom1, atom2, atom3, atom4, q0)\nInformation about one imroper dihedral in a residue\n; atom1 atom2 atom3 atom4 q0 cq\n\n\n\ntopology.atomic.ResidueType(residue, atoms, bonds, proper_dihedrals, improper_dihedrals)\nInformation about one residuetype from aminoacids.rtp"
  },
  {
    "objectID": "_reference/schema.html",
    "href": "_reference/schema.html",
    "title": "schema",
    "section": "",
    "text": "schema\nHandle the schema for the config file. To be used by the config module to validate the config file and set defaults for the Config object.\nReserved keywords: - pytype - default - description - type - required\n\n\n\n\n\nName\nDescription\n\n\n\n\nSequence\nA sequence of tasks.\n\n\n\n\n\nschema.Sequence(self, tasks)\nA sequence of tasks.\nTasks can be grouped together by using a dictionary with the following keys: - mult: number of times to repeat the tasks - tasks: list of tasks to repeat\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntasks\n\nlist of tasks\n\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconvert_schema_to_dict\nConvert a dictionary from a raw json schema to a nested dictionary\n\n\nflatten_scheme\nRecursively get properties and their desicripions from the scheme\n\n\ngenerate_markdown_table\nGenerate markdown table from scheme\n\n\nget_combined_scheme\nReturn the schema for the config file.\n\n\nload_kimmdy_schema\nReturn the schema for the config file\n\n\nload_plugin_schemas\nReturn the schemas for the reaction plugins known to kimmdy\n\n\nprune\nRemove empty dicts from a nested dict\n\n\n\n\n\nschema.convert_schema_to_dict(dictionary)\nConvert a dictionary from a raw json schema to a nested dictionary\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndictionary\ndict\ndictionary from a raw json schema\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nnested dictionary where each leaf entry is a dictionary with the\n“pytype”, “default” and “description” keys.\n\n\n\n\n\n\n\nschema.flatten_scheme(scheme, section='')\nRecursively get properties and their desicripions from the scheme\n\n\n\nschema.generate_markdown_table(scheme, append=False)\nGenerate markdown table from scheme\nUsed in documentation generation.\n\n\n\nschema.get_combined_scheme()\nReturn the schema for the config file.\nNested scheme where each leaf entry is a dictionary with the “pytype”, “default” and “description”. Contains the schema for the main kimmdy config file and all the plugins known at runtime.\n\n\n\nschema.load_kimmdy_schema()\nReturn the schema for the config file\n\n\n\nschema.load_plugin_schemas()\nReturn the schemas for the reaction plugins known to kimmdy\n\n\n\nschema.prune(d)\nRemove empty dicts from a nested dict"
  },
  {
    "objectID": "_reference/schema.html#classes",
    "href": "_reference/schema.html#classes",
    "title": "schema",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nSequence\nA sequence of tasks.\n\n\n\n\n\nschema.Sequence(self, tasks)\nA sequence of tasks.\nTasks can be grouped together by using a dictionary with the following keys: - mult: number of times to repeat the tasks - tasks: list of tasks to repeat\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntasks\n\nlist of tasks"
  },
  {
    "objectID": "_reference/schema.html#functions",
    "href": "_reference/schema.html#functions",
    "title": "schema",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconvert_schema_to_dict\nConvert a dictionary from a raw json schema to a nested dictionary\n\n\nflatten_scheme\nRecursively get properties and their desicripions from the scheme\n\n\ngenerate_markdown_table\nGenerate markdown table from scheme\n\n\nget_combined_scheme\nReturn the schema for the config file.\n\n\nload_kimmdy_schema\nReturn the schema for the config file\n\n\nload_plugin_schemas\nReturn the schemas for the reaction plugins known to kimmdy\n\n\nprune\nRemove empty dicts from a nested dict\n\n\n\n\n\nschema.convert_schema_to_dict(dictionary)\nConvert a dictionary from a raw json schema to a nested dictionary\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndictionary\ndict\ndictionary from a raw json schema\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nnested dictionary where each leaf entry is a dictionary with the\n“pytype”, “default” and “description” keys.\n\n\n\n\n\n\n\nschema.flatten_scheme(scheme, section='')\nRecursively get properties and their desicripions from the scheme\n\n\n\nschema.generate_markdown_table(scheme, append=False)\nGenerate markdown table from scheme\nUsed in documentation generation.\n\n\n\nschema.get_combined_scheme()\nReturn the schema for the config file.\nNested scheme where each leaf entry is a dictionary with the “pytype”, “default” and “description”. Contains the schema for the main kimmdy config file and all the plugins known at runtime.\n\n\n\nschema.load_kimmdy_schema()\nReturn the schema for the config file\n\n\n\nschema.load_plugin_schemas()\nReturn the schemas for the reaction plugins known to kimmdy\n\n\n\nschema.prune(d)\nRemove empty dicts from a nested dict"
  },
  {
    "objectID": "_reference/parsing.TopologyDict.html",
    "href": "_reference/parsing.TopologyDict.html",
    "title": "parsing.TopologyDict",
    "section": "",
    "text": "parsing.TopologyDict\nparsing.TopologyDict\nA raw representation of a topology file returned by read_top.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "_reference/topology.utils.html",
    "href": "_reference/topology.utils.html",
    "title": "topology.utils",
    "section": "",
    "text": "topology.utils\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_moleculetype_atomics\nGet content of subsections (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\n\n\nget_moleculetype_header\nGet content of the header of a moleculetype from a topology dict.\n\n\nget_protein_section\nGet content of a section in the first moleculetype (protein) from a topology dict.\n\n\nget_top_section\nGet content of a section from a topology dict.\n\n\nset_moleculetype_atomics\nSet content of the atomics (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\n\n\nset_protein_section\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\nset_top_section\nSet content of a section from a topology dict.\n\n\n\n\n\ntopology.utils.get_moleculetype_atomics(top, moleculetype)\nGet content of subsections (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.get_moleculetype_header(top, moleculetype)\nGet content of the header of a moleculetype from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.get_protein_section(top, name)\nGet content of a section in the first moleculetype (protein) from a topology dict.\n\n\n\ntopology.utils.get_top_section(top, name, moleculetype=None)\nGet content of a section from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.set_moleculetype_atomics(top, moleculetype, atomics)\nSet content of the atomics (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.set_protein_section(top, name, value)\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\n\ntopology.utils.set_top_section(top, name, value, moleculetype=None)\nSet content of a section from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result."
  },
  {
    "objectID": "_reference/topology.utils.html#functions",
    "href": "_reference/topology.utils.html#functions",
    "title": "topology.utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_moleculetype_atomics\nGet content of subsections (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\n\n\nget_moleculetype_header\nGet content of the header of a moleculetype from a topology dict.\n\n\nget_protein_section\nGet content of a section in the first moleculetype (protein) from a topology dict.\n\n\nget_top_section\nGet content of a section from a topology dict.\n\n\nset_moleculetype_atomics\nSet content of the atomics (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\n\n\nset_protein_section\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\nset_top_section\nSet content of a section from a topology dict.\n\n\n\n\n\ntopology.utils.get_moleculetype_atomics(top, moleculetype)\nGet content of subsections (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.get_moleculetype_header(top, moleculetype)\nGet content of the header of a moleculetype from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.get_protein_section(top, name)\nGet content of a section in the first moleculetype (protein) from a topology dict.\n\n\n\ntopology.utils.get_top_section(top, name, moleculetype=None)\nGet content of a section from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.set_moleculetype_atomics(top, moleculetype, atomics)\nSet content of the atomics (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.set_protein_section(top, name, value)\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\n\ntopology.utils.set_top_section(top, name, value, moleculetype=None)\nSet content of a section from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result."
  },
  {
    "objectID": "_reference/dummyreaction.reaction.DummyReaction.html",
    "href": "_reference/dummyreaction.reaction.DummyReaction.html",
    "title": "dummyreaction.reaction.DummyReaction",
    "section": "",
    "text": "dummyreaction.reaction.DummyReaction\nreaction.DummyReaction()\nDummy reaction, returns empty RecipeCollection\n\n\n\n\n Back to top"
  },
  {
    "objectID": "_reference/utils.html",
    "href": "_reference/utils.html",
    "title": "utils",
    "section": "",
    "text": "utils\nUtilities for building plugins, shell convenience functions and GROMACS related functions\n\n\n\n\n\nName\nDescription\n\n\n\n\nTopologyAtomAddress\nAddress to an atom in the topology.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_gmx_version\nCheck for an existing gromacs installation.\n\n\nget_atominfo_from_atomnrs\nUse topology atoms section to convert from atomnr to atomtype\n\n\nget_atomnrs_from_plumedid\nConvert from plumedid to atomnr, information from the plumed file is used.\n\n\nget_bondprm_from_atomtypes\nReturns bond parameters (b0, kb) for a set of two atomtypes.\n\n\nget_edissoc_from_atomnames\nReturns dissociation energy E_dissoc for a set of two atomnames.\n\n\nget_gmx_dir\nReturns the path to the gromacs installation\n\n\nget_shell_stdout\nRun command in shell and capture stdout.\n\n\nmorse_transition_rate\nCalculates reaction rate constant for a bond breaking event.\n\n\nrun_gmx\nRun GROMACS command in shell.\n\n\nrun_shell_cmd\nRun command in shell.\n\n\n\n\n\nutils.check_gmx_version(config)\nCheck for an existing gromacs installation.\nIf PLUMED is meant to be used it additionally checks for the keyword ‘MODIFIED’ or ‘plumed’ in the version name.\n\n\n\nutils.get_atominfo_from_atomnrs(atomnrs, top)\nUse topology atoms section to convert from atomnr to atomtype\n\n\n\nutils.get_atomnrs_from_plumedid(plumedid, plumed)\nConvert from plumedid to atomnr, information from the plumed file is used.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nplumedid\nstr\nIdentifier from a plumed input file (e.g d0).\nrequired\n\n\nplumed\nPlumed_dict\nParsed plumed input file\nrequired\n\n\n\n\n\n\n\nutils.get_bondprm_from_atomtypes(atomtypes, ffbonded)\nReturns bond parameters (b0, kb) for a set of two atomtypes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomtypes\nlist[str]\nTwo atomtypes as defined in the respective force field\nrequired\n\n\nffbonded\ndict\nForce field ffbonded.itp file parsed through the rtp parser\nrequired\n\n\n\n\n\n\n\nutils.get_edissoc_from_atomnames(atomnames, edissoc)\nReturns dissociation energy E_dissoc for a set of two atomnames.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomnames\nlist[str]\nTwo atomnames as defined in the respective force field\nrequired\n\n\nedissoc\ndict\nParsed file with dissociation energies per bond between two atomtypes or elements\nrequired\n\n\n\n\n\n\n\nutils.get_gmx_dir(gromacs_alias='gmx')\nReturns the path to the gromacs installation\nThis does not check if the installation is valid. It just returns the path to the gromacs data directory. If gmx is not executable it still returns the default gromacs data directory in /usr/share/gromacs.\n\n\n\nutils.get_shell_stdout(s)\nRun command in shell and capture stdout.\n\n\n\nutils.morse_transition_rate(r_curr, r_0, dissociation_energy, k_f, k_0=0.288, kT=2.479)\nCalculates reaction rate constant for a bond breaking event.\nUses the Morse potential model for this calculation. For an array of bond distances of the same bond, first calculates the forces on the bond, then the minima and maxima of the shifted Morse potential to get an energy barrier and finally a reaction rate constant using the Arrhenius equation. For intramolecular reactions, the reaction rate constant is equal to the reaction rate.\nThe calculation should be according to the derivation in the original KIMMDY paper: DOI: 10.1021/acs.jctc.9b00786\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nr_curr\nlist[float]\nBond distances for a single bond, typically from a time series.\nrequired\n\n\nr_0\nfloat\nEquilibrium bond length of the bond.\nrequired\n\n\ndissociation\n\nDissociation energy of the bond.\nrequired\n\n\nk_f\nfloat\nSpring constant of the bond.\nrequired\n\n\nk_0\nfloat\nPrefactor of the Arrhenius equation in [1/ps]. Default value from fitting averaged C_a - N data to gromacs data, see original KIMMDY paper Alternatively 1/2pi sqrt(k/m).\n0.288\n\n\nkT\nfloat\nConstant in the Arrhenius equation in GROMACS units [kJ mol-1], default for 310K.\n2.479\n\n\n\n\n\n\n\nutils.run_gmx(s, cwd=None)\nRun GROMACS command in shell.\nAdds a ‘-quiet’ flag to the command and checks the return code.\n\n\n\nutils.run_shell_cmd(s, cwd=None)\nRun command in shell."
  },
  {
    "objectID": "_reference/utils.html#attributes",
    "href": "_reference/utils.html#attributes",
    "title": "utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nTopologyAtomAddress\nAddress to an atom in the topology."
  },
  {
    "objectID": "_reference/utils.html#functions",
    "href": "_reference/utils.html#functions",
    "title": "utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_gmx_version\nCheck for an existing gromacs installation.\n\n\nget_atominfo_from_atomnrs\nUse topology atoms section to convert from atomnr to atomtype\n\n\nget_atomnrs_from_plumedid\nConvert from plumedid to atomnr, information from the plumed file is used.\n\n\nget_bondprm_from_atomtypes\nReturns bond parameters (b0, kb) for a set of two atomtypes.\n\n\nget_edissoc_from_atomnames\nReturns dissociation energy E_dissoc for a set of two atomnames.\n\n\nget_gmx_dir\nReturns the path to the gromacs installation\n\n\nget_shell_stdout\nRun command in shell and capture stdout.\n\n\nmorse_transition_rate\nCalculates reaction rate constant for a bond breaking event.\n\n\nrun_gmx\nRun GROMACS command in shell.\n\n\nrun_shell_cmd\nRun command in shell.\n\n\n\n\n\nutils.check_gmx_version(config)\nCheck for an existing gromacs installation.\nIf PLUMED is meant to be used it additionally checks for the keyword ‘MODIFIED’ or ‘plumed’ in the version name.\n\n\n\nutils.get_atominfo_from_atomnrs(atomnrs, top)\nUse topology atoms section to convert from atomnr to atomtype\n\n\n\nutils.get_atomnrs_from_plumedid(plumedid, plumed)\nConvert from plumedid to atomnr, information from the plumed file is used.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nplumedid\nstr\nIdentifier from a plumed input file (e.g d0).\nrequired\n\n\nplumed\nPlumed_dict\nParsed plumed input file\nrequired\n\n\n\n\n\n\n\nutils.get_bondprm_from_atomtypes(atomtypes, ffbonded)\nReturns bond parameters (b0, kb) for a set of two atomtypes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomtypes\nlist[str]\nTwo atomtypes as defined in the respective force field\nrequired\n\n\nffbonded\ndict\nForce field ffbonded.itp file parsed through the rtp parser\nrequired\n\n\n\n\n\n\n\nutils.get_edissoc_from_atomnames(atomnames, edissoc)\nReturns dissociation energy E_dissoc for a set of two atomnames.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomnames\nlist[str]\nTwo atomnames as defined in the respective force field\nrequired\n\n\nedissoc\ndict\nParsed file with dissociation energies per bond between two atomtypes or elements\nrequired\n\n\n\n\n\n\n\nutils.get_gmx_dir(gromacs_alias='gmx')\nReturns the path to the gromacs installation\nThis does not check if the installation is valid. It just returns the path to the gromacs data directory. If gmx is not executable it still returns the default gromacs data directory in /usr/share/gromacs.\n\n\n\nutils.get_shell_stdout(s)\nRun command in shell and capture stdout.\n\n\n\nutils.morse_transition_rate(r_curr, r_0, dissociation_energy, k_f, k_0=0.288, kT=2.479)\nCalculates reaction rate constant for a bond breaking event.\nUses the Morse potential model for this calculation. For an array of bond distances of the same bond, first calculates the forces on the bond, then the minima and maxima of the shifted Morse potential to get an energy barrier and finally a reaction rate constant using the Arrhenius equation. For intramolecular reactions, the reaction rate constant is equal to the reaction rate.\nThe calculation should be according to the derivation in the original KIMMDY paper: DOI: 10.1021/acs.jctc.9b00786\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nr_curr\nlist[float]\nBond distances for a single bond, typically from a time series.\nrequired\n\n\nr_0\nfloat\nEquilibrium bond length of the bond.\nrequired\n\n\ndissociation\n\nDissociation energy of the bond.\nrequired\n\n\nk_f\nfloat\nSpring constant of the bond.\nrequired\n\n\nk_0\nfloat\nPrefactor of the Arrhenius equation in [1/ps]. Default value from fitting averaged C_a - N data to gromacs data, see original KIMMDY paper Alternatively 1/2pi sqrt(k/m).\n0.288\n\n\nkT\nfloat\nConstant in the Arrhenius equation in GROMACS units [kJ mol-1], default for 310K.\n2.479\n\n\n\n\n\n\n\nutils.run_gmx(s, cwd=None)\nRun GROMACS command in shell.\nAdds a ‘-quiet’ flag to the command and checks the return code.\n\n\n\nutils.run_shell_cmd(s, cwd=None)\nRun command in shell."
  },
  {
    "objectID": "_reference/topology.ff.html",
    "href": "_reference/topology.ff.html",
    "title": "topology.ff",
    "section": "",
    "text": "topology.ff\n\n\n\n\n\nName\nDescription\n\n\n\n\nFF\nContainer for parsed forcefield data.\n\n\n\n\n\ntopology.ff.FF(self, top)\nContainer for parsed forcefield data."
  },
  {
    "objectID": "_reference/topology.ff.html#classes",
    "href": "_reference/topology.ff.html#classes",
    "title": "topology.ff",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nFF\nContainer for parsed forcefield data.\n\n\n\n\n\ntopology.ff.FF(self, top)\nContainer for parsed forcefield data."
  },
  {
    "objectID": "_reference/parsing.html",
    "href": "_reference/parsing.html",
    "title": "parsing",
    "section": "",
    "text": "parsing\nAll read_&lt;…&gt; and write_&lt;…&gt; functions.\n\n\n\n\n\nName\nDescription\n\n\n\n\nTopologyDict\nA raw representation of a topology file returned by read_top.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nJSONEncoder\nEncoder that enables writing JSONs with numpy types.\n\n\nPlumed_dict\nDict representation of a plumed.dat file.\n\n\n\n\n\nparsing.JSONEncoder()\nEncoder that enables writing JSONs with numpy types.\n\n\n\nparsing.Plumed_dict()\nDict representation of a plumed.dat file.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nis_not_comment\nReturns whether a string is not a comment.\n\n\nread_distances_dat\nRead a distances.dat plumed output file.\n\n\nread_edissoc\nReads a edissoc file and turns it into a dict.\n\n\nread_json\nReturn JSON file content as dict.\n\n\nread_plumed\nRead a plumed.dat configuration file.\n\n\nread_top\nRead a topology file (.top,.itp,*.rtp) into a raw TopologyDict represenation.\n\n\nresolve_includes\nResolve #include statements in a (top/itp) file.\n\n\nwrite_json\nWrite dict to file according to JSON format.\n\n\nwrite_plumed\nWrite a plumed.dat configuration file.\n\n\nwrite_top\nWrite a TopologyDict to a topology file.\n\n\n\n\n\nparsing.is_not_comment(c)\nReturns whether a string is not a comment.\nUsed for topology like files that use ‘;’ for comments.\n\n\n\nparsing.read_distances_dat(distances_dat)\nRead a distances.dat plumed output file.\n\n\n\nparsing.read_edissoc(path)\nReads a edissoc file and turns it into a dict.\nThe tuple of bond atoms make up the key, the dissociation energy E_dissoc [kJ mol-1] is the value.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the file. E.g. Path(“edissoc.dat”)\nrequired\n\n\n\n\n\n\n\nparsing.read_json(path)\nReturn JSON file content as dict.\n\n\n\nparsing.read_plumed(path)\nRead a plumed.dat configuration file.\nFollows the plumed naming scheme of label, keyword, action.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the file. E.g. “plumed.dat”\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nPlumed_dict\ndict with keys: ‘distances’ and ‘prints’ Each is a dict/list of dicts containing plumed keywords\n\n\n\n\n\n\n\nparsing.read_top(path, ffdir=None, use_gmx_dir=True)\nRead a topology file (.top,.itp,*.rtp) into a raw TopologyDict represenation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the topology file.\nrequired\n\n\n\n\n\n\n\n#include statements will be resolved\ncomments will be removed\nall lines are stripped of leading and trailing whitespace\n#undef is not supported\na section within ifdef may be a subsection of a section that was started outside of the ifdef\n#if..#endif statements only surround a full section or subsection, not individual lines within a section and a section may either be contained within if … else or it may not be, but it can not be duplicated with one part inside and one outside.\nif .. else can’t be nested\n#include s that don’t resolve to a valid file path are silently dropped\nsections that can have subsections can also exist multiple, separate times e.g. moleculetype will appear multiple times and they should not be merged\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nEvery section, apart from ffdir and define,\n\n\n\ncomes with a condition that can be checked against the\n\n\n\ndefines by the helper functions to determine if the content\n\n\n\n(a list of lists) should come from content or else_content.\n\n\n\nSome sections such as moleculetype also come with subsections.\n\n\n\n\n\n\n\nraw_top =\n{'ffdir': PosixPath('/usr/share/gromacs/top/amber99.ff'),\n'define': {'_FF_AMBER': [], '_FF_AMBER99': []},\n'defaults': {'content': [['1', '2', 'yes', '0.5', '0.8333']],\n'else_content': [],\n'extra': [],\n'condition': None},\n'atomtypes': {'content': [\n['C', '6', '12.01', '0.0000', 'A', '3.39967e-01', '3.59824e-01'],\n['MNH3', '0', '0.0000', '0.0000', 'A', '0.00000e+00', '0.00000e+00']],\n'else_content': [],\n'extra': [],\n'condition': None},\n'moleculetype_0': {'content': [['Urea', '3']],\n'else_content': [],\n'extra': [],\n'condition': None,\n'subsections': {'atoms': {'content': [['1',\n    'C',\n    '1',\n    'URE',\n    'C',\n    '1',\n    '0.880229',\n    '12.01000'],\n    ['2', 'O', '1', 'URE', 'O', '2', '-0.613359', '16.00000'],\n    ['3', 'N', '1', 'URE', 'N1', '3', '-0.923545', '14.01000'],\n    ['4', 'H', '1', 'URE', 'H11', '4', '0.395055', '1.00800'],\n    ['5', 'H', '1', 'URE', 'H12', '5', '0.395055', '1.00800'],\n    ['6', 'N', '1', 'URE', 'N2', '6', '-0.923545', '14.01000'],\n    ['7', 'H', '1', 'URE', 'H21', '7', '0.395055', '1.00800'],\n    ['8', 'H', '1', 'URE', 'H22', '8', '0.395055', '1.00800']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'bonds': {'content': [['1', '2'],\n    ['1', '3'],\n    ['1', '6'],\n    ['3', '4'],\n    ['3', '5'],\n    ['6', '7'],\n    ['6', '8']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'dihedrals': {'content': [['2', '1', '3', '4', '9'],\n    ['2', '1', '3', '5', '9'],\n    ['2', '1', '6', '7', '9'],\n    ['2', '1', '6', '8', '9'],\n    ['3', '1', '6', '7', '9'],\n    ['3', '1', '6', '8', '9'],\n    ['6', '1', '3', '4', '9'],\n    ['6', '1', '3', '5', '9'],\n    ['3', '6', '1', '2', '4'],\n    ['1', '4', '3', '5', '4'],\n    ['1', '7', '6', '8', '4']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'position_restraints': {'content': [['1', '1', '1000', '1000', '1000'],\n    ['2', '1', '1000', '0', '1000'],\n    ['3', '1', '1000', '0', '0']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'dihedral_restraints': {'content': [['3',\n    '6',\n    '1',\n    '2',\n    '1',\n    '180',\n    '0',\n    '10'],\n    ['1', '4', '3', '5', '1', '180', '0', '10']],\n    'else_content': [],\n    'extra': [],\n    'condition': None}}},\n}\n\n\n\n\nparsing.resolve_includes(path, gmx_builtin_ffs=None)\n\n\npath : Filepath to read.\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[str]\nList of lines.\n\n\nOptional[Path]\nPath to the ff directory if one of the includes used a file from it.\n\n\n\n\n\n\n\nparsing.write_json(d, path)\nWrite dict to file according to JSON format.\n\n\n\nparsing.write_plumed(d, path)\nWrite a plumed.dat configuration file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nd\nPlumed_dict\nDictionary containing ‘labeled_action’, ‘other’ and ‘prints’\nrequired\n\n\npath\nPath\nPath to the file. E.g. “plumed.dat”\nrequired\n\n\n\n\n\n\n\nparsing.write_top(top, outfile)\nWrite a TopologyDict to a topology file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntop\nTopologyDict\nRaw dictionary represenation of the topology.\nrequired\n\n\noutfile\nPath\nPath to the topology file to write to.\nrequired"
  },
  {
    "objectID": "_reference/parsing.html#attributes",
    "href": "_reference/parsing.html#attributes",
    "title": "parsing",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nTopologyDict\nA raw representation of a topology file returned by read_top."
  },
  {
    "objectID": "_reference/parsing.html#classes",
    "href": "_reference/parsing.html#classes",
    "title": "parsing",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nJSONEncoder\nEncoder that enables writing JSONs with numpy types.\n\n\nPlumed_dict\nDict representation of a plumed.dat file.\n\n\n\n\n\nparsing.JSONEncoder()\nEncoder that enables writing JSONs with numpy types.\n\n\n\nparsing.Plumed_dict()\nDict representation of a plumed.dat file."
  },
  {
    "objectID": "_reference/parsing.html#functions",
    "href": "_reference/parsing.html#functions",
    "title": "parsing",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nis_not_comment\nReturns whether a string is not a comment.\n\n\nread_distances_dat\nRead a distances.dat plumed output file.\n\n\nread_edissoc\nReads a edissoc file and turns it into a dict.\n\n\nread_json\nReturn JSON file content as dict.\n\n\nread_plumed\nRead a plumed.dat configuration file.\n\n\nread_top\nRead a topology file (.top,.itp,*.rtp) into a raw TopologyDict represenation.\n\n\nresolve_includes\nResolve #include statements in a (top/itp) file.\n\n\nwrite_json\nWrite dict to file according to JSON format.\n\n\nwrite_plumed\nWrite a plumed.dat configuration file.\n\n\nwrite_top\nWrite a TopologyDict to a topology file.\n\n\n\n\n\nparsing.is_not_comment(c)\nReturns whether a string is not a comment.\nUsed for topology like files that use ‘;’ for comments.\n\n\n\nparsing.read_distances_dat(distances_dat)\nRead a distances.dat plumed output file.\n\n\n\nparsing.read_edissoc(path)\nReads a edissoc file and turns it into a dict.\nThe tuple of bond atoms make up the key, the dissociation energy E_dissoc [kJ mol-1] is the value.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the file. E.g. Path(“edissoc.dat”)\nrequired\n\n\n\n\n\n\n\nparsing.read_json(path)\nReturn JSON file content as dict.\n\n\n\nparsing.read_plumed(path)\nRead a plumed.dat configuration file.\nFollows the plumed naming scheme of label, keyword, action.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the file. E.g. “plumed.dat”\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nPlumed_dict\ndict with keys: ‘distances’ and ‘prints’ Each is a dict/list of dicts containing plumed keywords\n\n\n\n\n\n\n\nparsing.read_top(path, ffdir=None, use_gmx_dir=True)\nRead a topology file (.top,.itp,*.rtp) into a raw TopologyDict represenation.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the topology file.\nrequired\n\n\n\n\n\n\n\n#include statements will be resolved\ncomments will be removed\nall lines are stripped of leading and trailing whitespace\n#undef is not supported\na section within ifdef may be a subsection of a section that was started outside of the ifdef\n#if..#endif statements only surround a full section or subsection, not individual lines within a section and a section may either be contained within if … else or it may not be, but it can not be duplicated with one part inside and one outside.\nif .. else can’t be nested\n#include s that don’t resolve to a valid file path are silently dropped\nsections that can have subsections can also exist multiple, separate times e.g. moleculetype will appear multiple times and they should not be merged\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nEvery section, apart from ffdir and define,\n\n\n\ncomes with a condition that can be checked against the\n\n\n\ndefines by the helper functions to determine if the content\n\n\n\n(a list of lists) should come from content or else_content.\n\n\n\nSome sections such as moleculetype also come with subsections.\n\n\n\n\n\n\n\nraw_top =\n{'ffdir': PosixPath('/usr/share/gromacs/top/amber99.ff'),\n'define': {'_FF_AMBER': [], '_FF_AMBER99': []},\n'defaults': {'content': [['1', '2', 'yes', '0.5', '0.8333']],\n'else_content': [],\n'extra': [],\n'condition': None},\n'atomtypes': {'content': [\n['C', '6', '12.01', '0.0000', 'A', '3.39967e-01', '3.59824e-01'],\n['MNH3', '0', '0.0000', '0.0000', 'A', '0.00000e+00', '0.00000e+00']],\n'else_content': [],\n'extra': [],\n'condition': None},\n'moleculetype_0': {'content': [['Urea', '3']],\n'else_content': [],\n'extra': [],\n'condition': None,\n'subsections': {'atoms': {'content': [['1',\n    'C',\n    '1',\n    'URE',\n    'C',\n    '1',\n    '0.880229',\n    '12.01000'],\n    ['2', 'O', '1', 'URE', 'O', '2', '-0.613359', '16.00000'],\n    ['3', 'N', '1', 'URE', 'N1', '3', '-0.923545', '14.01000'],\n    ['4', 'H', '1', 'URE', 'H11', '4', '0.395055', '1.00800'],\n    ['5', 'H', '1', 'URE', 'H12', '5', '0.395055', '1.00800'],\n    ['6', 'N', '1', 'URE', 'N2', '6', '-0.923545', '14.01000'],\n    ['7', 'H', '1', 'URE', 'H21', '7', '0.395055', '1.00800'],\n    ['8', 'H', '1', 'URE', 'H22', '8', '0.395055', '1.00800']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'bonds': {'content': [['1', '2'],\n    ['1', '3'],\n    ['1', '6'],\n    ['3', '4'],\n    ['3', '5'],\n    ['6', '7'],\n    ['6', '8']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'dihedrals': {'content': [['2', '1', '3', '4', '9'],\n    ['2', '1', '3', '5', '9'],\n    ['2', '1', '6', '7', '9'],\n    ['2', '1', '6', '8', '9'],\n    ['3', '1', '6', '7', '9'],\n    ['3', '1', '6', '8', '9'],\n    ['6', '1', '3', '4', '9'],\n    ['6', '1', '3', '5', '9'],\n    ['3', '6', '1', '2', '4'],\n    ['1', '4', '3', '5', '4'],\n    ['1', '7', '6', '8', '4']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'position_restraints': {'content': [['1', '1', '1000', '1000', '1000'],\n    ['2', '1', '1000', '0', '1000'],\n    ['3', '1', '1000', '0', '0']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'dihedral_restraints': {'content': [['3',\n    '6',\n    '1',\n    '2',\n    '1',\n    '180',\n    '0',\n    '10'],\n    ['1', '4', '3', '5', '1', '180', '0', '10']],\n    'else_content': [],\n    'extra': [],\n    'condition': None}}},\n}\n\n\n\n\nparsing.resolve_includes(path, gmx_builtin_ffs=None)\n\n\npath : Filepath to read.\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[str]\nList of lines.\n\n\nOptional[Path]\nPath to the ff directory if one of the includes used a file from it.\n\n\n\n\n\n\n\nparsing.write_json(d, path)\nWrite dict to file according to JSON format.\n\n\n\nparsing.write_plumed(d, path)\nWrite a plumed.dat configuration file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nd\nPlumed_dict\nDictionary containing ‘labeled_action’, ‘other’ and ‘prints’\nrequired\n\n\npath\nPath\nPath to the file. E.g. “plumed.dat”\nrequired\n\n\n\n\n\n\n\nparsing.write_top(top, outfile)\nWrite a TopologyDict to a topology file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntop\nTopologyDict\nRaw dictionary represenation of the topology.\nrequired\n\n\noutfile\nPath\nPath to the topology file to write to.\nrequired"
  },
  {
    "objectID": "_reference/recipe.html",
    "href": "_reference/recipe.html",
    "title": "recipe",
    "section": "",
    "text": "recipe\nContains the Reaction Recipe, RecipeStep and RecipeCollection.\n\n\n\n\n\nName\nDescription\n\n\n\n\nBind\nChange topology to form a bond\n\n\nBondOperation\nHandle a bond operation on the recipe step.\n\n\nBreak\nChange topology to break a bond\n\n\nPlace\nChange topology and/or coordinates to place an atom.\n\n\nRecipe\nA reaction path defined by one series of RecipeSteps.\n\n\nRecipeCollection\nA RecipeCollection encompasses a number of reaction paths.\n\n\nRecipeStep\nBase class for all RecipeSteps.\n\n\nRelax\nStart a relaxation MD.\n\n\n\n\n\nrecipe.Bind()\nChange topology to form a bond\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_ix_1\nint\nThe index of the first atom. zero-based, by default None\nrequired\n\n\natom_ix_2\nint\nThe index of the second atom. zero-based, by default None\nrequired\n\n\natom_id_1\nstr\nThe ID of the first atom. one-based, by default None\nrequired\n\n\natom_id_2\nstr\nThe ID of the second atom. one-based, by default None\nrequired\n\n\n\n\n\n\n\nrecipe.BondOperation(atom_ix_1, atom_ix_2, atom_id_1, atom_id_2, _atom_ix_1=field(init=False, repr=False, default=None), _atom_ix_2=field(init=False, repr=False, default=None))\nHandle a bond operation on the recipe step.\nThis class takes in either zero-based indices or one-base IDs for two atoms\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_ix_1\nint\nThe index of the first atom. zero-based, by default None\nrequired\n\n\natom_ix_2\nint\nThe index of the second atom. zero-based, by default None\nrequired\n\n\natom_id_1\nstr\nThe ID of the first atom. one-based, by default None\nrequired\n\n\natom_id_2\nstr\nThe ID of the second atom. one-based, by default None\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValueError\nIf neither an index nor an ID is provided for any of the atoms.\n\n\n\n\n\n\nInternally, this class stores the atom indices and converts IDs to indices as needed.\n\n\n\n\nrecipe.Break()\nChange topology to break a bond\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_ix_1\nint\nThe index of the first atom. zero-based, by default None\nrequired\n\n\natom_ix_2\nint\nThe index of the second atom. zero-based, by default None\nrequired\n\n\natom_id_1\nstr\nThe ID of the first atom. one-based, by default None\nrequired\n\n\natom_id_2\nstr\nThe ID of the second atom. one-based, by default None\nrequired\n\n\n\n\n\n\n\nrecipe.Place(new_coords, ix_to_place, id_to_place, _ix_to_place=field(init=False, repr=False, default=None))\nChange topology and/or coordinates to place an atom.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew_coords\ntuple[float, float, float]\nNew xyz coordinates for atom to place to. Valid for the end point of the recipe timespan.\nrequired\n\n\nix_to_place\nint\nIndex of atom to place. 0-based.\nrequired\n\n\nid_to_place\nstr\nIndex of atom to place. 1-based\nrequired\n\n\n\n\n\n\n\nrecipe.Recipe(recipe_steps, rates, timespans)\nA reaction path defined by one series of RecipeSteps. Defines everything necessart to build the product state from the educt state.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_steps\nlist[RecipeStep]\nSingle sequence of RecipeSteps to build product\nrequired\n\n\nrates\nlist[float]\nReaction rates corresponding 1:1 to timespans.\nrequired\n\n\ntimespans\nlist[list[float, float]]\nList of half-open timespans (t1, t2] in ps, at which this reaction path applies. Must have same number of timespans as rates. t1 can equal t2 for the first frame.\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalc_averages\nCalulate average rates over some window size\n\n\ncheck_consistency\nRun consistency checks for correct size of variables\n\n\ncombine_with\nCombines this Recipe with another with the same RecipeSteps.\n\n\n\n\n\nrecipe.Recipe.calc_averages(window_size)\nCalulate average rates over some window size\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwindow_size\nint\nSize of the window to average over, -1 to average over whole available range.\nrequired\n\n\n\n\n\n\n\nrecipe.Recipe.check_consistency()\nRun consistency checks for correct size of variables\n\n\n\nrecipe.Recipe.combine_with(other)\nCombines this Recipe with another with the same RecipeSteps.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nRecipe\n\nrequired\n\n\n\n\n\n\n\n\n\nrecipe.RecipeCollection(recipes)\nA RecipeCollection encompasses a number of reaction paths. They can originate from multiple reaction plugins, but do not need to.\n\n\n\n\n\nName\nDescription\n\n\n\n\naggregate_reactions\nCombines reactions having the same sequence of RecipeSteps.\n\n\ncalc_cumprob\nCalculate cumulative probability of all contained recipe steps.\n\n\nfrom_csv\nCreate a RecipeCollection object from a CSV file\n\n\nplot\nPlot reaction rates over time\n\n\nto_csv\nWrite a ReactionResult as defined in the reaction module to a csv file\n\n\n\n\n\nrecipe.RecipeCollection.aggregate_reactions()\nCombines reactions having the same sequence of RecipeSteps.\n\n\n\nrecipe.RecipeCollection.calc_cumprob()\nCalculate cumulative probability of all contained recipe steps. Sums up to 1 over all recipes. Assumes constant rate for given timespan and rate zero otherwise.\n\n\n\nrecipe.RecipeCollection.from_csv(path)\nCreate a RecipeCollection object from a CSV file Returns the recipe collection and a single recipe that was picked, otherwise None\n\n\n\nrecipe.RecipeCollection.plot(outfile, highlight_r=None, highlight_t=None)\nPlot reaction rates over time\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutfile\nPath\nWhere to save the plot, must have compatible suffix.\nrequired\n\n\nhighlight_r\nRecipe\nRecipe to highlight, by default None\nNone\n\n\nhighlight_t\nfloat\nTime at which the reactions starts\nNone\n\n\n\n\n\n\n\nrecipe.RecipeCollection.to_csv(path, picked_recipe=None)\nWrite a ReactionResult as defined in the reaction module to a csv file\n\n\n\n\n\nrecipe.RecipeStep()\nBase class for all RecipeSteps. Indices can be accessed as 0-based or 1-based. ix: 0-based, int id: 1-based, str\n\n\n\nrecipe.Relax()\nStart a relaxation MD.\nThe molecular system coordinates are far out of equilibrium after most topology changes. A relaxtion MD simulation using for example the slow growth method helps to reach the new equilibrium."
  },
  {
    "objectID": "_reference/recipe.html#classes",
    "href": "_reference/recipe.html#classes",
    "title": "recipe",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBind\nChange topology to form a bond\n\n\nBondOperation\nHandle a bond operation on the recipe step.\n\n\nBreak\nChange topology to break a bond\n\n\nPlace\nChange topology and/or coordinates to place an atom.\n\n\nRecipe\nA reaction path defined by one series of RecipeSteps.\n\n\nRecipeCollection\nA RecipeCollection encompasses a number of reaction paths.\n\n\nRecipeStep\nBase class for all RecipeSteps.\n\n\nRelax\nStart a relaxation MD.\n\n\n\n\n\nrecipe.Bind()\nChange topology to form a bond\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_ix_1\nint\nThe index of the first atom. zero-based, by default None\nrequired\n\n\natom_ix_2\nint\nThe index of the second atom. zero-based, by default None\nrequired\n\n\natom_id_1\nstr\nThe ID of the first atom. one-based, by default None\nrequired\n\n\natom_id_2\nstr\nThe ID of the second atom. one-based, by default None\nrequired\n\n\n\n\n\n\n\nrecipe.BondOperation(atom_ix_1, atom_ix_2, atom_id_1, atom_id_2, _atom_ix_1=field(init=False, repr=False, default=None), _atom_ix_2=field(init=False, repr=False, default=None))\nHandle a bond operation on the recipe step.\nThis class takes in either zero-based indices or one-base IDs for two atoms\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_ix_1\nint\nThe index of the first atom. zero-based, by default None\nrequired\n\n\natom_ix_2\nint\nThe index of the second atom. zero-based, by default None\nrequired\n\n\natom_id_1\nstr\nThe ID of the first atom. one-based, by default None\nrequired\n\n\natom_id_2\nstr\nThe ID of the second atom. one-based, by default None\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValueError\nIf neither an index nor an ID is provided for any of the atoms.\n\n\n\n\n\n\nInternally, this class stores the atom indices and converts IDs to indices as needed.\n\n\n\n\nrecipe.Break()\nChange topology to break a bond\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_ix_1\nint\nThe index of the first atom. zero-based, by default None\nrequired\n\n\natom_ix_2\nint\nThe index of the second atom. zero-based, by default None\nrequired\n\n\natom_id_1\nstr\nThe ID of the first atom. one-based, by default None\nrequired\n\n\natom_id_2\nstr\nThe ID of the second atom. one-based, by default None\nrequired\n\n\n\n\n\n\n\nrecipe.Place(new_coords, ix_to_place, id_to_place, _ix_to_place=field(init=False, repr=False, default=None))\nChange topology and/or coordinates to place an atom.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew_coords\ntuple[float, float, float]\nNew xyz coordinates for atom to place to. Valid for the end point of the recipe timespan.\nrequired\n\n\nix_to_place\nint\nIndex of atom to place. 0-based.\nrequired\n\n\nid_to_place\nstr\nIndex of atom to place. 1-based\nrequired\n\n\n\n\n\n\n\nrecipe.Recipe(recipe_steps, rates, timespans)\nA reaction path defined by one series of RecipeSteps. Defines everything necessart to build the product state from the educt state.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_steps\nlist[RecipeStep]\nSingle sequence of RecipeSteps to build product\nrequired\n\n\nrates\nlist[float]\nReaction rates corresponding 1:1 to timespans.\nrequired\n\n\ntimespans\nlist[list[float, float]]\nList of half-open timespans (t1, t2] in ps, at which this reaction path applies. Must have same number of timespans as rates. t1 can equal t2 for the first frame.\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalc_averages\nCalulate average rates over some window size\n\n\ncheck_consistency\nRun consistency checks for correct size of variables\n\n\ncombine_with\nCombines this Recipe with another with the same RecipeSteps.\n\n\n\n\n\nrecipe.Recipe.calc_averages(window_size)\nCalulate average rates over some window size\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwindow_size\nint\nSize of the window to average over, -1 to average over whole available range.\nrequired\n\n\n\n\n\n\n\nrecipe.Recipe.check_consistency()\nRun consistency checks for correct size of variables\n\n\n\nrecipe.Recipe.combine_with(other)\nCombines this Recipe with another with the same RecipeSteps.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nRecipe\n\nrequired\n\n\n\n\n\n\n\n\n\nrecipe.RecipeCollection(recipes)\nA RecipeCollection encompasses a number of reaction paths. They can originate from multiple reaction plugins, but do not need to.\n\n\n\n\n\nName\nDescription\n\n\n\n\naggregate_reactions\nCombines reactions having the same sequence of RecipeSteps.\n\n\ncalc_cumprob\nCalculate cumulative probability of all contained recipe steps.\n\n\nfrom_csv\nCreate a RecipeCollection object from a CSV file\n\n\nplot\nPlot reaction rates over time\n\n\nto_csv\nWrite a ReactionResult as defined in the reaction module to a csv file\n\n\n\n\n\nrecipe.RecipeCollection.aggregate_reactions()\nCombines reactions having the same sequence of RecipeSteps.\n\n\n\nrecipe.RecipeCollection.calc_cumprob()\nCalculate cumulative probability of all contained recipe steps. Sums up to 1 over all recipes. Assumes constant rate for given timespan and rate zero otherwise.\n\n\n\nrecipe.RecipeCollection.from_csv(path)\nCreate a RecipeCollection object from a CSV file Returns the recipe collection and a single recipe that was picked, otherwise None\n\n\n\nrecipe.RecipeCollection.plot(outfile, highlight_r=None, highlight_t=None)\nPlot reaction rates over time\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutfile\nPath\nWhere to save the plot, must have compatible suffix.\nrequired\n\n\nhighlight_r\nRecipe\nRecipe to highlight, by default None\nNone\n\n\nhighlight_t\nfloat\nTime at which the reactions starts\nNone\n\n\n\n\n\n\n\nrecipe.RecipeCollection.to_csv(path, picked_recipe=None)\nWrite a ReactionResult as defined in the reaction module to a csv file\n\n\n\n\n\nrecipe.RecipeStep()\nBase class for all RecipeSteps. Indices can be accessed as 0-based or 1-based. ix: 0-based, int id: 1-based, str\n\n\n\nrecipe.Relax()\nStart a relaxation MD.\nThe molecular system coordinates are far out of equilibrium after most topology changes. A relaxtion MD simulation using for example the slow growth method helps to reach the new equilibrium."
  },
  {
    "objectID": "guide/how_to/options.html",
    "href": "guide/how_to/options.html",
    "title": "KIMMDY Options",
    "section": "",
    "text": "KIMMDY comes with autocompletion for the kimmdy.yml file. Run kimmdy --show-schema-path to get the path to the schema file. Then, add the following to either the top of your kimmmdy.yml file or add the schema to the global configuration of the yaml-language-server in your editor (e.g. VS Code or Neovim).\n\n\nkimmdy.yml\n\n# yaml-language-server: $schema=/your/path/to/kimmdy-yaml-schema.json\n\nOnce KIMMDY is public, you can replace the path with the following url:\n\n\nkimmdy.yml\n\n# yaml-language-server: $schema=https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/src/kimmdy/kimmdy-yaml-schema.json"
  },
  {
    "objectID": "guide/how_to/options.html#autocompletion",
    "href": "guide/how_to/options.html#autocompletion",
    "title": "KIMMDY Options",
    "section": "",
    "text": "KIMMDY comes with autocompletion for the kimmdy.yml file. Run kimmdy --show-schema-path to get the path to the schema file. Then, add the following to either the top of your kimmmdy.yml file or add the schema to the global configuration of the yaml-language-server in your editor (e.g. VS Code or Neovim).\n\n\nkimmdy.yml\n\n# yaml-language-server: $schema=/your/path/to/kimmdy-yaml-schema.json\n\nOnce KIMMDY is public, you can replace the path with the following url:\n\n\nkimmdy.yml\n\n# yaml-language-server: $schema=https://raw.githubusercontent.com/hits-mbm-dev/kimmdy/main/src/kimmdy/kimmdy-yaml-schema.json"
  },
  {
    "objectID": "guide/how_to/options.html#all-options",
    "href": "guide/how_to/options.html#all-options",
    "title": "KIMMDY Options",
    "section": "All Options",
    "text": "All Options\nThe following is a list of the options that can be set in the kimmdy.yml file. It includes reactions currently available in KIMMDY as plugins. Nested options are separated by a .. * denotes an arbitrary name for a section. The key for a section is bold.\n\n\nTable 1: KIMMDY options\n\n\n\n\n\n\n\n\n\nOption\nDescription\nType\nDefault\n\n\n\n\n\ndryrun\nDon’t run the actual simulations, just print the tasks\nbool\nFalse\n\n\n\ncwd\nWorking directory\nPath\n\n\n\n\nname\nUsed for output folder if out is not specified\nstr\nkimmdy\n\n\n\nout\nOutput folder\nPath\n\n\n\n\nlog\nSettings for logging\n\n\n\n\n\nmax_tasks\nMaximum number of tasks to run. This is useful when a task in the sequence can dymanically add more tasks. 0 means no limit.\nint\n0\n\n\n\nmax_hours\nStop KIMMDY after max_hours hours. Set this lower than the limit of your HPC cluster for use with a re-submit jobscript. 0 Means no limit.\nint\n0\n\n\n\nrun\nReplica number\nint\n1\n\n\n\ntop\nTopology file\nPath\ntopol.top\n\n\n\ngro\nCoordinate file\nPath\nconf.gro\n\n\n\nndx\nIndex file\nPath\nindex.ndx\n\n\n\ngromacs_alias\nGromacs alias\nstr\ngmx\n\n\n\ngmx_mdrun_flags\nFlags passed to gmx mdrun. e.g. -nt 8 -maxh 24\nstr\n-maxh 24 -dlb yes\n\n\n\nff\nForce field directory (looks for .ff in cwd if not set)\nPath\n*.ff\n\n\n\nplumed\n.dat file containing plumed config\nPath\n\n\n\n\ntpr\n.tpr file of a finished simulation for starting with reaction\nPath\n\n\n\n\ntrr\n.trr file of a finished simulation for starting with reaction\nPath\n\n\n\n\nmds\nSettings for MD steps, e.g. mdp files, plumed files, etc.\n\n\n\n\n\nmds.*.mdp\nMDP file for the MD step\nPath\n\n\n\n\nmds.*.use_plumed\nWhether plumed should be used for this run or not\nbool\nFalse\n\n\n\nchanger\nSettings for applying a reaction recipe\n\n\n\n\n\nchanger.coordinates.md\nWhich MD instance from the ‘mds’ section is used for relaxation MDs\nstr\n\n\n\n\nchanger.coordinates.slow_growth\nWhether the chosen MD instance is a slow growth/free-energy simulation\nbool\nFalse\n\n\n\nchanger.topology.parameterization\nParameterization scheme that is used on the topology file after changes to it\nstr\nbasic\n\n\n\nsequence\nList of tasks. Each task can be a string (the name of the task) or an object with the task name and a multiplicity mult: &lt;int&gt;\nSequence\n\n\n\n\nreactions\nSettings for reactions\n\n\n\n\n\nplot_rates\nPlot the reaction rates\nbool\nTrue\n\n\n\nsave_recipes\nSave recipes as csv during decide_reaction\nbool\nTrue"
  },
  {
    "objectID": "guide/how_to/options.html#example-kimmdy.yml-files",
    "href": "guide/how_to/options.html#example-kimmdy.yml-files",
    "title": "KIMMDY Options",
    "section": "Example kimmdy.yml Files",
    "text": "Example kimmdy.yml Files\n\n\nkimmdy.yml\n\ndryrun: false\nmax_tasks: 100\nname: 'hat_tf_000'\ngromacs_alias: 'gmx'\ntop: 'Ala_out.top'\ngro: 'npt.gro'\nndx: 'index.ndx'\nmds:\n  equilibrium:\n    mdp: 'md.mdp'\n  relax:\n    mdp: 'md_slow.mdp'\nchanger:\n  coordinates:\n    md: 'relax'      \nreactions:\n  hat_reaction:\n    frequency_factor: 100000000\n    h_cutoff: 3\n    polling_rate: 1\n\nsequence:\n- equilibrium\n- mult: 2\n  tasks:\n  - equilibrium\n  - reactions"
  },
  {
    "objectID": "guide/how_to/contribute.html",
    "href": "guide/how_to/contribute.html",
    "title": "Contribute",
    "section": "",
    "text": "KIMMDY uses conventional commits and semantic versioning, automated via release please.\nIf a PR adds multiple commits, we use the squash and merge option to keep the commit history clean. If a PR unavoidably contains changes the message can be edited before merging to ensure release please picks up all changes.\nThe following example message (first line is the title in the GitHub UI, the rest is the body in the window below):\nfeat: this is a release-please test\n\nIt should add 3 features and a 2 fixes\nMaybe this first body is the important\npart of the commit message\n\nfix(ci): release please adds all the things\n  BREAKING-CHANGE: does this work?\n\nfeat(ci): update encode to support unicode\n  do I add a body here?\n\nfeat(ci): what if this doesn't have a body?\n\nfix(ci): or this?\nGenerates the following changelog:\n:robot: I have created a release *beep* *boop*\n---\n\n\n## [4.0.0](https://github.com/hits-mbm-dev/kimmdy/compare/v3.6.0...v4.0.0) (2023-08-11)\n\n\n### ⚠ BREAKING CHANGES\n\n* **ci:** does this work?\n\n### Features\n\n* **ci:** update encode to support unicode ([d9f16ad](https://github.com/hits-mbm-dev/kimmdy/commit/d9f16adb7470479a9e700ffd86597784caa2afe7))\n* **ci:** what if this doesn't have a body? ([d9f16ad](https://github.com/hits-mbm-dev/kimmdy/commit/d9f16adb7470479a9e700ffd86597784caa2afe7))\n* this is a release-please test ([d9f16ad](https://github.com/hits-mbm-dev/kimmdy/commit/d9f16adb7470479a9e700ffd86597784caa2afe7))\n\n\n### Bug Fixes\n\n* **ci:** or this? ([d9f16ad](https://github.com/hits-mbm-dev/kimmdy/commit/d9f16adb7470479a9e700ffd86597784caa2afe7))\n* **ci:** release please adds all the things ([d9f16ad](https://github.com/hits-mbm-dev/kimmdy/commit/d9f16adb7470479a9e700ffd86597784caa2afe7))\n\n---\nThis PR was generated with [Release Please](https://github.com/googleapis/release-please). See [documentation](https://github.com/googleapis/release-please#release-please).\n\n\nFor developoment, we provide a docker image containing gromacs and multiple python versions to test against.\nTo run the test locally, you must:\n\ninstall docker\ninstall act, easiest option is with github cli\n\ninstall github cli (gh)\ngh extension install https://github.com/nektos/gh-act\n\nrun tests with gh extension exec act -j test --artifact-server-path ./artifacts\n\ncustomize which python versions to test in tox.ini\nhtml coverage report is exported into artifacts"
  },
  {
    "objectID": "guide/how_to/contribute.html#local-testing",
    "href": "guide/how_to/contribute.html#local-testing",
    "title": "Contribute",
    "section": "",
    "text": "For developoment, we provide a docker image containing gromacs and multiple python versions to test against.\nTo run the test locally, you must:\n\ninstall docker\ninstall act, easiest option is with github cli\n\ninstall github cli (gh)\ngh extension install https://github.com/nektos/gh-act\n\nrun tests with gh extension exec act -j test --artifact-server-path ./artifacts\n\ncustomize which python versions to test in tox.ini\nhtml coverage report is exported into artifacts"
  },
  {
    "objectID": "guide/how_to/plugins.html",
    "href": "guide/how_to/plugins.html",
    "title": "Write Reaction Plugins",
    "section": "",
    "text": "Write Reaction Plugins\nTODO\n\n\n\n\n Back to top"
  },
  {
    "objectID": "guide/tutorials/getting-started.html",
    "href": "guide/tutorials/getting-started.html",
    "title": "0. Getting Started",
    "section": "",
    "text": "Let’s jump right in!\n\n\n\n\n\npython3.9 or higher\ngromacs (tested with version 2021.4, gmx should be available in the PATH)\n\nOptional:\n\nplumed-patched version of gromacs\n\n\n\n\n\nLet’s first create a virtual environment for kimmdy:\nmkdir kimmdy-tutorial\ncd kimmdy-tutorial\npython -m venv .venv\nsource .venv/bin/activate\nBecause we’ll be using optional reaction plugins directly from the git repository, we’ll need to install kimmdy from GitHub with the plugins extra:\n# TODO: update with https instead of ssh when repo is public\npip install 'git+ssh://git@github.com/hits-mbm-dev/kimmdy.git#egg=kimmdy[plugins]'\n# pip install 'git+ssh://git@github.com/hits-mbm-dev/kimmdy.git#egg&subdirectory=plugins'\n# pip install 'git+ssh://git@github.com/hits-mbm-dev/kimmdy.git@docs/config-completion#egg=kimmdy[plugins]'\n\n\n\nDownload the example kimmdy.yml file to this directory. It should look like this:\n\n\nkimmdy.yml\n\ndryrun: false\nmax_tasks: 100\nname: 'hat_tf_000'\ngromacs_alias: 'gmx'\ntop: 'Ala_out.top'\ngro: 'npt.gro'\nndx: 'index.ndx'\nmds:\n  equilibrium:\n    mdp: 'md.mdp'\n  relax:\n    mdp: 'md_slow.mdp'\nchanger:\n  coordinates:\n    md: 'relax'      \nreactions:\n  hat_reaction:\n    frequency_factor: 100000000\n    h_cutoff: 3\n    polling_rate: 1\n\nsequence:\n- equilibrium\n- mult: 2\n  tasks:\n  - equilibrium\n  - reactions\n\nLet’s also fetch the other input files:\n\nAla_out.top\nnpt.gro\ncat-center.gro\nindex.ndx\nmd.mdp\nmd_slow.mdp\nminim.mdp\n\n# TODO: while dev, copy run in example dir\n# from KIMMDY root directory\ncd example/alanine_hat_naive\nOur starting structure is a simple ACE/NME-capped Alanine molecule in a box of water.\n    \n    \n    \nStart a KIMMDY run with kimmdy command:\n\n\n\nkimmdy\nYou can also run kimmdy directly from python with\nfrom kimmdy.cmd import kimmdy_run\nkimmdy_run()\n\n\n\nConcatenate the trajectories from the individual steps into one for viewing:\nkimmdy-analysis trjcat alanine_hat_000 --open-vmd\nCheck the energy of the system:\nkimmdy-analysis plot_energy alanine_hat_000 --open-plot --terms Potential Kinetic\nVisualize where the radical ended up:\nkimmdy-analysis radical_population alanine_hat_000 --open-plot --open-vmd\nPlot the reaction rates:\nkimmdy-analysis plot_rates alanine_hat_000\nOr do all oft the above directly from python:\nfrom kimmdy.analysis import concat_trj, plot_energy, radical_population, plot_rates\nconcat_trj('alanine_hat_000', open_vmd=True)\nplot_energy('alanine_hat_000', terms=['Potential', 'Kinetic'], open_plot=True)\nradical_population('alanine_hat_000', open_plot=True, open_vmd=True)\nplot_rates('alanine_hat_000')"
  },
  {
    "objectID": "guide/tutorials/getting-started.html#installation",
    "href": "guide/tutorials/getting-started.html#installation",
    "title": "0. Getting Started",
    "section": "",
    "text": "python3.9 or higher\ngromacs (tested with version 2021.4, gmx should be available in the PATH)\n\nOptional:\n\nplumed-patched version of gromacs"
  },
  {
    "objectID": "guide/tutorials/getting-started.html#installation-1",
    "href": "guide/tutorials/getting-started.html#installation-1",
    "title": "0. Getting Started",
    "section": "",
    "text": "Let’s first create a virtual environment for kimmdy:\nmkdir kimmdy-tutorial\ncd kimmdy-tutorial\npython -m venv .venv\nsource .venv/bin/activate\nBecause we’ll be using optional reaction plugins directly from the git repository, we’ll need to install kimmdy from GitHub with the plugins extra:\n# TODO: update with https instead of ssh when repo is public\npip install 'git+ssh://git@github.com/hits-mbm-dev/kimmdy.git#egg=kimmdy[plugins]'\n# pip install 'git+ssh://git@github.com/hits-mbm-dev/kimmdy.git#egg&subdirectory=plugins'\n# pip install 'git+ssh://git@github.com/hits-mbm-dev/kimmdy.git@docs/config-completion#egg=kimmdy[plugins]'"
  },
  {
    "objectID": "guide/tutorials/getting-started.html#setup-the-simulation",
    "href": "guide/tutorials/getting-started.html#setup-the-simulation",
    "title": "0. Getting Started",
    "section": "",
    "text": "Download the example kimmdy.yml file to this directory. It should look like this:\n\n\nkimmdy.yml\n\ndryrun: false\nmax_tasks: 100\nname: 'hat_tf_000'\ngromacs_alias: 'gmx'\ntop: 'Ala_out.top'\ngro: 'npt.gro'\nndx: 'index.ndx'\nmds:\n  equilibrium:\n    mdp: 'md.mdp'\n  relax:\n    mdp: 'md_slow.mdp'\nchanger:\n  coordinates:\n    md: 'relax'      \nreactions:\n  hat_reaction:\n    frequency_factor: 100000000\n    h_cutoff: 3\n    polling_rate: 1\n\nsequence:\n- equilibrium\n- mult: 2\n  tasks:\n  - equilibrium\n  - reactions\n\nLet’s also fetch the other input files:\n\nAla_out.top\nnpt.gro\ncat-center.gro\nindex.ndx\nmd.mdp\nmd_slow.mdp\nminim.mdp\n\n# TODO: while dev, copy run in example dir\n# from KIMMDY root directory\ncd example/alanine_hat_naive\nOur starting structure is a simple ACE/NME-capped Alanine molecule in a box of water.\n    \n    \n    \nStart a KIMMDY run with kimmdy command:"
  },
  {
    "objectID": "guide/tutorials/getting-started.html#run-the-simulation",
    "href": "guide/tutorials/getting-started.html#run-the-simulation",
    "title": "0. Getting Started",
    "section": "",
    "text": "kimmdy\nYou can also run kimmdy directly from python with\nfrom kimmdy.cmd import kimmdy_run\nkimmdy_run()"
  },
  {
    "objectID": "guide/tutorials/getting-started.html#analyse-the-simulation",
    "href": "guide/tutorials/getting-started.html#analyse-the-simulation",
    "title": "0. Getting Started",
    "section": "",
    "text": "Concatenate the trajectories from the individual steps into one for viewing:\nkimmdy-analysis trjcat alanine_hat_000 --open-vmd\nCheck the energy of the system:\nkimmdy-analysis plot_energy alanine_hat_000 --open-plot --terms Potential Kinetic\nVisualize where the radical ended up:\nkimmdy-analysis radical_population alanine_hat_000 --open-plot --open-vmd\nPlot the reaction rates:\nkimmdy-analysis plot_rates alanine_hat_000\nOr do all oft the above directly from python:\nfrom kimmdy.analysis import concat_trj, plot_energy, radical_population, plot_rates\nconcat_trj('alanine_hat_000', open_vmd=True)\nplot_energy('alanine_hat_000', terms=['Potential', 'Kinetic'], open_plot=True)\nradical_population('alanine_hat_000', open_plot=True, open_vmd=True)\nplot_rates('alanine_hat_000')"
  },
  {
    "objectID": "guide/colbuilder.html",
    "href": "guide/colbuilder.html",
    "title": "Preparation",
    "section": "",
    "text": "Preparation\n\n\nSimulation\n#Analysis\n\n\n\n\n Back to top"
  }
]