[
  {
    "objectID": "guide/explanation/index.html",
    "href": "guide/explanation/index.html",
    "title": "Explanations",
    "section": "",
    "text": "Pages that help you understand the inner workings of KIMMDY\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nVisualize Topologies\n\n\n \n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "guide/how-to/index.html",
    "href": "guide/how-to/index.html",
    "title": "How-To",
    "section": "",
    "text": "How-To Guides\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nContribute\n\n\n \n\n\n\n\nExamples\n\n\n \n\n\n\n\nHigh Performance Computing\n\n\n \n\n\n\n\nInstall Machine Learning Plugins\n\n\n \n\n\n\n\nReaction only\n\n\nKai Riedmiller\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "guide/how-to/examples.html",
    "href": "guide/how-to/examples.html",
    "title": "Examples",
    "section": "",
    "text": "KIMMDY contains examples generated from our internal test systems. Those examples don’t currently have extensive documentation, but they can be used as a starting point for your own simulations.\nThe examples are located in the examples directory of the KIMMDY source code here.\nHere are their kimmdy.yml files at a glance:\n\n\ndryrun: false\nname: 'hexalanine_homolysis_000'\nmax_tasks: 100\ngromacs_alias: 'gmx'\ngmx_mdrun_flags: -maxh 24 -dlb yes -nt 8 -npme 0 -ntmpi 1\nff: 'amber99sb-star-ildnp.ff'\ntop: 'hexala_out.top'\ngro: 'npt.gro'\nndx: 'index.ndx'\nplumed: 'plumed.dat'\nmds:\n  equilibrium:\n    mdp: 'md.mdp'\n  pull:\n    mdp: 'md.mdp'\n    use_plumed: true\n  relax:\n    mdp: 'md_slow_growth.mdp'\nchanger:\n  coordinates:\n    md: 'relax'\n    slow_growth: True\n  topology:\n    parameterization: 'basic' \nreactions:\n  homolysis:\n    edis: 'edissoc.dat'\n    itp: 'ffbonded.itp'\nsequence:\n  - equilibrium\n  - pull  \n  - reactions\n  - equilibrium\n  - pull\n\n\n\ndryrun: false\nname: 'alanine_hat_000'\nmax_tasks: 100\ngromacs_alias: 'gmx'\ngmx_mdrun_flags: -maxh 24 -dlb yes -nt 8 -npme 0 -ntmpi 1\nff: 'amber99sb-star-ildnp.ff' # optional, dir endinng with .ff by default \ntop: 'Ala_out.top'\ngro: 'npt.gro'\nndx: 'index.ndx'\nmds:\n  equilibrium:\n    mdp: 'md.mdp'\n  relax:\n    mdp: 'md_slow_growth.mdp'\nchanger:\n  coordinates:\n    md: 'relax'  \n    slow_growth: True\n  topology:\n    parameterization: 'basic'\nreactions:\n  hat_naive:\n    frequency_factor: 100000000\n    h_cutoff: 3\n    polling_rate: 1\n\nsequence:\n- equilibrium\n- mult: 2\n  tasks:\n  - equilibrium\n  - reactions\n\n\n\nname: 'kimmdy_001'\ndryrun: false\nmax_tasks: 10\ngromacs_alias: 'gmx'\ngmx_mdrun_flags: -maxh 24 -dlb yes -nt 8 -npme 0 -ntmpi 1\nff: 'amber99sb-star-ildnp.ff' # optional, dir endinng with .ff by default \ntop: 'topol.top'\ngro: 'npt.gro'\nndx: 'index_backbone.ndx'\nplumed: 'plumed.dat'\nmds:\n  equilibrium:\n    mdp: 'pullf1500_equil.mdp'\n  prod:\n    mdp: 'pullf1500.mdp'\n    use_plumed: true\n  relax:\n    mdp: 'pullf1500.mdp'\nchanger:\n  coordinates:\n    md: 'relax'     \n  topology:\n    parameterization: 'basic' \nreactions:\n  homolysis:\n    edis: 'edissoc.dat'\n    itp: 'ffbonded.itp'\nsequence:\n  - equilibrium\n  - mult: 1\n    tasks:\n      - prod\n      - reactions\n\n\n\n\ndryrun: false\nname: 'single_reaction_000'\ngmx_mdrun_flags: -maxh 24 -dlb yes -nt 8 -npme 0 -ntmpi 1\nff: 'amber99sb-star-ildnp.ff'\ntop: 'hexala_out.top'\ngro: 'npt.gro'\nndx: 'index.ndx'\nplumed: 'plumed.dat'\ntrr: 'pull.trr'\nchanger:\n  coordinates: {}\n  topology:\n    parameterization: 'basic' \nreactions:\n  homolysis:\n    edis: 'edissoc.dat'\n    itp: 'ffbonded.itp'\n  dummyreaction: {}\nsequence:\n  - homolysis\n\n\n\nname: 'kimmdy_001'\ndryrun: false\nmax_tasks: 100\ngromacs_alias: 'gmx'\ngmx_mdrun_flags: -maxh 24 -dlb yes -nt 8\ntop: 'IMREE.top'\ngro: 'IMREE_npt.gro'\nndx: 'index.ndx'\nkmc: rfkmc\nplumed: 'plumed.dat'\nmds:\n  equilibrium:\n    mdp: 'md.mdp'\n  pull:\n    mdp: 'md.mdp'\n    use_plumed: true\n  relax:\n    mdp: 'md_slow_growth.mdp'\nchanger:\n  coordinates:\n    md: 'relax'    \n    slow_growth: True\n  topology:\n    parameterization: 'grappa' \nreactions:\n  homolysis:\n    edis: 'edissoc.dat'\n    itp: 'ffbonded.itp'\n  hat_naive:\n    frequency_factor: 100000000\n    h_cutoff: 3\n    polling_rate: 1\nplot_rates: true\nsave_recipes: true\nsequence:\n  - equilibrium\n  - pull\n  - homolysis\n  -\n    mult: 2\n    tasks:\n      - equilibrium\n      - pull\n      - reactions"
  },
  {
    "objectID": "guide/how-to/examples.html#further-examples",
    "href": "guide/how-to/examples.html#further-examples",
    "title": "Examples",
    "section": "",
    "text": "KIMMDY contains examples generated from our internal test systems. Those examples don’t currently have extensive documentation, but they can be used as a starting point for your own simulations.\nThe examples are located in the examples directory of the KIMMDY source code here.\nHere are their kimmdy.yml files at a glance:\n\n\ndryrun: false\nname: 'hexalanine_homolysis_000'\nmax_tasks: 100\ngromacs_alias: 'gmx'\ngmx_mdrun_flags: -maxh 24 -dlb yes -nt 8 -npme 0 -ntmpi 1\nff: 'amber99sb-star-ildnp.ff'\ntop: 'hexala_out.top'\ngro: 'npt.gro'\nndx: 'index.ndx'\nplumed: 'plumed.dat'\nmds:\n  equilibrium:\n    mdp: 'md.mdp'\n  pull:\n    mdp: 'md.mdp'\n    use_plumed: true\n  relax:\n    mdp: 'md_slow_growth.mdp'\nchanger:\n  coordinates:\n    md: 'relax'\n    slow_growth: True\n  topology:\n    parameterization: 'basic' \nreactions:\n  homolysis:\n    edis: 'edissoc.dat'\n    itp: 'ffbonded.itp'\nsequence:\n  - equilibrium\n  - pull  \n  - reactions\n  - equilibrium\n  - pull\n\n\n\ndryrun: false\nname: 'alanine_hat_000'\nmax_tasks: 100\ngromacs_alias: 'gmx'\ngmx_mdrun_flags: -maxh 24 -dlb yes -nt 8 -npme 0 -ntmpi 1\nff: 'amber99sb-star-ildnp.ff' # optional, dir endinng with .ff by default \ntop: 'Ala_out.top'\ngro: 'npt.gro'\nndx: 'index.ndx'\nmds:\n  equilibrium:\n    mdp: 'md.mdp'\n  relax:\n    mdp: 'md_slow_growth.mdp'\nchanger:\n  coordinates:\n    md: 'relax'  \n    slow_growth: True\n  topology:\n    parameterization: 'basic'\nreactions:\n  hat_naive:\n    frequency_factor: 100000000\n    h_cutoff: 3\n    polling_rate: 1\n\nsequence:\n- equilibrium\n- mult: 2\n  tasks:\n  - equilibrium\n  - reactions\n\n\n\nname: 'kimmdy_001'\ndryrun: false\nmax_tasks: 10\ngromacs_alias: 'gmx'\ngmx_mdrun_flags: -maxh 24 -dlb yes -nt 8 -npme 0 -ntmpi 1\nff: 'amber99sb-star-ildnp.ff' # optional, dir endinng with .ff by default \ntop: 'topol.top'\ngro: 'npt.gro'\nndx: 'index_backbone.ndx'\nplumed: 'plumed.dat'\nmds:\n  equilibrium:\n    mdp: 'pullf1500_equil.mdp'\n  prod:\n    mdp: 'pullf1500.mdp'\n    use_plumed: true\n  relax:\n    mdp: 'pullf1500.mdp'\nchanger:\n  coordinates:\n    md: 'relax'     \n  topology:\n    parameterization: 'basic' \nreactions:\n  homolysis:\n    edis: 'edissoc.dat'\n    itp: 'ffbonded.itp'\nsequence:\n  - equilibrium\n  - mult: 1\n    tasks:\n      - prod\n      - reactions\n\n\n\n\ndryrun: false\nname: 'single_reaction_000'\ngmx_mdrun_flags: -maxh 24 -dlb yes -nt 8 -npme 0 -ntmpi 1\nff: 'amber99sb-star-ildnp.ff'\ntop: 'hexala_out.top'\ngro: 'npt.gro'\nndx: 'index.ndx'\nplumed: 'plumed.dat'\ntrr: 'pull.trr'\nchanger:\n  coordinates: {}\n  topology:\n    parameterization: 'basic' \nreactions:\n  homolysis:\n    edis: 'edissoc.dat'\n    itp: 'ffbonded.itp'\n  dummyreaction: {}\nsequence:\n  - homolysis\n\n\n\nname: 'kimmdy_001'\ndryrun: false\nmax_tasks: 100\ngromacs_alias: 'gmx'\ngmx_mdrun_flags: -maxh 24 -dlb yes -nt 8\ntop: 'IMREE.top'\ngro: 'IMREE_npt.gro'\nndx: 'index.ndx'\nkmc: rfkmc\nplumed: 'plumed.dat'\nmds:\n  equilibrium:\n    mdp: 'md.mdp'\n  pull:\n    mdp: 'md.mdp'\n    use_plumed: true\n  relax:\n    mdp: 'md_slow_growth.mdp'\nchanger:\n  coordinates:\n    md: 'relax'    \n    slow_growth: True\n  topology:\n    parameterization: 'grappa' \nreactions:\n  homolysis:\n    edis: 'edissoc.dat'\n    itp: 'ffbonded.itp'\n  hat_naive:\n    frequency_factor: 100000000\n    h_cutoff: 3\n    polling_rate: 1\nplot_rates: true\nsave_recipes: true\nsequence:\n  - equilibrium\n  - pull\n  - homolysis\n  -\n    mult: 2\n    tasks:\n      - equilibrium\n      - pull\n      - reactions"
  },
  {
    "objectID": "guide/how-to/hcp.html",
    "href": "guide/how-to/hcp.html",
    "title": "High Performance Computing",
    "section": "",
    "text": "You need an installation of python (&gt;= 3.10) and (possibly PLUMED patched) GROMACS in your HPC environment.\nExample setup:\nsrun -t 1400:00 --mem=16000 -n20 --pty /bin/bash\nml EasyBuild\neb ./assets/Python-3.10.8.eb\nPrepare a bash script _modules.sh that loads the required modules and activates the python environment in which KIMMDY is installed.\nRun\nkimmdy --generate-jobscript\nto generate a file jobscript.sh that can be submitted to the HPC cluster.\nThis commands generates a kimmdy checkpoint and prepares the output folder. KIMMDY can then be started and re-started from the checkpoint via the jobscript, which uses\n# -c = continue, same  as --from-latest-checkpoint\nkimmdy -c"
  },
  {
    "objectID": "guide/how-to/hcp.html#setup",
    "href": "guide/how-to/hcp.html#setup",
    "title": "High Performance Computing",
    "section": "",
    "text": "You need an installation of python (&gt;= 3.10) and (possibly PLUMED patched) GROMACS in your HPC environment.\nExample setup:\nsrun -t 1400:00 --mem=16000 -n20 --pty /bin/bash\nml EasyBuild\neb ./assets/Python-3.10.8.eb\nPrepare a bash script _modules.sh that loads the required modules and activates the python environment in which KIMMDY is installed.\nRun\nkimmdy --generate-jobscript\nto generate a file jobscript.sh that can be submitted to the HPC cluster.\nThis commands generates a kimmdy checkpoint and prepares the output folder. KIMMDY can then be started and re-started from the checkpoint via the jobscript, which uses\n# -c = continue, same  as --from-latest-checkpoint\nkimmdy -c"
  },
  {
    "objectID": "guide/references/input.html",
    "href": "guide/references/input.html",
    "title": "Input File",
    "section": "",
    "text": "KIMMDY comes with autocompletion and tooltips insight your editor for its configuration file kimmdy.yml.\nAll you need to do is activate a yaml-language-server in your editor (e.g. VS Code via the YAML extension or Neovim via lspconfig).\nActivating this is very much recommended, as it prevents many typos and missaligned braces.\n\n\n\n\n\n\n\n\n\n\nThis only works, if your config file is called kimmdy.yml and the Scheme Store hasn’t been disabled in your editor settings (e.g. Yaml &gt; Schema Store: Enable."
  },
  {
    "objectID": "guide/references/input.html#autocompletion",
    "href": "guide/references/input.html#autocompletion",
    "title": "Input File",
    "section": "",
    "text": "KIMMDY comes with autocompletion and tooltips insight your editor for its configuration file kimmdy.yml.\nAll you need to do is activate a yaml-language-server in your editor (e.g. VS Code via the YAML extension or Neovim via lspconfig).\nActivating this is very much recommended, as it prevents many typos and missaligned braces.\n\n\n\n\n\n\n\n\n\n\nThis only works, if your config file is called kimmdy.yml and the Scheme Store hasn’t been disabled in your editor settings (e.g. Yaml &gt; Schema Store: Enable."
  },
  {
    "objectID": "guide/references/input.html#all-options",
    "href": "guide/references/input.html#all-options",
    "title": "Input File",
    "section": "All Options",
    "text": "All Options\nThe following is a list of the options that can be set in the kimmdy.yml file. It includes reactions currently available in KIMMDY as plugins. Nested options are separated by a .. * denotes an arbitrary name for a section. The key for a section is bold.\n\n\nTable 1: KIMMDY options\n\n\n\n\n\n\n\n\n\nOption\nDescription\nType\nDefault\n\n\n\n\n\ndryrun\nDon’t run the actual simulations, just print the tasks\nbool\nFalse\n\n\n\nwrite_checkpoint\nWrite checkpoints to continue a KIMMDY run from. Default True\nbool\nTrue\n\n\n\ncwd\nWorking directory. Default is current working directory\nPath\n\n\n\n\nname\nUsed for output folder if out is not specified\nstr\nkimmdy\n\n\n\nout\nOutput folder\nPath\n\n\n\n\nlog\nSettings for logging\n\n\n\n\n\nmax_tasks\nMaximum number of tasks to run. This is useful when a task in the sequence can dymanically add more tasks. 0 means no limit.\nint\n0\n\n\n\nmax_hours\nStop KIMMDY after max_hours hours. Set this lower than the limit of your HPC cluster for use with a re-submit jobscript. 0 Means no limit.\nint\n0\n\n\n\nkmc\nKMC algorithm overwrite. Should be set by the reactions, but can be changed here.\nstr\n\n\n\n\ntau_scale\nScaling parameter for tau in the extrande kmc algorithm.\nfloat\n1.0\n\n\n\ntop\nTopology file\nPath\ntopol.top\n\n\n\ntopology\nSettings for handling the topology file.\n\n\n\n\n\ntopology.reactive.include\nExplicitly include a moleculetype or list of moleculetypes as a space-separated string.\nstr\n\n\n\n\ntopology.reactive.exclude\nExplicitly exclude a moleculetype or a list as a space-separated string. For example the lipid moleculetype in a bilayer simulation e.g. DPPC POPC'\nstr\n\n\n\n\ngro\nCoordinate file\nPath\nconf.gro\n\n\n\nndx\nGromaxs index file\nPath\nindex.ndx\n\n\n\ngromacs_alias\nGromacs alias. e.g. gmx or mpirun gmx_mpi\nstr\ngmx\n\n\n\ngmx_mdrun_flags\nFlags passed to gmx mdrun. Default -maxh 24 -dlb yes\nstr\n-maxh 24 -dlb yes\n\n\n\nff\nForce field directory (looks for .ff in cwd if not set)\nPath\n*.ff\n\n\n\nplumed\n.dat file containing plumed config\nPath\n\n\n\n\ntpr\n.tpr file of a finished simulation for starting directly with a reaction\nPath\n\n\n\n\ntrr\n.trr file of a finished simulation for starting directly with a reaction\nPath\n\n\n\n\nmds\nSettings for MD steps, e.g. mdp files, plumed files, etc.\n\n\n\n\n\nmds.*.mdp\nMDP file for the MD step\nPath\n\n\n\n\nmds.*.use_plumed\nWhether plumed should be used for this run or not\nbool\nFalse\n\n\n\nchanger\nSettings for applying a reaction recipe\n\n\n\n\n\nchanger.coordinates.md\nMD step from the ‘mds’ section that is used for relaxation MDs\nstr\n\n\n\n\nchanger.coordinates.slow_growth\nWhether the chosen MD step is a slow growth/free-energy simulation\nbool\nFalse\n\n\n\nchanger.topology.parameterization\nParameterization scheme that is used on the topology file after changes to it\nstr\nbasic\n\n\n\nsequence\nList of tasks. Each task can be a string (the name of the task) or an object with the task name and a multiplicity mult: &lt;int&gt;\nSequence\n\n\n\n\nreactions\nSettings for reactions\n\n\n\n\n\nplot_rates\nPlot the reaction rates during the reactions step\nbool\nTrue\n\n\n\nsave_recipes\nSave recipes as csv during the reactions step\nbool\nTrue"
  },
  {
    "objectID": "guide/references/input.html#example-kimmdy.yml-files",
    "href": "guide/references/input.html#example-kimmdy.yml-files",
    "title": "Input File",
    "section": "Example kimmdy.yml Files",
    "text": "Example kimmdy.yml Files\n\n\nkimmdy.yml\n\ndryrun: false\nmax_tasks: 100\nname: 'hat_tf_000'\ngromacs_alias: 'gmx'\ntop: 'Ala_out.top'\ngro: 'npt.gro'\nndx: 'index.ndx'\nmds:\n  equilibrium:\n    mdp: 'md.mdp'\n  relax:\n    mdp: 'md_slow.mdp'\nchanger:\n  coordinates:\n    md: 'relax'      \nreactions:\n  hat_reaction:\n    frequency_factor: 100000000\n    h_cutoff: 3\n    polling_rate: 1\n\nsequence:\n- equilibrium\n- mult: 2\n  tasks:\n  - equilibrium\n  - reactions"
  },
  {
    "objectID": "guide/tutorials/getting-started.html",
    "href": "guide/tutorials/getting-started.html",
    "title": "Get Started",
    "section": "",
    "text": "In this tutorial we will be simulating hydrogen atom transfer in a simple ACE/NME-capped Alanine molecule in a box of water."
  },
  {
    "objectID": "guide/tutorials/getting-started.html#installation",
    "href": "guide/tutorials/getting-started.html#installation",
    "title": "Get Started",
    "section": "Installation",
    "text": "Installation\n\nPrerequisites\n\npython3.9 or higher\ngromacs (tested with version 2021.4, gmx should be available in the PATH)\n\nOptional:\n\nplumed-patched version of gromacs (for the homolysis reaction).\n\n\n\n\n\n\n\n\n\n\n\nIf you plan to use our machine-learning plugins, take a look at the full installation instruction\n\n\nLet’s first create a directory and a virtual environment for kimmdy:\nmkdir kimmdy-tutorial\ncd kimmdy-tutorial\npython -m venv .venv\nsource .venv/bin/activate\nTo install KIMMDY, the builtin reaction plugins and the analysis tools use\npip install kimmdy[reactions,analysis]"
  },
  {
    "objectID": "guide/tutorials/getting-started.html#setup-the-simulation",
    "href": "guide/tutorials/getting-started.html#setup-the-simulation",
    "title": "Get Started",
    "section": "Setup the Simulation",
    "text": "Setup the Simulation\nDownload and unzip the input files to this directory.\nwget https://hits-mbm-dev.github.io/kimmdy/guide/tutorials/getting-started-files/setup.zip\nunzip setup.zip\nThe kimmdy.yml file should look like this:\n\n\nkimmdy.yml\n\ndryrun: false\nmax_tasks: 100\nname: 'hat_tf_000'\ngromacs_alias: 'gmx'\ntop: 'Ala_out.top'\ngro: 'npt.gro'\nndx: 'index.ndx'\nmds:\n  equilibrium:\n    mdp: 'md.mdp'\n  relax:\n    mdp: 'md_slow.mdp'\nchanger:\n  coordinates:\n    md: 'relax'      \nreactions:\n  hat_reaction:\n    frequency_factor: 100000000\n    h_cutoff: 3\n    polling_rate: 1\n\nsequence:\n- equilibrium\n- mult: 2\n  tasks:\n  - equilibrium\n  - reactions\n\nOur starting structure is a simple ACE/NME-capped Alanine molecule in a box of water. Note, how it has a missing hydrogen atom on the alpha carbon. This is a radical. We will use the builtin hat_reaction to simulate hydrogen atom transfer reactions from nearby hydrogens to the radical position.\n    \n    \n    \nStart the KIMMDY run with the kimmdy command:"
  },
  {
    "objectID": "guide/tutorials/getting-started.html#run-the-simulation",
    "href": "guide/tutorials/getting-started.html#run-the-simulation",
    "title": "Get Started",
    "section": "Run the Simulation",
    "text": "Run the Simulation\nkimmdy\nYou can also run kimmdy directly from python with\nfrom kimmdy.cmd import kimmdy_run\nkimmdy_run()\n\n\n\n\n\n\nTip\n\n\n\nKIMMDY parses your topology to generate its internal representation and writes out a new topology to be used in future steps. This topology includes everything gromacs needs to run the simulation, including forcefield parameters. KIMMDY combines all moleculetypes that are meant to take part in reactions into one moleculetype named “Reactive”. It also makes multiples explicit (e.g. 10 molecules of a peptide), such that each reactive atom has a unique representation. You can always find this topology in the output directory for the kimmdy setup task, e.g. alanine_hat_000/0_setup/&lt;name-of-your-top.top. By default, everything that is not a solvent or ion is considered reactive. To exclude or include certain moleculetypes from this (e.g. in a lipid bilayer simulation), check out the topology.reactive options in the input file documentation. You can find another example of merging topologies in the topology explanation."
  },
  {
    "objectID": "guide/tutorials/getting-started.html#analyse-the-simulation",
    "href": "guide/tutorials/getting-started.html#analyse-the-simulation",
    "title": "Get Started",
    "section": "Analyse the Simulation",
    "text": "Analyse the Simulation\nConcatenate the trajectories from the individual steps into one for viewing:\nkimmdy-analysis trjcat alanine_hat_000 --open-vmd\nCheck the energy of the system:\nkimmdy-analysis energy alanine_hat_000 --open-plot --terms Potential Kinetic\n\n\n\nEnergy plot\n\n\nVisualize where the radicals end up:\nkimmdy-analysis radical_population alanine_hat_000 --open-plot --open-vmd\nIn VMD, color the atoms by beta factor to show the radical occupancy.\n\n\n\nVMD representation settings\n\n\n\n\n\nRadical population plot\n\n\nPlot the reaction rates:\nkimmdy-analysis rates alanine_hat_000\nIn the alanine_hat_000/analysis directory you will then find a plot of rates for each possible reaction at every step they were queried, e.g.\n\n\n\nReaction rates plot\n\n\nOr do all of the above directly from python:\nfrom kimmdy.analysis import concat_trj, plot_energy, radical_population, plot_rates\nconcat_trj('alanine_hat_000', open_vmd=True)\nplot_energy('alanine_hat_000', terms=['Potential', 'Kinetic'], open_plot=True)\nradical_population('alanine_hat_000', open_plot=True, open_vmd=True)\nplot_rates('alanine_hat_000')\nCongratulations, you have successfully run your first KIMMDY simulation!"
  },
  {
    "objectID": "guide/tutorials/getting-started.html#next-steps",
    "href": "guide/tutorials/getting-started.html#next-steps",
    "title": "Get Started",
    "section": "Next steps",
    "text": "Next steps\n\nLearn more about the kimmdy.yml input file\nRun KIMMDY with a collagen fibril from Colbuilder\nWrite your own reaction plugin\nDiscover more plugins by looking for the kimmdy tag on GitHub"
  },
  {
    "objectID": "guide/tutorials/colbuilder.html",
    "href": "guide/tutorials/colbuilder.html",
    "title": "Run KIMMDY from Colbuilder fibril",
    "section": "",
    "text": "In this tutorial we will download a collagen fibril from colbuilder and run a KIMMDY simulation on it."
  },
  {
    "objectID": "guide/tutorials/colbuilder.html#preparation",
    "href": "guide/tutorials/colbuilder.html#preparation",
    "title": "Run KIMMDY from Colbuilder fibril",
    "section": "Preparation",
    "text": "Preparation\n\nDownload the desired model and the ff parameters for gromacs from colbuilder\nClean the force field files by moving amber99sb-star-ildnp.ff up to the working directory, adding residuetypes.dat and specbond.dat to the working directory, removing temporary files ._* and deleting the rest of collagen.ff\nConvert the pdb file to .gro format and create a unified topology file\n\n\n\n\n\n\n\nCaution\n\n\n\nDue to some issues in GROMACS, pdb2gmx may take a while (~16 hours). The majority of the time is actually spend on checks that happen just before the final lines are written to the file. It is possible to stop the process early and add the final lines manually.\n\n\ngmx pdb2gmx -f Homo_sapiens_aln_N_HLKNL_12_C_PYD_2_fibril.pdb -o fibril2.gro -ignh -water tip3p -merge all &lt;&lt;&lt;1"
  },
  {
    "objectID": "guide/tutorials/colbuilder.html#equilibration",
    "href": "guide/tutorials/colbuilder.html#equilibration",
    "title": "Run KIMMDY from Colbuilder fibril",
    "section": "Equilibration",
    "text": "Equilibration\nmdp files for the following steps are located in &lt;kimmdy root&gt;/www/colbuilder_files.\ngmx editconf -f fibril.gro -o fibril_x.gro -c -princ  &lt;&lt;&lt;1\n\ngmx editconf -f fibril_x.gro -o fibril_z.gro -rotate 0 270 0 -c\n\ngmx editconf -f fibril_z.gro -o fibril_box.gro -c -box 16.3 17.7 95.0 -bt triclinic\n\ngmx solvate -cp fibril_box.gro -p topol.top -o fibril_solv.gro\n\ntouch ions.mdp\n\ngmx grompp -f ions.mdp -c fibril_solv.gro -p topol.top -o fibril_genion.tpr\n\ngmx genion -s fibril_genion.tpr -p topol.top -o fibril_ion.gro -conc 0.15 -neutral &lt; SOL\n\ngmx grompp -f minim.mdp -c fibril_ion.gro -p topol.top -o fibril_min.tpr\n\ngmx mdrun -deffnm fibril_min -v\n\n\n\n\n\n\nCaution\n\n\n\nHeavy computational load from here on.\n\n\ngmx grompp -f nvt.mdp -c fibril_min.gro -r fibril_min.gro -p topol.top -o fibril_nvt.tpr\n\ngmx mdrun -deffnm fibril_nvt -v -dlb yes -ntomp 4 -ntmpi 10  -pme gpu -bonded gpu -npme 1\n\ngmx grompp -f npt.mdp -c fibril_nvt.gro -r fibril_nvt.gro -p topol.top -o fibril_npt.tpr\n\ngmx mdrun -deffnm fibril_npt -v -dlb yes -ntomp 4 -ntmpi 10  -pme gpu -bonded gpu -npme 1\n\n\n\n\n\n\nTip\n\n\n\nThe equilibration process can take up to 4 days. An equilibrated system will be provided in the release assets."
  },
  {
    "objectID": "guide/tutorials/colbuilder.html#kimmdy-run-preparation-and-simulation",
    "href": "guide/tutorials/colbuilder.html#kimmdy-run-preparation-and-simulation",
    "title": "Run KIMMDY from Colbuilder fibril",
    "section": "KIMMDY Run Preparation and Simulation",
    "text": "KIMMDY Run Preparation and Simulation\n\nConfiguration File Template\nFor a KIMMDY run, some additional setup is required. A suitable KIMMDY config file for homolysis can be found in the hexalanine_homolysis example:\n\n\nKIMMDY config file (kimmdy.yml)\n\n\n\nkimmdy.yml\n\ndryrun: false\nname: 'hexalanine_homolysis_000'\nmax_tasks: 100\ngromacs_alias: 'gmx'\ngmx_mdrun_flags: -maxh 24 -dlb yes -nt 8\nff: 'amber99sb-star-ildnp.ff'\ntop: 'hexala_out.top'\ngro: 'npt.gro'\nndx: 'index.ndx'\nplumed: 'plumed.dat'\nmds:\n  pull:\n    mdp: 'pull_fibril.mdp'\n  pull:\n    mdp: 'md.mdp'\n    use_plumed: true\n  relax:\n    mdp: 'md_slow_growth.mdp'\nchanger:\n  coordinates:\n    md: 'relax'\n    slow_growth: True\n  topology:\n    parameterization: 'basic' \nreactions:\n  homolysis:\n    edis: 'edissoc.dat'\n    itp: 'ffbonded.itp'\nsequence:\n  - equilibrium\n  - pull  \n  - reactions\n  - equilibrium\n  - pull\n\n\n\n\nGromacs index file v1\nThe config file mentions three important gromacs file for your system: top, gro, idx. We have the top and gro file from the equilibration and can update the file names in the config file. A basic index file can be generated with\necho 'q' | gmx make_ndx -f fibril_npt.gro -o index.ndx\n\n\nPlumed.dat and index file v2\nThe next entry in the config file is plumed and references a plumed configuration file (plumed.dat) which we don’t yet have. This file is needed for the homolysis reaction plugin.\nFor homolysis, the plumed.dat file should contain instructions to sample distances between bonds. Homolysis can then occur for the bonds mentioned in this file. A script to create a plumed.dat file (create_plumed_config.py) can be found in the tutorial files. Check out the script to understand its input and output!\nWe want to sample homolysis in the backbone and in crosslinks. By providing a gromacs index file with all backbone and crosslink atoms, the script generates the necessary plumed.dat file. Our initial index file does not contain those sections, so we have to create them ourselves. Such a index file can be generated with\necho -ne \"\\\"Backbone\\\"| r LY2 LY3 L4Y L5Y LYX\\nq\\n\"| gmx make_ndx -f fibril_npt.gro -o index.ndx\nNow run the python script to generate a plumed.dat file and check its contents.\n\n\nHomolysis Plugin Files: edissoc.dat and ffbonded.itp\nIn the reactions section, other files which are necessary for the homolysis reaction can also be seen: edissoc.dat and ffbonded.itp. The ffbonded.itp file is specific to the force field and can be copied from the force field directory. Edissoc.dat contains a table of bond dissociation energies by atom name and can be taken from the hexalanine_homolysis example if only standard amino acids and the HLKNL and PYD crosslinks are part of the system. The file should be separated into sections with bracketed headings.\nFor other crosslinks, the bond dissociation energy has to be provided by the user.\n\n\nKIMMDY Run Sequence: mdp files\nNow let’s look at the sequence. It mentions the reactions, which we have taken care of, and the names of different md runs. A good first Kimmdy run would include a first pulling simulation to stretch the fibril followed by a pulling simulation with distance sampling for the subsequent reaction and a final pulling simulation. For both types of pulling simulation the same mdp file can be used from the tutorial files. The pulling simulations also need torque restraints to prevent unphysiological unwinding of the fibrils. The torque restraints can be set in the mdp file and are applied to the capping groups of a tripelhelix.\nRunning the script prepare_enforced_rotation.py creates mdp and index files that only have to be appended to the current file of the respective type to use torque restraints. However, you will get an error saying that some index group is missing. Use gmx make_ndx to add these groups to your file and then run the script.\nBond distance sampling can be turned on for a md run by the tag use_plumed. You want to use this option for the MD run before checking for homolysis reactions. Another md run, in this case called relax, is mentioned under changer.coordinates.md. It is used after the homolysis reaction to interpolate between new and old parameters. An example mdp file is included in the tutorial files.\nIn a mdp file you would also define temperature coupling groups. To separate between protein and solvent, you might have to create new index groups to include the crosslinks in the protein group:\necho -ne \"r ACE & a CH3\\nr NME & a CH3\\n\\\"Protein\\\"|\\\"Other\\\"\\n\\\"Backbone\\\"| r LY2 LY3 L4Y L5Y LYX\\nq\\n\"| gmx make_ndx -f fibril_npt.gro -o index.ndx\nFinally, the KIMMDY run name and gmx_mdrun_flags can be adjusted. For large systems, writing checkpoints takes considerable time. This is why the write_checkpoint setting is on False for our tutorial run. A final KIMMDY config file could look like this:\n\n\nKIMMDY config file (kimmdy.yml)\n\n\n\nkimmdy.yml\n\n# yaml-language-server: $schema=../../src/kimmdy/kimmdy-yaml-schema.json\n\ndryrun: false\nname: 'fibril_000'\nmax_tasks: 100\nwrite_checkpoint: False\ngromacs_alias: 'gmx'\ngmx_mdrun_flags: -maxh 24 -dlb yes -ntomp 4 -ntmpi 10  -pme gpu -bonded gpu -npme 1\nff: 'amber99sb-star-ildnp.ff'\ntop: 'topol.top'\ngro: 'fibril_npt.gro'\nndx: 'index.ndx'\nplumed: 'plumed.dat'\nmds:\n  pull:\n    mdp: 'pull_fibril.mdp'\n  sample:\n    mdp: 'pull_fibril.mdp'\n    use_plumed: true\n  relax:\n    mdp: 'pull_fibril_slow_growth.mdp'\nchanger:\n  coordinates:\n    md: 'relax'\n    slow_growth: True\n  topology:\n    parameterization: 'basic' \nreactions:\n  homolysis:\n    edis: 'edissoc.dat'\n    itp: 'ffbonded.itp'\nsequence:\n  - pull\n  - sample  \n  - reactions\n  - pull\n\n\nThe run can be started by typing kimmdy in the command line. The output files are located in fibril_000"
  },
  {
    "objectID": "guide/tutorials/colbuilder.html#analysis",
    "href": "guide/tutorials/colbuilder.html#analysis",
    "title": "Run KIMMDY from Colbuilder fibril",
    "section": "Analysis",
    "text": "Analysis\nTry the options in kimmdy-analysis to visualize your kimmdy run."
  },
  {
    "objectID": "_reference/parsing.TopologyDict.html",
    "href": "_reference/parsing.TopologyDict.html",
    "title": "parsing.TopologyDict",
    "section": "",
    "text": "parsing.TopologyDict\nparsing.TopologyDict\nA raw representation of a topology file returned by read_top.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "_reference/topology.ff.html",
    "href": "_reference/topology.ff.html",
    "title": "topology.ff",
    "section": "",
    "text": "topology.ff\n\n\n\n\n\nName\nDescription\n\n\n\n\nFF\nContainer for parsed forcefield data.\n\n\n\n\n\ntopology.ff.FF(self, top, residuetypes_path=None)\nContainer for parsed forcefield data."
  },
  {
    "objectID": "_reference/topology.ff.html#classes",
    "href": "_reference/topology.ff.html#classes",
    "title": "topology.ff",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nFF\nContainer for parsed forcefield data.\n\n\n\n\n\ntopology.ff.FF(self, top, residuetypes_path=None)\nContainer for parsed forcefield data."
  },
  {
    "objectID": "_reference/index.html",
    "href": "_reference/index.html",
    "title": "References",
    "section": "",
    "text": "Options of the main KIMMDY input file\n\n\n\nArguments of all KIMMDY parts.\n\n\n\nStart KIMMDY from a python script or the command line\n\n\n\ncmd\nFunctions for starting KIMMDY either from python or the command line.\n\n\n\n\n\n\nTopology modules\n\n\n\ntopology.topology\n\n\n\ntopology.ff\n\n\n\ntopology.utils\n\n\n\ntopology.atomic\nAtomic datatypes for the topology such as Atom, Bond, Angle, Dihedral, etc.\n\n\nparsing.TopologyDict\nA raw representation of a topology file returned by read_top.\n\n\n\n\n\n\nModules\n\n\n\nanalysis\nAnalysis tools for KIMMDY runs.\n\n\ncmd\nFunctions for starting KIMMDY either from python or the command line.\n\n\nconfig\nRead and validate kimmdy.yml configuration files\n\n\nconstants\nComstants used throughout KIMMDY\n\n\ncoordinates\ncoordinate, topology and plumed modification functions\n\n\nkmc\nKinetic Monte Carlo (KMC) classes and functions.\n\n\nparsing\nAll read_&lt;…&gt; and write_&lt;…&gt; functions.\n\n\nplugins\nPlugin base classes and basic instances thereof.\n\n\nrecipe\nContains the Reaction Recipe, RecipeStep and RecipeCollection.\n\n\nrunmanager\nThe Runmanager is the main entry point of the program.\n\n\nschema\nHandle the schema for the config file.\n\n\ntasks\nThe tasks module holds the TaskFiles class which organizes input and\n\n\ntools\nStandalone tools that are complementary to KIMMDY.\n\n\nutils\nUtilities for building plugins, shell convenience functions and GROMACS related functions\n\n\n\n\n\n\nReaction plugins bundled with KIMMDY and the protocol to add a new reaction plugin to KIMMDY\n\n\n\nhomolysis.reaction.Homolysis\nHomolytic bond breaking leading to 2 radicals.\n\n\nhat_naive.reaction.NaiveHAT\nNaive HAT reaction, selects hydrogens at random\n\n\ndummyreaction.reaction.DummyReaction\nDummy reaction, returns empty RecipeCollection"
  },
  {
    "objectID": "_reference/index.html#input-file",
    "href": "_reference/index.html#input-file",
    "title": "References",
    "section": "",
    "text": "Options of the main KIMMDY input file"
  },
  {
    "objectID": "_reference/index.html#command-line-interface",
    "href": "_reference/index.html#command-line-interface",
    "title": "References",
    "section": "",
    "text": "Arguments of all KIMMDY parts."
  },
  {
    "objectID": "_reference/index.html#python-api",
    "href": "_reference/index.html#python-api",
    "title": "References",
    "section": "",
    "text": "Start KIMMDY from a python script or the command line\n\n\n\ncmd\nFunctions for starting KIMMDY either from python or the command line."
  },
  {
    "objectID": "_reference/index.html#topology",
    "href": "_reference/index.html#topology",
    "title": "References",
    "section": "",
    "text": "Topology modules\n\n\n\ntopology.topology\n\n\n\ntopology.ff\n\n\n\ntopology.utils\n\n\n\ntopology.atomic\nAtomic datatypes for the topology such as Atom, Bond, Angle, Dihedral, etc.\n\n\nparsing.TopologyDict\nA raw representation of a topology file returned by read_top."
  },
  {
    "objectID": "_reference/index.html#modules",
    "href": "_reference/index.html#modules",
    "title": "References",
    "section": "",
    "text": "Modules\n\n\n\nanalysis\nAnalysis tools for KIMMDY runs.\n\n\ncmd\nFunctions for starting KIMMDY either from python or the command line.\n\n\nconfig\nRead and validate kimmdy.yml configuration files\n\n\nconstants\nComstants used throughout KIMMDY\n\n\ncoordinates\ncoordinate, topology and plumed modification functions\n\n\nkmc\nKinetic Monte Carlo (KMC) classes and functions.\n\n\nparsing\nAll read_&lt;…&gt; and write_&lt;…&gt; functions.\n\n\nplugins\nPlugin base classes and basic instances thereof.\n\n\nrecipe\nContains the Reaction Recipe, RecipeStep and RecipeCollection.\n\n\nrunmanager\nThe Runmanager is the main entry point of the program.\n\n\nschema\nHandle the schema for the config file.\n\n\ntasks\nThe tasks module holds the TaskFiles class which organizes input and\n\n\ntools\nStandalone tools that are complementary to KIMMDY.\n\n\nutils\nUtilities for building plugins, shell convenience functions and GROMACS related functions"
  },
  {
    "objectID": "_reference/index.html#reaction-plugins",
    "href": "_reference/index.html#reaction-plugins",
    "title": "References",
    "section": "",
    "text": "Reaction plugins bundled with KIMMDY and the protocol to add a new reaction plugin to KIMMDY\n\n\n\nhomolysis.reaction.Homolysis\nHomolytic bond breaking leading to 2 radicals.\n\n\nhat_naive.reaction.NaiveHAT\nNaive HAT reaction, selects hydrogens at random\n\n\ndummyreaction.reaction.DummyReaction\nDummy reaction, returns empty RecipeCollection"
  },
  {
    "objectID": "_reference/config.html",
    "href": "_reference/config.html",
    "title": "config",
    "section": "",
    "text": "config\nRead and validate kimmdy.yml configuration files and package into a parsed format for internal use.\n\n\n\n\n\nName\nDescription\n\n\n\n\nConfig\nInternal representation of the configuration generated\n\n\n\n\n\nconfig.Config(self, input_file=None, recursive_dict=None, scheme=None, section='config', logfile=None, loglevel=None)\nInternal representation of the configuration generated from the input file, which enables validation before running and computationally expensive operations.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_file\nPath | None\nPath to the config yaml file.\nNone\n\n\nrecursive_dict\ndict | None\nFor internal use only, used in reading settings in recursively.\nNone\n\n\nscheme\ndict | None\ndict containing types and defaults for casting and validating settings.\nNone\n\n\nsection\nstr\ncurrent section e.g. to determine the level of recursion in nested configs e.g. “config”, “config.mds” or “config.reactions.homolysis”\n'config'\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nattr\nGet the value of a specific attribute.\n\n\nget_attributes\nGet a list of all attributes without hidden ones (_&lt;…&gt;).\n\n\n\n\n\nconfig.Config.attr(attribute)\nGet the value of a specific attribute. Alias for self.__getattribute__\n\n\n\nconfig.Config.get_attributes()\nGet a list of all attributes without hidden ones (_&lt;…&gt;)."
  },
  {
    "objectID": "_reference/config.html#classes",
    "href": "_reference/config.html#classes",
    "title": "config",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nConfig\nInternal representation of the configuration generated\n\n\n\n\n\nconfig.Config(self, input_file=None, recursive_dict=None, scheme=None, section='config', logfile=None, loglevel=None)\nInternal representation of the configuration generated from the input file, which enables validation before running and computationally expensive operations.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput_file\nPath | None\nPath to the config yaml file.\nNone\n\n\nrecursive_dict\ndict | None\nFor internal use only, used in reading settings in recursively.\nNone\n\n\nscheme\ndict | None\ndict containing types and defaults for casting and validating settings.\nNone\n\n\nsection\nstr\ncurrent section e.g. to determine the level of recursion in nested configs e.g. “config”, “config.mds” or “config.reactions.homolysis”\n'config'\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nattr\nGet the value of a specific attribute.\n\n\nget_attributes\nGet a list of all attributes without hidden ones (_&lt;…&gt;).\n\n\n\n\n\nconfig.Config.attr(attribute)\nGet the value of a specific attribute. Alias for self.__getattribute__\n\n\n\nconfig.Config.get_attributes()\nGet a list of all attributes without hidden ones (_&lt;…&gt;)."
  },
  {
    "objectID": "_reference/kmc.html",
    "href": "_reference/kmc.html",
    "title": "kmc",
    "section": "",
    "text": "kmc\nKinetic Monte Carlo (KMC) classes and functions.\nIn our system, the reaction rate r = (deterministic) reaction constant k = stochastic reaction constant c (from gillespie 1977) = propensity a (from Anderson 2007) because of the fundamental premise of chemical kinetics and because we have one reactant molecule\n\n\n\n\n\nName\nDescription\n\n\n\n\nKMCResult\nThe result of a KMC step. Similar to a Recipe but for the concrete realization of a reaction.\n\n\n\n\n\nkmc.KMCResult(self, recipe=lambda: Recipe([], [], [])(), reaction_probability=None, time_delta=None, time_start=None)\nThe result of a KMC step. Similar to a Recipe but for the concrete realization of a reaction.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nrecipe\nRecipe\nSingle sequence of RecipeSteps to build product\n\n\nreaction_probability\nOptional[list[float]]\nIntegral of reaction propensity with respect to time\n\n\ntime_delta\nOptional[float]\nMC time jump during which the reaction occurs [ps]\n\n\ntime_start\nOptional[float]\nTime, from which the reaction starts. The reaction changes the geometry/topology of this timestep and continues from there. [ps]\n\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nextrande\nExtrande KMC\n\n\nextrande_mod\nModified Extrande KMC\n\n\nfrm\nFirst Reaction Method variant of Kinetic Monte Carlo.\n\n\nrf_kmc\nRejection-Free Monte Carlo.\n\n\n\n\n\nkmc.extrande(recipe_collection, tau_scale, logger=logging.getLogger(__name__), rng=default_rng())\nExtrande KMC\nImplemented as in Stochastic Simulation of Biomolecular Networks in Dynamic Environments 10.1371/journal.pcbi.1004923\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnp.random.Generator\nfunction to generate random numbers in the KMC step\ndefault_rng()\n\n\ntau_scale\nfloat\nScaling factor for tau, by default 1.0\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nKMCResult\ntime delta set to 0\n\n\n\n\n\n\n\nkmc.extrande_mod(recipe_collection, tau_scale, logger=logging.getLogger(__name__), rng=default_rng())\nModified Extrande KMC\nImproved implementation of Stochastic Simulation of Biomolecular Networks in Dynamic Environments 10.1371/journal.pcbi.1004923 Changes: The considered time window is chosen to be a window containing constant rates. This prevents very small tau caused by a spike in the rate at a later point. As a side effect, the upper rate bound b and current rate a0 are the same, and the ‘extra’ side channel can not be triggered anymore.\nThis should be more efficient given a limited number of time windows containing constant rates.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnp.random.Generator\nfunction to generate random numbers in the KMC step\ndefault_rng()\n\n\ntau_scale\nfloat\nScaling factor for tau, by default 1.0\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nKMCResult\ntime delta set to 0\n\n\n\n\n\n\n\nkmc.frm(recipe_collection, logger=logging.getLogger(__name__), rng=default_rng(), MD_time=None)\nFirst Reaction Method variant of Kinetic Monte Carlo. takes RecipeCollection and choses a recipe based on which reaction would occur.\nCompare e.g. Wikipedia KMC - time dependent\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnp.random.Generator\nto generate random numbers in the KMC step\ndefault_rng()\n\n\nMD_time\nOptional[float]\ntime [ps] to compare conformational events with reaction events in the time domain\nNone\n\n\n\n\n\n\n\nkmc.rf_kmc(recipe_collection, logger=logging.getLogger(__name__), rng=default_rng())\nRejection-Free Monte Carlo. Takes RecipeCollection and choses a recipe based on the relative propensity of the events. The ‘start’ time of the reaction is the time of the highest rate of the accepted reaction.\nCompare e.g. Wikipedia KMC - rejection free\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnp.random.Generator\nfunction to generate random numbers in the KMC step\ndefault_rng()"
  },
  {
    "objectID": "_reference/kmc.html#classes",
    "href": "_reference/kmc.html#classes",
    "title": "kmc",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nKMCResult\nThe result of a KMC step. Similar to a Recipe but for the concrete realization of a reaction.\n\n\n\n\n\nkmc.KMCResult(self, recipe=lambda: Recipe([], [], [])(), reaction_probability=None, time_delta=None, time_start=None)\nThe result of a KMC step. Similar to a Recipe but for the concrete realization of a reaction.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nrecipe\nRecipe\nSingle sequence of RecipeSteps to build product\n\n\nreaction_probability\nOptional[list[float]]\nIntegral of reaction propensity with respect to time\n\n\ntime_delta\nOptional[float]\nMC time jump during which the reaction occurs [ps]\n\n\ntime_start\nOptional[float]\nTime, from which the reaction starts. The reaction changes the geometry/topology of this timestep and continues from there. [ps]"
  },
  {
    "objectID": "_reference/kmc.html#functions",
    "href": "_reference/kmc.html#functions",
    "title": "kmc",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nextrande\nExtrande KMC\n\n\nextrande_mod\nModified Extrande KMC\n\n\nfrm\nFirst Reaction Method variant of Kinetic Monte Carlo.\n\n\nrf_kmc\nRejection-Free Monte Carlo.\n\n\n\n\n\nkmc.extrande(recipe_collection, tau_scale, logger=logging.getLogger(__name__), rng=default_rng())\nExtrande KMC\nImplemented as in Stochastic Simulation of Biomolecular Networks in Dynamic Environments 10.1371/journal.pcbi.1004923\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnp.random.Generator\nfunction to generate random numbers in the KMC step\ndefault_rng()\n\n\ntau_scale\nfloat\nScaling factor for tau, by default 1.0\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nKMCResult\ntime delta set to 0\n\n\n\n\n\n\n\nkmc.extrande_mod(recipe_collection, tau_scale, logger=logging.getLogger(__name__), rng=default_rng())\nModified Extrande KMC\nImproved implementation of Stochastic Simulation of Biomolecular Networks in Dynamic Environments 10.1371/journal.pcbi.1004923 Changes: The considered time window is chosen to be a window containing constant rates. This prevents very small tau caused by a spike in the rate at a later point. As a side effect, the upper rate bound b and current rate a0 are the same, and the ‘extra’ side channel can not be triggered anymore.\nThis should be more efficient given a limited number of time windows containing constant rates.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnp.random.Generator\nfunction to generate random numbers in the KMC step\ndefault_rng()\n\n\ntau_scale\nfloat\nScaling factor for tau, by default 1.0\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nKMCResult\ntime delta set to 0\n\n\n\n\n\n\n\nkmc.frm(recipe_collection, logger=logging.getLogger(__name__), rng=default_rng(), MD_time=None)\nFirst Reaction Method variant of Kinetic Monte Carlo. takes RecipeCollection and choses a recipe based on which reaction would occur.\nCompare e.g. Wikipedia KMC - time dependent\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnp.random.Generator\nto generate random numbers in the KMC step\ndefault_rng()\n\n\nMD_time\nOptional[float]\ntime [ps] to compare conformational events with reaction events in the time domain\nNone\n\n\n\n\n\n\n\nkmc.rf_kmc(recipe_collection, logger=logging.getLogger(__name__), rng=default_rng())\nRejection-Free Monte Carlo. Takes RecipeCollection and choses a recipe based on the relative propensity of the events. The ‘start’ time of the reaction is the time of the highest rate of the accepted reaction.\nCompare e.g. Wikipedia KMC - rejection free\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_collection\nRecipeCollection\nfrom which one will be choosen\nrequired\n\n\nrng\nnp.random.Generator\nfunction to generate random numbers in the KMC step\ndefault_rng()"
  },
  {
    "objectID": "_reference/topology.topology.html",
    "href": "_reference/topology.topology.html",
    "title": "topology.topology",
    "section": "",
    "text": "topology.topology\n\n\n\n\n\nName\nDescription\n\n\n\n\nMoleculeType\nOne moleculetype in the topology\n\n\nTopology\nSmart container for parsed topology data.\n\n\n\n\n\ntopology.topology.MoleculeType(self, header, atomics, radicals=None)\nOne moleculetype in the topology\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\natoms\ndict[str, Atom]\n\n\n\nbonds\ndict[tuple[str, str], Bond]\n\n\n\npairs\ndict[tuple[str, str], Pair]\n\n\n\nangles\ndict[tuple[str, str, str], Angle]\n\n\n\nproper_dihedrals\ndict[tuple[str, str, str, str], MultipleDihedrals]\n\n\n\nimproper_dihedrals\ndict[tuple[str, str, str, str], Dihedral]\n\n\n\nposition_restraints\ndict[str, PositionRestraint]\n\n\n\ndihedral_restraints\ndict[tuple[str, str, str, str], DihedralRestraint]\n\n\n\nradicals\ndict[str, Atom]\ndict mapping atom indices to atom objects for storing all radical atoms\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfind_radicals\nFind atoms that are radicals and update self.radicals.\n\n\nreindex_atomnrs\nReindex atom numbers in topology.\n\n\n\n\n\ntopology.topology.MoleculeType.find_radicals()\nFind atoms that are radicals and update self.radicals.\nIterate over all atoms and designate them as radicals if they have fewer bounds than their natural bond order.\n\n\n\ntopology.topology.MoleculeType.reindex_atomnrs()\nReindex atom numbers in topology.\nStarts at index 1. This also updates the numbers for bonds, angles, dihedrals and pairs. Returns a dict, mapping of old atom number strings to new ones\n\n\n\n\n\ntopology.topology.Topology(self, top, parametrizer=BasicParameterizer(), is_reactive_predicate_f=is_not_solvent_or_ion, radicals=None, residuetypes_path=None)\nSmart container for parsed topology data.\nA topology keeps track of connections when bonds are broken or formed. Reparametrization is triggerd automatically if to_dict is called after bonds have changed.\nAssumptions:\n\nthe topology of interest (the Reactive moleculetype) consists of the first moleculetypes (non-solvent).\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntop\nTopologyDict\nA dictionary containing the parsed topology data, produced by kimmdy.parsing.read_top\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbind_bond\nAdd a bond in topology.\n\n\nbreak_bond\nBreak bonds in topology homolytically.\n\n\ndel_atom\nDeletes atom\n\n\nreindex_atomnrs\nReindex atom numbers in topology.\n\n\nupdate_partial_charges\nUpdate the topology atom partial charges.\n\n\nvalidate_bond\nValidates bond consistency between both atoms and top\n\n\n\n\n\ntopology.topology.Topology.bind_bond(atompair_addresses)\nAdd a bond in topology.\nModifies the topology dictionary in place. It keeps track of affected terms in the topology via a graph representation of the topology and applies the necessary changes to bonds, angles and dihedrals (proper and improper). Furthermore, it modifies to function types in the topology to account for radicals.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natompair_addresses\ntuple[TopologyAtomAddress, TopologyAtomAddress]\nAtoms to bind together.\nrequired\n\n\n\n\n\n\n\ntopology.topology.Topology.break_bond(atompair_addresses)\nBreak bonds in topology homolytically.\nRemoves bond, angles and dihedrals where atompair was involved. Modifies the topology dictionary in place. Atom pairs become radicals.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natompair_addresses\ntuple[TopologyAtomAddress, TopologyAtomAddress]\nBetween which atoms to break the bond.\nrequired\n\n\n\n\n\n\n\ntopology.topology.Topology.del_atom(atom_nr, parameterize=True)\nDeletes atom\nDeletes atom and all attached bonds. Reindexes the top and updates the parameters if requested. Also moves charges to first bound_nrs atom.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_nr\nUnion[list[str], str]\n1-based atom number as string to delete\nrequired\n\n\nparameterize\nbool\nIf true and bonds are removed triggers reparameterization, by default True\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nupdate_map\nDict, mapping of old atom number strings to new ones.\n\n\n\n\n\n\n\ntopology.topology.Topology.reindex_atomnrs()\nReindex atom numbers in topology.\nStarts at index 1. This also updates the numbers for bonds, angles, dihedrals and pairs. Returns a dict of all moleculetypes to their update maps (old -&gt; new).\n\n\n\ntopology.topology.Topology.update_partial_charges(recipe_steps)\nUpdate the topology atom partial charges.\nThis function must be called after the recipe_steps are applied. Changes are based on the recipe_steps. Update rules follow a simple assignment scheme that works well with grappa. If fragments are created, their partial charges are kept integers. If previously broken bonds are formed again, the original partial charges are restored.\n\n\n\ntopology.topology.Topology.validate_bond(atm1, atm2)\nValidates bond consistency between both atoms and top Returns True if bond exists, False if not. Raises RuntimeError if bond is not consistent."
  },
  {
    "objectID": "_reference/topology.topology.html#classes",
    "href": "_reference/topology.topology.html#classes",
    "title": "topology.topology",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nMoleculeType\nOne moleculetype in the topology\n\n\nTopology\nSmart container for parsed topology data.\n\n\n\n\n\ntopology.topology.MoleculeType(self, header, atomics, radicals=None)\nOne moleculetype in the topology\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\natoms\ndict[str, Atom]\n\n\n\nbonds\ndict[tuple[str, str], Bond]\n\n\n\npairs\ndict[tuple[str, str], Pair]\n\n\n\nangles\ndict[tuple[str, str, str], Angle]\n\n\n\nproper_dihedrals\ndict[tuple[str, str, str, str], MultipleDihedrals]\n\n\n\nimproper_dihedrals\ndict[tuple[str, str, str, str], Dihedral]\n\n\n\nposition_restraints\ndict[str, PositionRestraint]\n\n\n\ndihedral_restraints\ndict[tuple[str, str, str, str], DihedralRestraint]\n\n\n\nradicals\ndict[str, Atom]\ndict mapping atom indices to atom objects for storing all radical atoms\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfind_radicals\nFind atoms that are radicals and update self.radicals.\n\n\nreindex_atomnrs\nReindex atom numbers in topology.\n\n\n\n\n\ntopology.topology.MoleculeType.find_radicals()\nFind atoms that are radicals and update self.radicals.\nIterate over all atoms and designate them as radicals if they have fewer bounds than their natural bond order.\n\n\n\ntopology.topology.MoleculeType.reindex_atomnrs()\nReindex atom numbers in topology.\nStarts at index 1. This also updates the numbers for bonds, angles, dihedrals and pairs. Returns a dict, mapping of old atom number strings to new ones\n\n\n\n\n\ntopology.topology.Topology(self, top, parametrizer=BasicParameterizer(), is_reactive_predicate_f=is_not_solvent_or_ion, radicals=None, residuetypes_path=None)\nSmart container for parsed topology data.\nA topology keeps track of connections when bonds are broken or formed. Reparametrization is triggerd automatically if to_dict is called after bonds have changed.\nAssumptions:\n\nthe topology of interest (the Reactive moleculetype) consists of the first moleculetypes (non-solvent).\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntop\nTopologyDict\nA dictionary containing the parsed topology data, produced by kimmdy.parsing.read_top\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nbind_bond\nAdd a bond in topology.\n\n\nbreak_bond\nBreak bonds in topology homolytically.\n\n\ndel_atom\nDeletes atom\n\n\nreindex_atomnrs\nReindex atom numbers in topology.\n\n\nupdate_partial_charges\nUpdate the topology atom partial charges.\n\n\nvalidate_bond\nValidates bond consistency between both atoms and top\n\n\n\n\n\ntopology.topology.Topology.bind_bond(atompair_addresses)\nAdd a bond in topology.\nModifies the topology dictionary in place. It keeps track of affected terms in the topology via a graph representation of the topology and applies the necessary changes to bonds, angles and dihedrals (proper and improper). Furthermore, it modifies to function types in the topology to account for radicals.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natompair_addresses\ntuple[TopologyAtomAddress, TopologyAtomAddress]\nAtoms to bind together.\nrequired\n\n\n\n\n\n\n\ntopology.topology.Topology.break_bond(atompair_addresses)\nBreak bonds in topology homolytically.\nRemoves bond, angles and dihedrals where atompair was involved. Modifies the topology dictionary in place. Atom pairs become radicals.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natompair_addresses\ntuple[TopologyAtomAddress, TopologyAtomAddress]\nBetween which atoms to break the bond.\nrequired\n\n\n\n\n\n\n\ntopology.topology.Topology.del_atom(atom_nr, parameterize=True)\nDeletes atom\nDeletes atom and all attached bonds. Reindexes the top and updates the parameters if requested. Also moves charges to first bound_nrs atom.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_nr\nUnion[list[str], str]\n1-based atom number as string to delete\nrequired\n\n\nparameterize\nbool\nIf true and bonds are removed triggers reparameterization, by default True\nTrue\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nupdate_map\nDict, mapping of old atom number strings to new ones.\n\n\n\n\n\n\n\ntopology.topology.Topology.reindex_atomnrs()\nReindex atom numbers in topology.\nStarts at index 1. This also updates the numbers for bonds, angles, dihedrals and pairs. Returns a dict of all moleculetypes to their update maps (old -&gt; new).\n\n\n\ntopology.topology.Topology.update_partial_charges(recipe_steps)\nUpdate the topology atom partial charges.\nThis function must be called after the recipe_steps are applied. Changes are based on the recipe_steps. Update rules follow a simple assignment scheme that works well with grappa. If fragments are created, their partial charges are kept integers. If previously broken bonds are formed again, the original partial charges are restored.\n\n\n\ntopology.topology.Topology.validate_bond(atm1, atm2)\nValidates bond consistency between both atoms and top Returns True if bond exists, False if not. Raises RuntimeError if bond is not consistent."
  },
  {
    "objectID": "_reference/schema.html",
    "href": "_reference/schema.html",
    "title": "schema",
    "section": "",
    "text": "schema\nHandle the schema for the config file. To be used by the config module to validate the config file and set defaults for the Config object.\nReserved keywords: - pytype - default - description - type - required\n\n\n\n\n\nName\nDescription\n\n\n\n\nSequence\nA sequence of tasks.\n\n\n\n\n\nschema.Sequence(self, tasks)\nA sequence of tasks.\nTasks can be grouped together by using a dictionary with the following keys: - mult: number of times to repeat the tasks - tasks: list of tasks to repeat\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntasks\n\nlist of tasks\n\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconvert_schema_to_dict\nConvert a dictionary from a raw json schema to a nested dictionary\n\n\nflatten_scheme\nRecursively get properties and their desicripions from the scheme\n\n\ngenerate_markdown_table\nGenerate markdown table from scheme\n\n\nget_combined_scheme\nReturn the schema for the config file.\n\n\nload_kimmdy_schema\nReturn the schema for the config file\n\n\nload_plugin_schemas\nReturn the schemas for the reaction plugins known to kimmdy\n\n\nprune\nRemove empty dicts from a nested dict\n\n\n\n\n\nschema.convert_schema_to_dict(dictionary)\nConvert a dictionary from a raw json schema to a nested dictionary\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndictionary\ndict\ndictionary from a raw json schema\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nnested dictionary where each leaf entry is a dictionary with the\n“pytype”, “default” and “description” keys.\n\n\n\n\n\n\n\nschema.flatten_scheme(scheme, section='')\nRecursively get properties and their desicripions from the scheme\n\n\n\nschema.generate_markdown_table(scheme, append=False)\nGenerate markdown table from scheme\nUsed in documentation generation.\n\n\n\nschema.get_combined_scheme()\nReturn the schema for the config file.\nNested scheme where each leaf entry is a dictionary with the “pytype”, “default” and “description”. Contains the schema for the main kimmdy config file and all the plugins known at runtime.\n\n\n\nschema.load_kimmdy_schema()\nReturn the schema for the config file\n\n\n\nschema.load_plugin_schemas()\nReturn the schemas for the reaction plugins known to kimmdy\n\n\n\nschema.prune(d)\nRemove empty dicts from a nested dict"
  },
  {
    "objectID": "_reference/schema.html#classes",
    "href": "_reference/schema.html#classes",
    "title": "schema",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nSequence\nA sequence of tasks.\n\n\n\n\n\nschema.Sequence(self, tasks)\nA sequence of tasks.\nTasks can be grouped together by using a dictionary with the following keys: - mult: number of times to repeat the tasks - tasks: list of tasks to repeat\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntasks\n\nlist of tasks"
  },
  {
    "objectID": "_reference/schema.html#functions",
    "href": "_reference/schema.html#functions",
    "title": "schema",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconvert_schema_to_dict\nConvert a dictionary from a raw json schema to a nested dictionary\n\n\nflatten_scheme\nRecursively get properties and their desicripions from the scheme\n\n\ngenerate_markdown_table\nGenerate markdown table from scheme\n\n\nget_combined_scheme\nReturn the schema for the config file.\n\n\nload_kimmdy_schema\nReturn the schema for the config file\n\n\nload_plugin_schemas\nReturn the schemas for the reaction plugins known to kimmdy\n\n\nprune\nRemove empty dicts from a nested dict\n\n\n\n\n\nschema.convert_schema_to_dict(dictionary)\nConvert a dictionary from a raw json schema to a nested dictionary\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndictionary\ndict\ndictionary from a raw json schema\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nnested dictionary where each leaf entry is a dictionary with the\n“pytype”, “default” and “description” keys.\n\n\n\n\n\n\n\nschema.flatten_scheme(scheme, section='')\nRecursively get properties and their desicripions from the scheme\n\n\n\nschema.generate_markdown_table(scheme, append=False)\nGenerate markdown table from scheme\nUsed in documentation generation.\n\n\n\nschema.get_combined_scheme()\nReturn the schema for the config file.\nNested scheme where each leaf entry is a dictionary with the “pytype”, “default” and “description”. Contains the schema for the main kimmdy config file and all the plugins known at runtime.\n\n\n\nschema.load_kimmdy_schema()\nReturn the schema for the config file\n\n\n\nschema.load_plugin_schemas()\nReturn the schemas for the reaction plugins known to kimmdy\n\n\n\nschema.prune(d)\nRemove empty dicts from a nested dict"
  },
  {
    "objectID": "_reference/homolysis.reaction.Homolysis.html",
    "href": "_reference/homolysis.reaction.Homolysis.html",
    "title": "homolysis.reaction.Homolysis",
    "section": "",
    "text": "homolysis.reaction.Homolysis\nreaction.Homolysis(self, name, runmng)\nHomolytic bond breaking leading to 2 radicals. Implementation for time-varying rates\n\n\n\n\n Back to top"
  },
  {
    "objectID": "_reference/recipe.html",
    "href": "_reference/recipe.html",
    "title": "recipe",
    "section": "",
    "text": "recipe\nContains the Reaction Recipe, RecipeStep and RecipeCollection.\n\n\n\n\n\nName\nDescription\n\n\n\n\nBind\nChange topology to form a bond\n\n\nBondOperation\nHandle a bond operation on the recipe step.\n\n\nBreak\nChange topology to break a bond\n\n\nCustomTopMod\nA custom recipe step that can be used to define a custom topology modification.\n\n\nPlace\nChange topology and/or coordinates to place an atom.\n\n\nRecipe\nA reaction path defined by one series of RecipeSteps.\n\n\nRecipeCollection\nA RecipeCollection encompasses a number of reaction paths.\n\n\nRecipeStep\nBase class for all RecipeSteps.\n\n\nRelax\nStart a relaxation MD.\n\n\n\n\n\nrecipe.Bind(self, atom_ix_1=None, atom_ix_2=None, atom_id_1=None, atom_id_2=None)\nChange topology to form a bond\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_ix_1\nint\nThe index of the first atom. zero-based, by default None\nNone\n\n\natom_ix_2\nint\nThe index of the second atom. zero-based, by default None\nNone\n\n\natom_id_1\nstr\nThe ID of the first atom. one-based, by default None\nNone\n\n\natom_id_2\nstr\nThe ID of the second atom. one-based, by default None\nNone\n\n\n\n\n\n\n\nrecipe.BondOperation(self, atom_ix_1=None, atom_ix_2=None, atom_id_1=None, atom_id_2=None)\nHandle a bond operation on the recipe step.\nThis class takes in either zero-based indices or one-base IDs for two atoms.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_ix_1\nint\nThe index of the first atom. zero-based, by default None\nNone\n\n\natom_ix_2\nint\nThe index of the second atom. zero-based, by default None\nNone\n\n\natom_id_1\nstr\nThe ID of the first atom. one-based, by default None\nNone\n\n\natom_id_2\nstr\nThe ID of the second atom. one-based, by default None\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValueError\nIf neither an index nor an ID is provided for any of the atoms.\n\n\n\n\n\n\nInternally, this class stores the atom indices and converts IDs to indices as needed.\n\n\n\n\nrecipe.Break(self, atom_ix_1=None, atom_ix_2=None, atom_id_1=None, atom_id_2=None)\nChange topology to break a bond\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_ix_1\nint\nThe index of the first atom. zero-based, by default None\nNone\n\n\natom_ix_2\nint\nThe index of the second atom. zero-based, by default None\nNone\n\n\natom_id_1\nstr\nThe ID of the first atom. one-based, by default None\nNone\n\n\natom_id_2\nstr\nThe ID of the second atom. one-based, by default None\nNone\n\n\n\n\n\n\n\nrecipe.CustomTopMod(self, f)\nA custom recipe step that can be used to define a custom topology modification.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf\nCallable[[Topology], Topology]\nA function that takes a Topology object and modifies it in place.\nrequired\n\n\n\n\n\n\n\nrecipe.Place(self, new_coords, ix_to_place=None, id_to_place=None)\nChange topology and/or coordinates to place an atom.\nEither provide the index (ix_to_place) or the ID (id_to_place) of the atom to place.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew_coords\ntuple[float, float, float]\nNew xyz coordinates for atom to place to. Valid for the end point of the recipe timespan.\nrequired\n\n\nix_to_place\nint\nIndex of atom to place. 0-based.\nNone\n\n\nid_to_place\nstr\nIndex of atom to place. 1-based\nNone\n\n\n\n\n\n\n\nrecipe.Recipe(self, recipe_steps, rates, timespans)\nA reaction path defined by one series of RecipeSteps. Defines everything necessart to build the product state from the educt state.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_steps\nlist[RecipeStep]\nSingle sequence of RecipeSteps to build product\nrequired\n\n\nrates\nlist[float]\nReaction rates corresponding 1:1 to timespans.\nrequired\n\n\ntimespans\nlist[list[float, float]]\nList of half-open timespans (t1, t2] in ps, at which this rate is valid. Recipe steps which change the coordinates only need to be applicable at the first time in the interval. Must have same number of timespans as rates. t1 can equal t2 for the last frame.\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_consistency\nRun consistency checks for correct size of variables\n\n\ncombine_with\nCombines this Recipe with another with the same RecipeSteps.\n\n\n\n\n\nrecipe.Recipe.check_consistency()\nRun consistency checks for correct size of variables\n\n\n\nrecipe.Recipe.combine_with(other)\nCombines this Recipe with another with the same RecipeSteps.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nRecipe\n\nrequired\n\n\n\n\n\n\n\n\n\nrecipe.RecipeCollection(self, recipes)\nA RecipeCollection encompasses a number of reaction paths. They can originate from multiple reaction plugins, but do not need to.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nunique_recipes_ixs\nList of lists binning the old recipe indices and maps to the new recipes list.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\naggregate_reactions\nCombines reactions having the same sequence of RecipeSteps.\n\n\ncalc_cumprob\nCalculate cumulative probability of all contained recipe steps.\n\n\ncalc_ratesum\nCalculate the sum of rates over all timesteps\n\n\nfrom_csv\nCreate a RecipeCollection object from a CSV file\n\n\nplot\nPlot reaction rates over time\n\n\nto_csv\nWrite a ReactionResult as defined in the reaction module to a csv file\n\n\n\n\n\nrecipe.RecipeCollection.aggregate_reactions()\nCombines reactions having the same sequence of RecipeSteps.\n\n\n\nrecipe.RecipeCollection.calc_cumprob()\nCalculate cumulative probability of all contained recipe steps. Sums up to 1 over all recipes. Assumes constant rate for given timespan and rate zero otherwise.\n\n\n\nrecipe.RecipeCollection.calc_ratesum()\nCalculate the sum of rates over all timesteps\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nboarders\nflat list containing times of rate changes marking the boarders of the windows\n\n\nrate_windows\nflat list containing all rates in between the boarders. Each window is orderd as in recipe_windows\n\n\nrecipe_windows\nflat list containing the recipes of the corresponding window. Each window is orderd as in rate_windows\n\n\n\n\n\n\n\nrecipe.RecipeCollection.from_csv(path)\nCreate a RecipeCollection object from a CSV file Returns the recipe collection and a single recipe that was picked, otherwise None\n\n\n\nrecipe.RecipeCollection.plot(outfile, highlight_r=None, highlight_t=None)\nPlot reaction rates over time\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutfile\nPath\nWhere to save the plot, must have compatible suffix.\nrequired\n\n\nhighlight_r\nRecipe\nRecipe to highlight, by default None\nNone\n\n\nhighlight_t\nfloat\nTime at which the reactions starts\nNone\n\n\n\n\n\n\n\nrecipe.RecipeCollection.to_csv(path, picked_recipe=None)\nWrite a ReactionResult as defined in the reaction module to a csv file\n\n\n\n\n\nrecipe.RecipeStep()\nBase class for all RecipeSteps. Indices can be accessed as 0-based or 1-based. ix: 0-based, int id: 1-based, str\n\n\n\nrecipe.Relax(self)\nStart a relaxation MD.\nThe molecular system coordinates are far out of equilibrium after most topology changes. A relaxtion MD simulation using for example the slow growth method helps to reach the new equilibrium."
  },
  {
    "objectID": "_reference/recipe.html#classes",
    "href": "_reference/recipe.html#classes",
    "title": "recipe",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBind\nChange topology to form a bond\n\n\nBondOperation\nHandle a bond operation on the recipe step.\n\n\nBreak\nChange topology to break a bond\n\n\nCustomTopMod\nA custom recipe step that can be used to define a custom topology modification.\n\n\nPlace\nChange topology and/or coordinates to place an atom.\n\n\nRecipe\nA reaction path defined by one series of RecipeSteps.\n\n\nRecipeCollection\nA RecipeCollection encompasses a number of reaction paths.\n\n\nRecipeStep\nBase class for all RecipeSteps.\n\n\nRelax\nStart a relaxation MD.\n\n\n\n\n\nrecipe.Bind(self, atom_ix_1=None, atom_ix_2=None, atom_id_1=None, atom_id_2=None)\nChange topology to form a bond\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_ix_1\nint\nThe index of the first atom. zero-based, by default None\nNone\n\n\natom_ix_2\nint\nThe index of the second atom. zero-based, by default None\nNone\n\n\natom_id_1\nstr\nThe ID of the first atom. one-based, by default None\nNone\n\n\natom_id_2\nstr\nThe ID of the second atom. one-based, by default None\nNone\n\n\n\n\n\n\n\nrecipe.BondOperation(self, atom_ix_1=None, atom_ix_2=None, atom_id_1=None, atom_id_2=None)\nHandle a bond operation on the recipe step.\nThis class takes in either zero-based indices or one-base IDs for two atoms.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_ix_1\nint\nThe index of the first atom. zero-based, by default None\nNone\n\n\natom_ix_2\nint\nThe index of the second atom. zero-based, by default None\nNone\n\n\natom_id_1\nstr\nThe ID of the first atom. one-based, by default None\nNone\n\n\natom_id_2\nstr\nThe ID of the second atom. one-based, by default None\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValueError\nIf neither an index nor an ID is provided for any of the atoms.\n\n\n\n\n\n\nInternally, this class stores the atom indices and converts IDs to indices as needed.\n\n\n\n\nrecipe.Break(self, atom_ix_1=None, atom_ix_2=None, atom_id_1=None, atom_id_2=None)\nChange topology to break a bond\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natom_ix_1\nint\nThe index of the first atom. zero-based, by default None\nNone\n\n\natom_ix_2\nint\nThe index of the second atom. zero-based, by default None\nNone\n\n\natom_id_1\nstr\nThe ID of the first atom. one-based, by default None\nNone\n\n\natom_id_2\nstr\nThe ID of the second atom. one-based, by default None\nNone\n\n\n\n\n\n\n\nrecipe.CustomTopMod(self, f)\nA custom recipe step that can be used to define a custom topology modification.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf\nCallable[[Topology], Topology]\nA function that takes a Topology object and modifies it in place.\nrequired\n\n\n\n\n\n\n\nrecipe.Place(self, new_coords, ix_to_place=None, id_to_place=None)\nChange topology and/or coordinates to place an atom.\nEither provide the index (ix_to_place) or the ID (id_to_place) of the atom to place.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew_coords\ntuple[float, float, float]\nNew xyz coordinates for atom to place to. Valid for the end point of the recipe timespan.\nrequired\n\n\nix_to_place\nint\nIndex of atom to place. 0-based.\nNone\n\n\nid_to_place\nstr\nIndex of atom to place. 1-based\nNone\n\n\n\n\n\n\n\nrecipe.Recipe(self, recipe_steps, rates, timespans)\nA reaction path defined by one series of RecipeSteps. Defines everything necessart to build the product state from the educt state.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrecipe_steps\nlist[RecipeStep]\nSingle sequence of RecipeSteps to build product\nrequired\n\n\nrates\nlist[float]\nReaction rates corresponding 1:1 to timespans.\nrequired\n\n\ntimespans\nlist[list[float, float]]\nList of half-open timespans (t1, t2] in ps, at which this rate is valid. Recipe steps which change the coordinates only need to be applicable at the first time in the interval. Must have same number of timespans as rates. t1 can equal t2 for the last frame.\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_consistency\nRun consistency checks for correct size of variables\n\n\ncombine_with\nCombines this Recipe with another with the same RecipeSteps.\n\n\n\n\n\nrecipe.Recipe.check_consistency()\nRun consistency checks for correct size of variables\n\n\n\nrecipe.Recipe.combine_with(other)\nCombines this Recipe with another with the same RecipeSteps.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nRecipe\n\nrequired\n\n\n\n\n\n\n\n\n\nrecipe.RecipeCollection(self, recipes)\nA RecipeCollection encompasses a number of reaction paths. They can originate from multiple reaction plugins, but do not need to.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nunique_recipes_ixs\nList of lists binning the old recipe indices and maps to the new recipes list.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\naggregate_reactions\nCombines reactions having the same sequence of RecipeSteps.\n\n\ncalc_cumprob\nCalculate cumulative probability of all contained recipe steps.\n\n\ncalc_ratesum\nCalculate the sum of rates over all timesteps\n\n\nfrom_csv\nCreate a RecipeCollection object from a CSV file\n\n\nplot\nPlot reaction rates over time\n\n\nto_csv\nWrite a ReactionResult as defined in the reaction module to a csv file\n\n\n\n\n\nrecipe.RecipeCollection.aggregate_reactions()\nCombines reactions having the same sequence of RecipeSteps.\n\n\n\nrecipe.RecipeCollection.calc_cumprob()\nCalculate cumulative probability of all contained recipe steps. Sums up to 1 over all recipes. Assumes constant rate for given timespan and rate zero otherwise.\n\n\n\nrecipe.RecipeCollection.calc_ratesum()\nCalculate the sum of rates over all timesteps\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nboarders\nflat list containing times of rate changes marking the boarders of the windows\n\n\nrate_windows\nflat list containing all rates in between the boarders. Each window is orderd as in recipe_windows\n\n\nrecipe_windows\nflat list containing the recipes of the corresponding window. Each window is orderd as in rate_windows\n\n\n\n\n\n\n\nrecipe.RecipeCollection.from_csv(path)\nCreate a RecipeCollection object from a CSV file Returns the recipe collection and a single recipe that was picked, otherwise None\n\n\n\nrecipe.RecipeCollection.plot(outfile, highlight_r=None, highlight_t=None)\nPlot reaction rates over time\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noutfile\nPath\nWhere to save the plot, must have compatible suffix.\nrequired\n\n\nhighlight_r\nRecipe\nRecipe to highlight, by default None\nNone\n\n\nhighlight_t\nfloat\nTime at which the reactions starts\nNone\n\n\n\n\n\n\n\nrecipe.RecipeCollection.to_csv(path, picked_recipe=None)\nWrite a ReactionResult as defined in the reaction module to a csv file\n\n\n\n\n\nrecipe.RecipeStep()\nBase class for all RecipeSteps. Indices can be accessed as 0-based or 1-based. ix: 0-based, int id: 1-based, str\n\n\n\nrecipe.Relax(self)\nStart a relaxation MD.\nThe molecular system coordinates are far out of equilibrium after most topology changes. A relaxtion MD simulation using for example the slow growth method helps to reach the new equilibrium."
  },
  {
    "objectID": "_reference/analysis.html",
    "href": "_reference/analysis.html",
    "title": "analysis",
    "section": "",
    "text": "analysis\nAnalysis tools for KIMMDY runs. For command line usage, run kimmdy-analysis -h.\n\n\n\n\n\nName\nDescription\n\n\n\n\nconcat_traj\nFind and concatenate trajectories (.xtc files) from a KIMMDY run into one trajectory.\n\n\nentry_point_analysis\nAnalyse existing KIMMDY runs.\n\n\nget_analysis_cmdline_args\nParse command line arguments.\n\n\nget_analysis_dir\nGet analysis directory for a KIMMDY run.\n\n\nget_step_directories\ncreate list of subdirectories that match the steps.\n\n\nplot_energy\nPlot GROMACS energy for a KIMMDY run.\n\n\nplot_rates\nPlot rates of all possible reactions for each ‘decide_recipe’ step.\n\n\nplot_runtime\nPlot runtime of all tasks.\n\n\nradical_migration\nPlot population of radicals for a KIMMDY run.\n\n\nradical_population\nPlot population of radicals for a KIMMDY run.\n\n\nreaction_participation\nPlot which atoms participate in reactions.\n\n\n\n\n\nanalysis.concat_traj(dir, filetype, steps, open_vmd=False, output_group=None)\nFind and concatenate trajectories (.xtc files) from a KIMMDY run into one trajectory. The concatenated trajectory is centered and pbc corrected.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory to search for subdirectories\nrequired\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories\nrequired\n\n\nopen_vmd\nbool\nOpen concatenated trajectory in VMD\nFalse\n\n\noutput_group\nOptional[str]\nindex group for output. Default is “Protein” for xtc and “System” for trr.\nNone\n\n\n\n\n\n\n\nanalysis.entry_point_analysis()\nAnalyse existing KIMMDY runs.\n\n\n\nanalysis.get_analysis_cmdline_args()\nParse command line arguments.\n\n\n\n\n\nType\nDescription\n\n\n\n\nParsed command line arguments\n\n\n\n\n\n\n\n\nanalysis.get_analysis_dir(dir)\nGet analysis directory for a KIMMDY run.\nCreates the directory if it does not exist.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nPath\nDirectory of KIMMDY run\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nPath to analysis directory\n\n\n\n\n\n\n\n\nanalysis.get_step_directories(dir, steps='all')\ncreate list of subdirectories that match the steps. If steps is “all”, all subdirectories are returned.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nPath\nDirectory to search for subdirectories\nrequired\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories\n'all'\n\n\n\n\n\n\n\nanalysis.plot_energy(dir, steps, terms, open_plot=False)\nPlot GROMACS energy for a KIMMDY run.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory to search for subdirectories\nrequired\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories. Default is “all”.\nrequired\n\n\nterms\nlist[str]\nTerms from gmx energy that will be plotted. Uses ‘Potential’ by default.\nrequired\n\n\nopen_plot\nbool\nOpen plot in default system viewer.\nFalse\n\n\n\n\n\n\n\nanalysis.plot_rates(dir)\nPlot rates of all possible reactions for each ‘decide_recipe’ step.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory of KIMMDY run\nrequired\n\n\n\n\n\n\n\nanalysis.plot_runtime(dir, md_tasks, datefmt, open_plot=False)\nPlot runtime of all tasks.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory of KIMMDY run\nrequired\n\n\nmd_tasks\nlist\nNames of MD tasks to color\nrequired\n\n\ndatefmt\nstr\nDate format in the KIMMDY logfile\nrequired\n\n\nopen_plot\nbool\nOpen plot in default system viewer.\nFalse\n\n\n\n\n\n\n\nanalysis.radical_migration(dirs, type='qualitative', cutoff=1)\nPlot population of radicals for a KIMMDY run.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndirs\nlist[str]\nKIMMDY run directories to be analysed.\nrequired\n\n\ntype\nstr\nHow to analyse radical migration. Available are ‘qualitative’,‘occurence’ and ‘min_rate’“,\n'qualitative'\n\n\ncutoff\nint\nIgnore migration between two atoms if it happened less often than the specified value.\n1\n\n\n\n\n\n\n\nanalysis.radical_population(dir, population_type='frequency', steps='all', select_atoms='protein', open_plot=False, open_vmd=False)\nPlot population of radicals for a KIMMDY run.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nKIMMDY run directory to be analysed.\nrequired\n\n\npopulation_type\nstr\nHow to calculate the fractional radical occupancy. Available are ‘frequency’ and ‘time’\n'frequency'\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories. Default is “all”.\n'all'\n\n\nselect_atoms\nstr\nAtoms chosen for radical population analysis, default is protein (uses MDAnalysis selection syntax)\n'protein'\n\n\nopen_plot\nbool\nOpen plot in default system viewer.\nFalse\n\n\nopen_vmd\nbool\nOpen a pdb in VMD with the radical occupation as B-factors.\nFalse\n\n\n\n\n\n\n\nanalysis.reaction_participation(dir, open_plot=False)\nPlot which atoms participate in reactions.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory of KIMMDY run\nrequired\n\n\nopen_plot\nbool\nOpen plot in default system viewer.\nFalse"
  },
  {
    "objectID": "_reference/analysis.html#functions",
    "href": "_reference/analysis.html#functions",
    "title": "analysis",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconcat_traj\nFind and concatenate trajectories (.xtc files) from a KIMMDY run into one trajectory.\n\n\nentry_point_analysis\nAnalyse existing KIMMDY runs.\n\n\nget_analysis_cmdline_args\nParse command line arguments.\n\n\nget_analysis_dir\nGet analysis directory for a KIMMDY run.\n\n\nget_step_directories\ncreate list of subdirectories that match the steps.\n\n\nplot_energy\nPlot GROMACS energy for a KIMMDY run.\n\n\nplot_rates\nPlot rates of all possible reactions for each ‘decide_recipe’ step.\n\n\nplot_runtime\nPlot runtime of all tasks.\n\n\nradical_migration\nPlot population of radicals for a KIMMDY run.\n\n\nradical_population\nPlot population of radicals for a KIMMDY run.\n\n\nreaction_participation\nPlot which atoms participate in reactions.\n\n\n\n\n\nanalysis.concat_traj(dir, filetype, steps, open_vmd=False, output_group=None)\nFind and concatenate trajectories (.xtc files) from a KIMMDY run into one trajectory. The concatenated trajectory is centered and pbc corrected.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory to search for subdirectories\nrequired\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories\nrequired\n\n\nopen_vmd\nbool\nOpen concatenated trajectory in VMD\nFalse\n\n\noutput_group\nOptional[str]\nindex group for output. Default is “Protein” for xtc and “System” for trr.\nNone\n\n\n\n\n\n\n\nanalysis.entry_point_analysis()\nAnalyse existing KIMMDY runs.\n\n\n\nanalysis.get_analysis_cmdline_args()\nParse command line arguments.\n\n\n\n\n\nType\nDescription\n\n\n\n\nParsed command line arguments\n\n\n\n\n\n\n\n\nanalysis.get_analysis_dir(dir)\nGet analysis directory for a KIMMDY run.\nCreates the directory if it does not exist.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nPath\nDirectory of KIMMDY run\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nPath to analysis directory\n\n\n\n\n\n\n\n\nanalysis.get_step_directories(dir, steps='all')\ncreate list of subdirectories that match the steps. If steps is “all”, all subdirectories are returned.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nPath\nDirectory to search for subdirectories\nrequired\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories\n'all'\n\n\n\n\n\n\n\nanalysis.plot_energy(dir, steps, terms, open_plot=False)\nPlot GROMACS energy for a KIMMDY run.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory to search for subdirectories\nrequired\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories. Default is “all”.\nrequired\n\n\nterms\nlist[str]\nTerms from gmx energy that will be plotted. Uses ‘Potential’ by default.\nrequired\n\n\nopen_plot\nbool\nOpen plot in default system viewer.\nFalse\n\n\n\n\n\n\n\nanalysis.plot_rates(dir)\nPlot rates of all possible reactions for each ‘decide_recipe’ step.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory of KIMMDY run\nrequired\n\n\n\n\n\n\n\nanalysis.plot_runtime(dir, md_tasks, datefmt, open_plot=False)\nPlot runtime of all tasks.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory of KIMMDY run\nrequired\n\n\nmd_tasks\nlist\nNames of MD tasks to color\nrequired\n\n\ndatefmt\nstr\nDate format in the KIMMDY logfile\nrequired\n\n\nopen_plot\nbool\nOpen plot in default system viewer.\nFalse\n\n\n\n\n\n\n\nanalysis.radical_migration(dirs, type='qualitative', cutoff=1)\nPlot population of radicals for a KIMMDY run.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndirs\nlist[str]\nKIMMDY run directories to be analysed.\nrequired\n\n\ntype\nstr\nHow to analyse radical migration. Available are ‘qualitative’,‘occurence’ and ‘min_rate’“,\n'qualitative'\n\n\ncutoff\nint\nIgnore migration between two atoms if it happened less often than the specified value.\n1\n\n\n\n\n\n\n\nanalysis.radical_population(dir, population_type='frequency', steps='all', select_atoms='protein', open_plot=False, open_vmd=False)\nPlot population of radicals for a KIMMDY run.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nKIMMDY run directory to be analysed.\nrequired\n\n\npopulation_type\nstr\nHow to calculate the fractional radical occupancy. Available are ‘frequency’ and ‘time’\n'frequency'\n\n\nsteps\nUnion[list[str], str]\nList of steps e.g. [“equilibrium”, “production”]. Or a string “all” to return all subdirectories. Default is “all”.\n'all'\n\n\nselect_atoms\nstr\nAtoms chosen for radical population analysis, default is protein (uses MDAnalysis selection syntax)\n'protein'\n\n\nopen_plot\nbool\nOpen plot in default system viewer.\nFalse\n\n\nopen_vmd\nbool\nOpen a pdb in VMD with the radical occupation as B-factors.\nFalse\n\n\n\n\n\n\n\nanalysis.reaction_participation(dir, open_plot=False)\nPlot which atoms participate in reactions.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndir\nstr\nDirectory of KIMMDY run\nrequired\n\n\nopen_plot\nbool\nOpen plot in default system viewer.\nFalse"
  },
  {
    "objectID": "_reference/hat_naive.reaction.NaiveHAT.html",
    "href": "_reference/hat_naive.reaction.NaiveHAT.html",
    "title": "hat_naive.reaction.NaiveHAT",
    "section": "",
    "text": "hat_naive.reaction.NaiveHAT\nreaction.NaiveHAT(self, name, runmng)\nNaive HAT reaction, selects hydrogens at random\n\n\n\n\n Back to top"
  },
  {
    "objectID": "_reference/topology.atomic.html",
    "href": "_reference/topology.atomic.html",
    "title": "topology.atomic",
    "section": "",
    "text": "topology.atomic\nAtomic datatypes for the topology such as Atom, Bond, Angle, Dihedral, etc. The order of the fields comes from the gromacs topology file format. See gromacs manual\n\n\n\n\n\nName\nDescription\n\n\n\n\nAngle\nInformation about one angle\n\n\nAngleType\nInformation about one angletype\n\n\nAtom\nInformation about one atom\n\n\nAtomType\nInformation about one atom type\n\n\nBond\nInformation about one bond\n\n\nBondType\nInformation about one bondtype\n\n\nDihedral\nInformation about one proper or improper dihedral\n\n\nDihedralRestraint\nInformation about one dihedral restraint.\n\n\nDihedralType\nInformation about one dihedraltype\n\n\nExclusion\nInformation about one exclusion\n\n\nMultipleDihedralTypes\nMultiple DihedralTypess with the same ai, aj, ak, al\n\n\nMultipleDihedrals\nMultiple Dihedrals with the same ai, aj, ak, al\n\n\nPair\nInformation about one pair\n\n\nPositionRestraint\nInformation about one position restraint.\n\n\nResidueAtomSpec\nInformation about one atom in a residue\n\n\nResidueBondSpec\nInformation about one bond in a residue\n\n\nResidueImproperSpec\nInformation about one improper dihedral in a residue\n\n\nResidueProperSpec\nInformation about one proper dihedral in a residue\n\n\nResidueType\nInformation about one residuetype from aminoacids.rtp\n\n\nSettle\nInformation about one settles\n\n\n\n\n\ntopology.atomic.Angle(self, ai, aj, ak, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one angle\nA class containing angle information as in the angles section of the topology.\nFrom gromacs topology: ; ai aj ak funct c0 c1 c2 c3 With aj &lt; ai &lt; ak\n\n\n\ntopology.atomic.AngleType(self, i, j, k, id, id_sym, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one angletype\nA class containing angle type information as in the angletypes section of the forcefield.\nFrom gromacs version of the amber* ff: ; i j k func th0 cth\n\n\n\ntopology.atomic.Atom(self, nr, type, resnr, residue, atom, cgnr, charge, mass=None, typeB=None, chargeB=None, massB=None, bound_to_nrs=list(), is_radical=False)\nInformation about one atom\nA class containing atom information as in the atoms section of the topology. An atom keeps a list of which atoms it is bound to and its radical state.\nFrom gromacs topology: ; nr type resnr residue atom cgnr charge mass typeB chargeB massB\n\n\n\ntopology.atomic.AtomType(self, type, id_sym, at_num, mass, charge, ptype, sigma, epsilon, id)\nInformation about one atom type\nA class containing atom type information as in the atomtypes section of the forcefield.\nFrom gromacs version of the amber* ff: ; name at.num mass charge ptype sigma epsilon\n\n\n\ntopology.atomic.Bond(self, ai, aj, funct, c0=None, c1=None, c2=None, c3=None, c4=None, c5=None)\nInformation about one bond\nA class containing bond information as in the bonds section of the topology.\nFrom gromacs topology: ; ai aj funct c0 c1 c2 c3 c4 c5 With ai &lt; aj\n\n\n\ntopology.atomic.BondType(self, i, j, id, id_sym, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one bondtype\nA class containing bond information as in the bondtype section of the forcefield.\nFrom gromacs version of the amber* ff: ; i j func b0 kb Where i and j are atomtypes\n\n\n\ntopology.atomic.Dihedral(self, ai, aj, ak, al, funct, c0=None, c1=None, periodicity='', c3=None, c4=None, c5=None)\nInformation about one proper or improper dihedral\nA class containing dihedral information as in the dihedrals section of the topology. Improper dihedrals have funct 4. Proper dihedrals have funct != 4, mostly funct 9.\nNote that proper dihedrals of type 9 can be defined multiple times, for different periodicities. This is why would-be parameter c2 is called periodicity.\nFrom gromacs topology: ; ai aj ak al funct c0 c1 c2 c3 c4 c5 For proper dihedrals (funct 9): aj &lt; ak\n\n\n\ntopology.atomic.DihedralRestraint(self, ai, aj, ak, al, type, phi, dphi, fc)\nInformation about one dihedral restraint.\nA class containing information as in the dihedral_restraints section of the topology.\nFrom gromacs topology: ; ai aj ak al type phi dphi fc\n\n\n\ntopology.atomic.DihedralType(self, i, j, k, l, id, id_sym, funct, c0, c1, periodicity, c3=None, c4=None, c5=None)\nInformation about one dihedraltype\nA class containing dihedral type information as in the dihedraltypes section of the forcefield. Improper dihedrals have funct 4. Proper dihedrals have funct 9.\nNote that proper dihedrals of type 9 can be defined multiple times, for different periodicities. This is why would-be parameter c2 is called periodicity and part of the id.\nFrom gromacs version of the amber* ff: ; i j k l func phase kd pn\n\n\n\ntopology.atomic.Exclusion(self, ai, aj, ak=None, al=None)\nInformation about one exclusion\nA class containing atom information as in the exclusions section of the topology.\nFrom gromacs topology: ; ai aj ak al\n\n\n\ntopology.atomic.MultipleDihedralTypes(self, ai, aj, ak, al, funct, dihedral_types)\nMultiple DihedralTypess with the same ai, aj, ak, al but different periodicities. funct should always be “9” when the length of dihedrals is &gt; 1. The key of the dihedral_types dict is the periodicity (c2).\n\n\n\ntopology.atomic.MultipleDihedrals(self, ai, aj, ak, al, funct, dihedrals)\nMultiple Dihedrals with the same ai, aj, ak, al but different periodicities. funct should always be “9” when the length of dihedrals is &gt; 1. The key of the dihedrals dict is the periodicity (c2).\n\n\n\ntopology.atomic.Pair(self, ai, aj, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one pair\nA class containing pair information as in the pair section of the topology.\nFrom gromacs topology: ; ai aj funct c0 c1 c2 c3\n\n\n\ntopology.atomic.PositionRestraint(self, ai, funct, fc, condition=None)\nInformation about one position restraint.\nA class containing information as in the position_restraints section of the topology.\nFrom gromacs topology: ; ai funct fc(x,y,z)\n\n\n\ntopology.atomic.ResidueAtomSpec(self, name, type, charge, cgrp)\nInformation about one atom in a residue\n; name type charge chargegroup\n\n\n\ntopology.atomic.ResidueBondSpec(self, atom1, atom2, b0=None, kb=None)\nInformation about one bond in a residue\n; atom1 atom2 b0 kb\n\n\n\ntopology.atomic.ResidueImproperSpec(self, atom1, atom2, atom3, atom4, c0, c1, c2)\nInformation about one improper dihedral in a residue\n; atom1 atom2 atom3 atom4 c0(q0) c1(cp) c2(mult)\n\n\n\ntopology.atomic.ResidueProperSpec(self, atom1, atom2, atom3, atom4, c0, c1, c2)\nInformation about one proper dihedral in a residue\n; atom1 atom2 atom3 atom4 c0(q0) c1(cq) c2\n\n\n\ntopology.atomic.ResidueType(self, residue, atoms, bonds, proper_dihedrals, improper_dihedrals)\nInformation about one residuetype from aminoacids.rtp\n\n\n\ntopology.atomic.Settle(self, nr, funct, doh, dhh)\nInformation about one settles\nA class containing atom information as in the settle section of the topology.\nFrom gromacs topology: ; nr funct doh dhh"
  },
  {
    "objectID": "_reference/topology.atomic.html#classes",
    "href": "_reference/topology.atomic.html#classes",
    "title": "topology.atomic",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAngle\nInformation about one angle\n\n\nAngleType\nInformation about one angletype\n\n\nAtom\nInformation about one atom\n\n\nAtomType\nInformation about one atom type\n\n\nBond\nInformation about one bond\n\n\nBondType\nInformation about one bondtype\n\n\nDihedral\nInformation about one proper or improper dihedral\n\n\nDihedralRestraint\nInformation about one dihedral restraint.\n\n\nDihedralType\nInformation about one dihedraltype\n\n\nExclusion\nInformation about one exclusion\n\n\nMultipleDihedralTypes\nMultiple DihedralTypess with the same ai, aj, ak, al\n\n\nMultipleDihedrals\nMultiple Dihedrals with the same ai, aj, ak, al\n\n\nPair\nInformation about one pair\n\n\nPositionRestraint\nInformation about one position restraint.\n\n\nResidueAtomSpec\nInformation about one atom in a residue\n\n\nResidueBondSpec\nInformation about one bond in a residue\n\n\nResidueImproperSpec\nInformation about one improper dihedral in a residue\n\n\nResidueProperSpec\nInformation about one proper dihedral in a residue\n\n\nResidueType\nInformation about one residuetype from aminoacids.rtp\n\n\nSettle\nInformation about one settles\n\n\n\n\n\ntopology.atomic.Angle(self, ai, aj, ak, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one angle\nA class containing angle information as in the angles section of the topology.\nFrom gromacs topology: ; ai aj ak funct c0 c1 c2 c3 With aj &lt; ai &lt; ak\n\n\n\ntopology.atomic.AngleType(self, i, j, k, id, id_sym, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one angletype\nA class containing angle type information as in the angletypes section of the forcefield.\nFrom gromacs version of the amber* ff: ; i j k func th0 cth\n\n\n\ntopology.atomic.Atom(self, nr, type, resnr, residue, atom, cgnr, charge, mass=None, typeB=None, chargeB=None, massB=None, bound_to_nrs=list(), is_radical=False)\nInformation about one atom\nA class containing atom information as in the atoms section of the topology. An atom keeps a list of which atoms it is bound to and its radical state.\nFrom gromacs topology: ; nr type resnr residue atom cgnr charge mass typeB chargeB massB\n\n\n\ntopology.atomic.AtomType(self, type, id_sym, at_num, mass, charge, ptype, sigma, epsilon, id)\nInformation about one atom type\nA class containing atom type information as in the atomtypes section of the forcefield.\nFrom gromacs version of the amber* ff: ; name at.num mass charge ptype sigma epsilon\n\n\n\ntopology.atomic.Bond(self, ai, aj, funct, c0=None, c1=None, c2=None, c3=None, c4=None, c5=None)\nInformation about one bond\nA class containing bond information as in the bonds section of the topology.\nFrom gromacs topology: ; ai aj funct c0 c1 c2 c3 c4 c5 With ai &lt; aj\n\n\n\ntopology.atomic.BondType(self, i, j, id, id_sym, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one bondtype\nA class containing bond information as in the bondtype section of the forcefield.\nFrom gromacs version of the amber* ff: ; i j func b0 kb Where i and j are atomtypes\n\n\n\ntopology.atomic.Dihedral(self, ai, aj, ak, al, funct, c0=None, c1=None, periodicity='', c3=None, c4=None, c5=None)\nInformation about one proper or improper dihedral\nA class containing dihedral information as in the dihedrals section of the topology. Improper dihedrals have funct 4. Proper dihedrals have funct != 4, mostly funct 9.\nNote that proper dihedrals of type 9 can be defined multiple times, for different periodicities. This is why would-be parameter c2 is called periodicity.\nFrom gromacs topology: ; ai aj ak al funct c0 c1 c2 c3 c4 c5 For proper dihedrals (funct 9): aj &lt; ak\n\n\n\ntopology.atomic.DihedralRestraint(self, ai, aj, ak, al, type, phi, dphi, fc)\nInformation about one dihedral restraint.\nA class containing information as in the dihedral_restraints section of the topology.\nFrom gromacs topology: ; ai aj ak al type phi dphi fc\n\n\n\ntopology.atomic.DihedralType(self, i, j, k, l, id, id_sym, funct, c0, c1, periodicity, c3=None, c4=None, c5=None)\nInformation about one dihedraltype\nA class containing dihedral type information as in the dihedraltypes section of the forcefield. Improper dihedrals have funct 4. Proper dihedrals have funct 9.\nNote that proper dihedrals of type 9 can be defined multiple times, for different periodicities. This is why would-be parameter c2 is called periodicity and part of the id.\nFrom gromacs version of the amber* ff: ; i j k l func phase kd pn\n\n\n\ntopology.atomic.Exclusion(self, ai, aj, ak=None, al=None)\nInformation about one exclusion\nA class containing atom information as in the exclusions section of the topology.\nFrom gromacs topology: ; ai aj ak al\n\n\n\ntopology.atomic.MultipleDihedralTypes(self, ai, aj, ak, al, funct, dihedral_types)\nMultiple DihedralTypess with the same ai, aj, ak, al but different periodicities. funct should always be “9” when the length of dihedrals is &gt; 1. The key of the dihedral_types dict is the periodicity (c2).\n\n\n\ntopology.atomic.MultipleDihedrals(self, ai, aj, ak, al, funct, dihedrals)\nMultiple Dihedrals with the same ai, aj, ak, al but different periodicities. funct should always be “9” when the length of dihedrals is &gt; 1. The key of the dihedrals dict is the periodicity (c2).\n\n\n\ntopology.atomic.Pair(self, ai, aj, funct, c0=None, c1=None, c2=None, c3=None)\nInformation about one pair\nA class containing pair information as in the pair section of the topology.\nFrom gromacs topology: ; ai aj funct c0 c1 c2 c3\n\n\n\ntopology.atomic.PositionRestraint(self, ai, funct, fc, condition=None)\nInformation about one position restraint.\nA class containing information as in the position_restraints section of the topology.\nFrom gromacs topology: ; ai funct fc(x,y,z)\n\n\n\ntopology.atomic.ResidueAtomSpec(self, name, type, charge, cgrp)\nInformation about one atom in a residue\n; name type charge chargegroup\n\n\n\ntopology.atomic.ResidueBondSpec(self, atom1, atom2, b0=None, kb=None)\nInformation about one bond in a residue\n; atom1 atom2 b0 kb\n\n\n\ntopology.atomic.ResidueImproperSpec(self, atom1, atom2, atom3, atom4, c0, c1, c2)\nInformation about one improper dihedral in a residue\n; atom1 atom2 atom3 atom4 c0(q0) c1(cp) c2(mult)\n\n\n\ntopology.atomic.ResidueProperSpec(self, atom1, atom2, atom3, atom4, c0, c1, c2)\nInformation about one proper dihedral in a residue\n; atom1 atom2 atom3 atom4 c0(q0) c1(cq) c2\n\n\n\ntopology.atomic.ResidueType(self, residue, atoms, bonds, proper_dihedrals, improper_dihedrals)\nInformation about one residuetype from aminoacids.rtp\n\n\n\ntopology.atomic.Settle(self, nr, funct, doh, dhh)\nInformation about one settles\nA class containing atom information as in the settle section of the topology.\nFrom gromacs topology: ; nr funct doh dhh"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "KIMMDY",
    "section": "",
    "text": "Reactive MD pipeline for GROMACS using Kinetic Monte Carlo / Molecular Dynamics (KIMMDY)\n\n\nNote: KIMMDY requires GROMACS to be installed. Some reactions need a GROMACS version patched with PLUMED. The gromacs version name should then contain MODIFIED or plumed.\npip install kimmdy\nThis installation includes only the most basic functionality as no plugins and analysis tools are installed.\nTo install the builtin reaction plugins, use\npip install kimmdy[reactions]\nTo install the builtin reactions and analysis tools use\npip install kimmdy[reactions,analysis]\nHowever, this is only half the fun!\nKIMMDY has two exciting plugins in the making, which properly parameterize your molecules for radicals using GrAPPa (Graph Attentional Protein Parametrization) and predict Hydrogen Atom Transfer (HAT) rates. Full installation instructions are available here\n\n\n\nThe documentation is available here.\n\n\n\nHead over to the getting started tutorial.\n\n\n\n\n\nClone kimmdy and the default reaction and parameterization plugins and install requirements and kimmdy as editable via\ngit clone git@github.com:hits-mbm-dev/kimmdy.git\ngit clone git@github.com:hits-mbm-dev/kimmdy-reactions.git\ngit clone git@github.com:hits-mbm-dev/kimmdy-grappa.git\ncd kimmdy\npython -m venv .venv\nsource ./venv/bin/activate\npip install -r requirements.txt\nConventions:\n\ncode style: black\ndocstrings: numpy\nConventional commit messages when possible for pretty release notes.\n\n\n\n\nFor developoment, we provide a docker image containing gromacs and multiple python versions to test against.\nTo run the test locally, you must:\n\ninstall docker\ninstall act, the easiest option is with github cli via gh extension install https://github.com/nektos/gh-act\nrun tests with gh extension exec act -j test --artifact-server-path ./artifacts\nhtml coverage report is exported into artifacts"
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "KIMMDY",
    "section": "",
    "text": "Note: KIMMDY requires GROMACS to be installed. Some reactions need a GROMACS version patched with PLUMED. The gromacs version name should then contain MODIFIED or plumed.\npip install kimmdy\nThis installation includes only the most basic functionality as no plugins and analysis tools are installed.\nTo install the builtin reaction plugins, use\npip install kimmdy[reactions]\nTo install the builtin reactions and analysis tools use\npip install kimmdy[reactions,analysis]\nHowever, this is only half the fun!\nKIMMDY has two exciting plugins in the making, which properly parameterize your molecules for radicals using GrAPPa (Graph Attentional Protein Parametrization) and predict Hydrogen Atom Transfer (HAT) rates. Full installation instructions are available here"
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "KIMMDY",
    "section": "",
    "text": "The documentation is available here."
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "KIMMDY",
    "section": "",
    "text": "Head over to the getting started tutorial."
  },
  {
    "objectID": "index.html#development",
    "href": "index.html#development",
    "title": "KIMMDY",
    "section": "",
    "text": "Clone kimmdy and the default reaction and parameterization plugins and install requirements and kimmdy as editable via\ngit clone git@github.com:hits-mbm-dev/kimmdy.git\ngit clone git@github.com:hits-mbm-dev/kimmdy-reactions.git\ngit clone git@github.com:hits-mbm-dev/kimmdy-grappa.git\ncd kimmdy\npython -m venv .venv\nsource ./venv/bin/activate\npip install -r requirements.txt\nConventions:\n\ncode style: black\ndocstrings: numpy\nConventional commit messages when possible for pretty release notes.\n\n\n\n\nFor developoment, we provide a docker image containing gromacs and multiple python versions to test against.\nTo run the test locally, you must:\n\ninstall docker\ninstall act, the easiest option is with github cli via gh extension install https://github.com/nektos/gh-act\nrun tests with gh extension exec act -j test --artifact-server-path ./artifacts\nhtml coverage report is exported into artifacts"
  },
  {
    "objectID": "_reference/dummyreaction.reaction.DummyReaction.html",
    "href": "_reference/dummyreaction.reaction.DummyReaction.html",
    "title": "dummyreaction.reaction.DummyReaction",
    "section": "",
    "text": "dummyreaction.reaction.DummyReaction\nreaction.DummyReaction(self, name, runmng)\nDummy reaction, returns empty RecipeCollection\n\n\n\n\n Back to top"
  },
  {
    "objectID": "_reference/constants.html",
    "href": "_reference/constants.html",
    "title": "constants",
    "section": "",
    "text": "constants\nComstants used throughout KIMMDY\n\n\n\n\n\nName\nDescription\n\n\n\n\nATOMTYPE_BONDORDER\nTo determin if an atom is a radical.\n\n\nATOMTYPE_BONDORDER_FLAT\nTo determin if an atom is a radical."
  },
  {
    "objectID": "_reference/constants.html#attributes",
    "href": "_reference/constants.html#attributes",
    "title": "constants",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nATOMTYPE_BONDORDER\nTo determin if an atom is a radical.\n\n\nATOMTYPE_BONDORDER_FLAT\nTo determin if an atom is a radical."
  },
  {
    "objectID": "_reference/tasks.html",
    "href": "_reference/tasks.html",
    "title": "tasks",
    "section": "",
    "text": "tasks\nThe tasks module holds the TaskFiles class which organizes input and output paths and the Task class for steps in the runmanager.\n\n\n\n\n\nName\nDescription\n\n\n\n\nAutoFillDict\nDictionary that gets populated by calling get_missing.\n\n\nTask\nA task to be performed as as a step in the RunManager.\n\n\nTaskFiles\nClass for Task input and output files and directories.\n\n\n\n\n\ntasks.AutoFillDict(self, get_missing)\nDictionary that gets populated by calling get_missing.\n\n\n\ntasks.Task(self, runmng, f, kwargs=None, out=None)\nA task to be performed as as a step in the RunManager.\nA task consists of a function and its keyword arguments. Calling a taks calls the stored function. The function must return a TaskFiles object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrunmng\n\nRunmanager instance from which the task is called\nrequired\n\n\nf\nCallable[…, Optional[TaskFiles]]\nFunction that will be called when the task is called\nrequired\n\n\nkwargs\nOptional[dict[str, Any]]\nkwargs to be passed to f\nNone\n\n\nout\nOptional[str]\nIf not None, an output dir will be created with this name\nNone\n\n\n\n\n\n\n\ntasks.TaskFiles(self, get_latest, input=dict(), output=dict(), outputdir=Path(), logger=logging.getLogger('kimmdy.basetask'))\nClass for Task input and output files and directories.\nHosts the input and output file paths belonging to a task. A function or method that wants to be callable as a Task has to return a TaskFiles object. The input defaultdict is populated on the fly using get_latest of the runmanager to find newest files. Files which can not be found by get_latest must be added manually.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nget_latest\nCallable\nRunmanager.get_latest function that returns paths to the latest file of given type.\n\n\ninput\ndict[str, Path]\nInput file paths for a Task. Is populated by get_latest or manually.\n\n\noutput\ndict[str, Path]\nOutput file paths for a Task. Is populated by runmanager._discover_output_files or manually.\n\n\noutputdir\nPath\nOutput directory for a Task. Typically populated by create_task_directory called by Task.\n\n\nlogger\nlogging.Logger\nLogger for a Task. Initialized in create_task_directory.\n\n\n\n\n\n\n&gt;&gt;&gt; class run():\n&gt;&gt;&gt;     def get_latest(self, s):\n&gt;&gt;&gt;         return f\"latest {s}\"\n&gt;&gt;&gt; runmng = run()\n&gt;&gt;&gt; files = TaskFiles(runmng)\n&gt;&gt;&gt; files.input\n&gt;&gt;&gt; files.input[\"top\"]\n{'top': 'latest top'}\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncreate_task_directory\nCreates TaskFiles object, output directory, logger and symlinks ff.\n\n\n\n\n\ntasks.create_task_directory(runmng, postfix)\nCreates TaskFiles object, output directory, logger and symlinks ff.\nGets called when a Task is called (from the runmanager.tasks queue)."
  },
  {
    "objectID": "_reference/tasks.html#classes",
    "href": "_reference/tasks.html#classes",
    "title": "tasks",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nAutoFillDict\nDictionary that gets populated by calling get_missing.\n\n\nTask\nA task to be performed as as a step in the RunManager.\n\n\nTaskFiles\nClass for Task input and output files and directories.\n\n\n\n\n\ntasks.AutoFillDict(self, get_missing)\nDictionary that gets populated by calling get_missing.\n\n\n\ntasks.Task(self, runmng, f, kwargs=None, out=None)\nA task to be performed as as a step in the RunManager.\nA task consists of a function and its keyword arguments. Calling a taks calls the stored function. The function must return a TaskFiles object.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrunmng\n\nRunmanager instance from which the task is called\nrequired\n\n\nf\nCallable[…, Optional[TaskFiles]]\nFunction that will be called when the task is called\nrequired\n\n\nkwargs\nOptional[dict[str, Any]]\nkwargs to be passed to f\nNone\n\n\nout\nOptional[str]\nIf not None, an output dir will be created with this name\nNone\n\n\n\n\n\n\n\ntasks.TaskFiles(self, get_latest, input=dict(), output=dict(), outputdir=Path(), logger=logging.getLogger('kimmdy.basetask'))\nClass for Task input and output files and directories.\nHosts the input and output file paths belonging to a task. A function or method that wants to be callable as a Task has to return a TaskFiles object. The input defaultdict is populated on the fly using get_latest of the runmanager to find newest files. Files which can not be found by get_latest must be added manually.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nget_latest\nCallable\nRunmanager.get_latest function that returns paths to the latest file of given type.\n\n\ninput\ndict[str, Path]\nInput file paths for a Task. Is populated by get_latest or manually.\n\n\noutput\ndict[str, Path]\nOutput file paths for a Task. Is populated by runmanager._discover_output_files or manually.\n\n\noutputdir\nPath\nOutput directory for a Task. Typically populated by create_task_directory called by Task.\n\n\nlogger\nlogging.Logger\nLogger for a Task. Initialized in create_task_directory.\n\n\n\n\n\n\n&gt;&gt;&gt; class run():\n&gt;&gt;&gt;     def get_latest(self, s):\n&gt;&gt;&gt;         return f\"latest {s}\"\n&gt;&gt;&gt; runmng = run()\n&gt;&gt;&gt; files = TaskFiles(runmng)\n&gt;&gt;&gt; files.input\n&gt;&gt;&gt; files.input[\"top\"]\n{'top': 'latest top'}"
  },
  {
    "objectID": "_reference/tasks.html#functions",
    "href": "_reference/tasks.html#functions",
    "title": "tasks",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncreate_task_directory\nCreates TaskFiles object, output directory, logger and symlinks ff.\n\n\n\n\n\ntasks.create_task_directory(runmng, postfix)\nCreates TaskFiles object, output directory, logger and symlinks ff.\nGets called when a Task is called (from the runmanager.tasks queue)."
  },
  {
    "objectID": "_reference/plugins.html",
    "href": "_reference/plugins.html",
    "title": "plugins",
    "section": "",
    "text": "plugins\nPlugin base classes and basic instances thereof.\nAlso discovers and loads KIMMDY plugins.\n\n\n\n\n\nName\nDescription\n\n\n\n\nBasicParameterizer\nreconstruct base force field state\n\n\nReactionPlugin\nReaction base class\n\n\n\n\n\nplugins.BasicParameterizer()\nreconstruct base force field state\n\n\n\n\n\nName\nDescription\n\n\n\n\nparameterize_topology\nDo nothing,\n\n\n\n\n\nplugins.BasicParameterizer.parameterize_topology(current_topology, focus_nrs=None)\nDo nothing, all necessary actions should already have happened in bind_bond and break_bond of Topology\n\n\n\n\n\nplugins.ReactionPlugin(self, name, runmng)\nReaction base class\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName of the reaction\nrequired\n\n\nrunmng\nRunmanager\nRunManager instance\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_recipe_collection\nGet a RecipeCollection as a result of the reaction.\n\n\n\n\n\nplugins.ReactionPlugin.get_recipe_collection(files)\nGet a RecipeCollection as a result of the reaction.\nThis is run as a Task in the RunManager. How the RecipeCollection is built is up to the reaction. It has access to the current state of the system via the runmanager self.runmng and the files.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfiles\nTaskFiles\nTaskFiles instance\nrequired"
  },
  {
    "objectID": "_reference/plugins.html#classes",
    "href": "_reference/plugins.html#classes",
    "title": "plugins",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nBasicParameterizer\nreconstruct base force field state\n\n\nReactionPlugin\nReaction base class\n\n\n\n\n\nplugins.BasicParameterizer()\nreconstruct base force field state\n\n\n\n\n\nName\nDescription\n\n\n\n\nparameterize_topology\nDo nothing,\n\n\n\n\n\nplugins.BasicParameterizer.parameterize_topology(current_topology, focus_nrs=None)\nDo nothing, all necessary actions should already have happened in bind_bond and break_bond of Topology\n\n\n\n\n\nplugins.ReactionPlugin(self, name, runmng)\nReaction base class\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName of the reaction\nrequired\n\n\nrunmng\nRunmanager\nRunManager instance\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_recipe_collection\nGet a RecipeCollection as a result of the reaction.\n\n\n\n\n\nplugins.ReactionPlugin.get_recipe_collection(files)\nGet a RecipeCollection as a result of the reaction.\nThis is run as a Task in the RunManager. How the RecipeCollection is built is up to the reaction. It has access to the current state of the system via the runmanager self.runmng and the files.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfiles\nTaskFiles\nTaskFiles instance\nrequired"
  },
  {
    "objectID": "_reference/tools.html",
    "href": "_reference/tools.html",
    "title": "tools",
    "section": "",
    "text": "tools\nStandalone tools that are complementary to KIMMDY.\n\n\n\n\n\nName\nDescription\n\n\n\n\nbuild_examples\nBuild example directories for KIMMDY from integration tests.\n\n\nedgelist_to_dot_graph\nConvert a list of edges to a dot graph.\n\n\nentry_point_build_examples\nBuild examples from the command line.\n\n\nentry_point_modify_top\nModify topology file in various ways\n\n\nget_build_example_cmdline_args\nParse command line arguments.\n\n\nget_modify_top_cmdline_args\nparse cmdline args for modify_top\n\n\nmodify_top\nModify topology in various ways.\n\n\ntop_to_graph\nConvert a topology to a dot graph.\n\n\ntopology_to_edgelist\nConvert a topology to a list of edges for a dot graph.\n\n\nwrite_top_as_dot\nWrite a topology as a dot graph to a file.\n\n\n\n\n\ntools.build_examples(restore)\nBuild example directories for KIMMDY from integration tests.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrestore\nstr\nIf True, overwrite input files in existing example directories. If “hard”, also delete output files.\nrequired\n\n\n\n\n\n\n\ntools.edgelist_to_dot_graph(ls, overlap='true')\nConvert a list of edges to a dot graph.\n\n\n\ntools.entry_point_build_examples()\nBuild examples from the command line.\n\n\n\ntools.entry_point_modify_top()\nModify topology file in various ways\n\n\n\ntools.get_build_example_cmdline_args()\nParse command line arguments.\n\n\n\n\n\nType\nDescription\n\n\n\n\nNamespace\nparsed command line arguments\n\n\n\n\n\n\n\ntools.get_modify_top_cmdline_args()\nparse cmdline args for modify_top\n\n\n\ntools.modify_top(topology, out, parameterize=False, removeH=None, gro=None, residuetypes=None, radicals=None, search_amber_rad=True)\nModify topology in various ways.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntopology\nstr\nPath to GROMACS top file\nrequired\n\n\nout\nstr\nOutput topology file path, stem also used for gro. Can be relative to cwd.\nrequired\n\n\nparameterize\nbool\nParameterize topology with grappa after removing hydrogen\nFalse\n\n\nremoveH\nOptional[list[int]]\nRemove one or more hydrogens by atom nrs in the top file. One based.\nNone\n\n\ngro\nOptional[str]\nGROMACS gro input file. Updates structure when deleting H. Output named like top output.\nNone\n\n\nresiduetypes\nOptional[str]\nGROMACS style residuetypes file. Necessary for parameterization with non-amber atom types.\nNone\n\n\nradicals\nOptional[list[int]]\nRadicals in the system PRIOR to removing hydrogens with the removeH option. One based. Can be detected automatically in amber topologies.\nNone\n\n\nsearch_amber_rad\nbool\nAutomatic radical search only implemented for amber. If you do use another ff, set this to false, and provide a list of radicals manually, if necessary.\nTrue\n\n\n\n\n\n\n\ntools.top_to_graph(top, overlap='true')\nConvert a topology to a dot graph.\nCan be used in notebooks to write a dot file and render with quarto.\n\n\n\ntools.topology_to_edgelist(top)\nConvert a topology to a list of edges for a dot graph.\n\n\n\ntools.write_top_as_dot(top, path, overlap='true')\nWrite a topology as a dot graph to a file.\nCan be used in notebooks to write a dot file and render with quarto."
  },
  {
    "objectID": "_reference/tools.html#functions",
    "href": "_reference/tools.html#functions",
    "title": "tools",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbuild_examples\nBuild example directories for KIMMDY from integration tests.\n\n\nedgelist_to_dot_graph\nConvert a list of edges to a dot graph.\n\n\nentry_point_build_examples\nBuild examples from the command line.\n\n\nentry_point_modify_top\nModify topology file in various ways\n\n\nget_build_example_cmdline_args\nParse command line arguments.\n\n\nget_modify_top_cmdline_args\nparse cmdline args for modify_top\n\n\nmodify_top\nModify topology in various ways.\n\n\ntop_to_graph\nConvert a topology to a dot graph.\n\n\ntopology_to_edgelist\nConvert a topology to a list of edges for a dot graph.\n\n\nwrite_top_as_dot\nWrite a topology as a dot graph to a file.\n\n\n\n\n\ntools.build_examples(restore)\nBuild example directories for KIMMDY from integration tests.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nrestore\nstr\nIf True, overwrite input files in existing example directories. If “hard”, also delete output files.\nrequired\n\n\n\n\n\n\n\ntools.edgelist_to_dot_graph(ls, overlap='true')\nConvert a list of edges to a dot graph.\n\n\n\ntools.entry_point_build_examples()\nBuild examples from the command line.\n\n\n\ntools.entry_point_modify_top()\nModify topology file in various ways\n\n\n\ntools.get_build_example_cmdline_args()\nParse command line arguments.\n\n\n\n\n\nType\nDescription\n\n\n\n\nNamespace\nparsed command line arguments\n\n\n\n\n\n\n\ntools.get_modify_top_cmdline_args()\nparse cmdline args for modify_top\n\n\n\ntools.modify_top(topology, out, parameterize=False, removeH=None, gro=None, residuetypes=None, radicals=None, search_amber_rad=True)\nModify topology in various ways.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntopology\nstr\nPath to GROMACS top file\nrequired\n\n\nout\nstr\nOutput topology file path, stem also used for gro. Can be relative to cwd.\nrequired\n\n\nparameterize\nbool\nParameterize topology with grappa after removing hydrogen\nFalse\n\n\nremoveH\nOptional[list[int]]\nRemove one or more hydrogens by atom nrs in the top file. One based.\nNone\n\n\ngro\nOptional[str]\nGROMACS gro input file. Updates structure when deleting H. Output named like top output.\nNone\n\n\nresiduetypes\nOptional[str]\nGROMACS style residuetypes file. Necessary for parameterization with non-amber atom types.\nNone\n\n\nradicals\nOptional[list[int]]\nRadicals in the system PRIOR to removing hydrogens with the removeH option. One based. Can be detected automatically in amber topologies.\nNone\n\n\nsearch_amber_rad\nbool\nAutomatic radical search only implemented for amber. If you do use another ff, set this to false, and provide a list of radicals manually, if necessary.\nTrue\n\n\n\n\n\n\n\ntools.top_to_graph(top, overlap='true')\nConvert a topology to a dot graph.\nCan be used in notebooks to write a dot file and render with quarto.\n\n\n\ntools.topology_to_edgelist(top)\nConvert a topology to a list of edges for a dot graph.\n\n\n\ntools.write_top_as_dot(top, path, overlap='true')\nWrite a topology as a dot graph to a file.\nCan be used in notebooks to write a dot file and render with quarto."
  },
  {
    "objectID": "_reference/coordinates.html",
    "href": "_reference/coordinates.html",
    "title": "coordinates",
    "section": "",
    "text": "coordinates\ncoordinate, topology and plumed modification functions\n\n\n\n\n\nName\nDescription\n\n\n\n\nbreak_bond_plumed\nBreak bond in plumed configuration file.\n\n\nget_explicit_MultipleDihedrals\nTakes a valid dihedral key and returns explicit\n\n\nget_explicit_or_type\nTakes an Interaction and associated key, InteractionTypes, Topology\n\n\nis_parameterized\nParameterized topology entries have c0 and c1 attributes != None\n\n\nmerge_dihedrals\nMerge one to two Dihedrals or -Types into a Dihedral in free-energy syntax\n\n\nmerge_top_moleculetypes_slow_growth\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation\n\n\nmerge_top_slow_growth\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation.\n\n\nplace_atom\nPlace an atom to new coords at the last time point of the trajectory\n\n\n\n\n\ncoordinates.break_bond_plumed(files, breakpair, newplumed)\nBreak bond in plumed configuration file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfiles\nTaskFiles\n\nrequired\n\n\nbreakpair\ntuple[str, str]\n\nrequired\n\n\n\n\n\n\n\ncoordinates.get_explicit_MultipleDihedrals(dihedral_key, mol, dihedrals_in, ff, periodicity_max=6)\nTakes a valid dihedral key and returns explicit dihedral parameters for a given topology\n\n\n\ncoordinates.get_explicit_or_type(key, interaction, interaction_types, mol, periodicity='')\nTakes an Interaction and associated key, InteractionTypes, Topology and Periodicity (for dihedrals) and returns an object with the parameters of this Interaction\n\n\n\ncoordinates.is_parameterized(entry)\nParameterized topology entries have c0 and c1 attributes != None\n\n\n\ncoordinates.merge_dihedrals(dihedral_key, dihedral_a, dihedral_b, dihedral_types_a, dihedral_types_b, molA, molB, funct, periodicity)\nMerge one to two Dihedrals or -Types into a Dihedral in free-energy syntax\n\n\n\ncoordinates.merge_top_moleculetypes_slow_growth(molA, molB, ff)\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation\n\n\n\ncoordinates.merge_top_slow_growth(topA, topB)\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation.\nTODO: for now this assumes that only one moleculeype (the first, index 0) is of interest.\n\n\n\ncoordinates.place_atom(files, step, ttime=None)\nPlace an atom to new coords at the last time point of the trajectory"
  },
  {
    "objectID": "_reference/coordinates.html#functions",
    "href": "_reference/coordinates.html#functions",
    "title": "coordinates",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nbreak_bond_plumed\nBreak bond in plumed configuration file.\n\n\nget_explicit_MultipleDihedrals\nTakes a valid dihedral key and returns explicit\n\n\nget_explicit_or_type\nTakes an Interaction and associated key, InteractionTypes, Topology\n\n\nis_parameterized\nParameterized topology entries have c0 and c1 attributes != None\n\n\nmerge_dihedrals\nMerge one to two Dihedrals or -Types into a Dihedral in free-energy syntax\n\n\nmerge_top_moleculetypes_slow_growth\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation\n\n\nmerge_top_slow_growth\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation.\n\n\nplace_atom\nPlace an atom to new coords at the last time point of the trajectory\n\n\n\n\n\ncoordinates.break_bond_plumed(files, breakpair, newplumed)\nBreak bond in plumed configuration file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfiles\nTaskFiles\n\nrequired\n\n\nbreakpair\ntuple[str, str]\n\nrequired\n\n\n\n\n\n\n\ncoordinates.get_explicit_MultipleDihedrals(dihedral_key, mol, dihedrals_in, ff, periodicity_max=6)\nTakes a valid dihedral key and returns explicit dihedral parameters for a given topology\n\n\n\ncoordinates.get_explicit_or_type(key, interaction, interaction_types, mol, periodicity='')\nTakes an Interaction and associated key, InteractionTypes, Topology and Periodicity (for dihedrals) and returns an object with the parameters of this Interaction\n\n\n\ncoordinates.is_parameterized(entry)\nParameterized topology entries have c0 and c1 attributes != None\n\n\n\ncoordinates.merge_dihedrals(dihedral_key, dihedral_a, dihedral_b, dihedral_types_a, dihedral_types_b, molA, molB, funct, periodicity)\nMerge one to two Dihedrals or -Types into a Dihedral in free-energy syntax\n\n\n\ncoordinates.merge_top_moleculetypes_slow_growth(molA, molB, ff)\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation\n\n\n\ncoordinates.merge_top_slow_growth(topA, topB)\nTakes two Topologies and joins them for a smooth free-energy like parameter transition simulation.\nTODO: for now this assumes that only one moleculeype (the first, index 0) is of interest.\n\n\n\ncoordinates.place_atom(files, step, ttime=None)\nPlace an atom to new coords at the last time point of the trajectory"
  },
  {
    "objectID": "_reference/utils.html",
    "href": "_reference/utils.html",
    "title": "utils",
    "section": "",
    "text": "utils\nUtilities for building plugins, shell convenience functions and GROMACS related functions\n\n\n\n\n\nName\nDescription\n\n\n\n\nTopologyAtomAddress\nAddress to an atom in the topology.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncheck_gmx_version\nCheck for an existing gromacs installation.\n\n\nget_atominfo_from_atomnrs\nUse topology atoms section to convert from atomnr to atomtype\n\n\nget_atomnrs_from_plumedid\nConvert from plumedid to atomnr, information from the plumed file is used.\n\n\nget_bondprm_from_atomtypes\nReturns bond parameters (b0, kb) for a set of two atomtypes.\n\n\nget_edissoc_from_atomnames\nReturns dissociation energy E_dissoc for a set of two atomnames.\n\n\nget_gmx_dir\nReturns the path to the gromacs installation\n\n\nget_shell_stdout\nRun command in shell and capture stdout.\n\n\nmorse_transition_rate\nCalculates reaction rate constant for a bond breaking event.\n\n\nrun_gmx\nRun GROMACS command in shell.\n\n\nrun_shell_cmd\nRun command in shell.\n\n\ntruncate_sim_files\nTruncates latest trr, xtc, edr, and gro to the time to a previous\n\n\n\n\n\nutils.check_gmx_version(config)\nCheck for an existing gromacs installation.\nIf PLUMED is meant to be used it additionally checks for the keyword ‘MODIFIED’ or ‘plumed’ in the version name.\n\n\n\nutils.get_atominfo_from_atomnrs(atomnrs, top)\nUse topology atoms section to convert from atomnr to atomtype\n\n\n\nutils.get_atomnrs_from_plumedid(plumedid, plumed)\nConvert from plumedid to atomnr, information from the plumed file is used.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nplumedid\nstr\nIdentifier from a plumed input file (e.g d0).\nrequired\n\n\nplumed\nPlumed_dict\nParsed plumed input file\nrequired\n\n\n\n\n\n\n\nutils.get_bondprm_from_atomtypes(atomtypes, ffbonded)\nReturns bond parameters (b0, kb) for a set of two atomtypes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomtypes\nlist[str]\nTwo atomtypes as defined in the respective force field\nrequired\n\n\nffbonded\ndict\nForce field ffbonded.itp file parsed through the rtp parser\nrequired\n\n\n\n\n\n\n\nutils.get_edissoc_from_atomnames(atomnames, edissoc, residue='_')\nReturns dissociation energy E_dissoc for a set of two atomnames.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomnames\nlist[str]\nTwo atomnames as defined in the respective force field\nrequired\n\n\nedissoc\ndict\nParsed file with dissociation energies per bond between two atomtypes or elements\nrequired\n\n\nresidue\nstr\nResidue for which the atomnames are defined\n'_'\n\n\n\n\n\n\n\nutils.get_gmx_dir(gromacs_alias='gmx')\nReturns the path to the gromacs installation\n\n\n\nutils.get_shell_stdout(s)\nRun command in shell and capture stdout.\n\n\n\nutils.morse_transition_rate(r_curr, r_0, dissociation_energy, k_f, frequency_factor=0.288, temperature=300)\nCalculates reaction rate constant for a bond breaking event.\nUses the Morse potential model for this calculation. For an array of bond distances of the same bond, first calculates the forces on the bond, then the minima and maxima of the shifted Morse potential to get an energy barrier and finally a reaction rate constant using the Arrhenius equation. For intramolecular reactions, the reaction rate constant is equal to the reaction rate.\nThe calculation should be according to the derivation in the original KIMMDY paper: DOI: 10.1021/acs.jctc.9b00786\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nr_curr\nlist[float]\nBond distances for a single bond, typically from a time series.\nrequired\n\n\nr_0\nfloat\nEquilibrium bond length of the bond.\nrequired\n\n\ndissociation\n\nDissociation energy of the bond.\nrequired\n\n\nk_f\nfloat\nSpring constant of the bond.\nrequired\n\n\nfrequency_factor\nfloat\nPrefactor of the Arrhenius equation in [1/ps]. Default value from fitting averaged C_a - N data to gromacs data, see original KIMMDY paper Alternatively 1/2pi sqrt(k/m).\n0.288\n\n\ntemperature\nfloat\nTemperature for the Arrhenius equation in GROMACS units.\n300\n\n\n\n\n\n\n\nutils.run_gmx(s, cwd=None)\nRun GROMACS command in shell.\nAdds a ‘-quiet’ flag to the command and checks the return code.\n\n\n\nutils.run_shell_cmd(s, cwd=None)\nRun command in shell.\n\n\n\nutils.truncate_sim_files(files, time, keep_tail=True)\nTruncates latest trr, xtc, edr, and gro to the time to a previous point in time.\nThe files stay in place, the truncated tail is by default kept and renamed to ‘[…xtc].tail’\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nOptional[float]\nTime in ps up to which the data should be truncated.\nrequired\n\n\nfiles\nTaskFiles\nTaskFiles to get the latest files.\nrequired"
  },
  {
    "objectID": "_reference/utils.html#attributes",
    "href": "_reference/utils.html#attributes",
    "title": "utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nTopologyAtomAddress\nAddress to an atom in the topology."
  },
  {
    "objectID": "_reference/utils.html#functions",
    "href": "_reference/utils.html#functions",
    "title": "utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncheck_gmx_version\nCheck for an existing gromacs installation.\n\n\nget_atominfo_from_atomnrs\nUse topology atoms section to convert from atomnr to atomtype\n\n\nget_atomnrs_from_plumedid\nConvert from plumedid to atomnr, information from the plumed file is used.\n\n\nget_bondprm_from_atomtypes\nReturns bond parameters (b0, kb) for a set of two atomtypes.\n\n\nget_edissoc_from_atomnames\nReturns dissociation energy E_dissoc for a set of two atomnames.\n\n\nget_gmx_dir\nReturns the path to the gromacs installation\n\n\nget_shell_stdout\nRun command in shell and capture stdout.\n\n\nmorse_transition_rate\nCalculates reaction rate constant for a bond breaking event.\n\n\nrun_gmx\nRun GROMACS command in shell.\n\n\nrun_shell_cmd\nRun command in shell.\n\n\ntruncate_sim_files\nTruncates latest trr, xtc, edr, and gro to the time to a previous\n\n\n\n\n\nutils.check_gmx_version(config)\nCheck for an existing gromacs installation.\nIf PLUMED is meant to be used it additionally checks for the keyword ‘MODIFIED’ or ‘plumed’ in the version name.\n\n\n\nutils.get_atominfo_from_atomnrs(atomnrs, top)\nUse topology atoms section to convert from atomnr to atomtype\n\n\n\nutils.get_atomnrs_from_plumedid(plumedid, plumed)\nConvert from plumedid to atomnr, information from the plumed file is used.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nplumedid\nstr\nIdentifier from a plumed input file (e.g d0).\nrequired\n\n\nplumed\nPlumed_dict\nParsed plumed input file\nrequired\n\n\n\n\n\n\n\nutils.get_bondprm_from_atomtypes(atomtypes, ffbonded)\nReturns bond parameters (b0, kb) for a set of two atomtypes.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomtypes\nlist[str]\nTwo atomtypes as defined in the respective force field\nrequired\n\n\nffbonded\ndict\nForce field ffbonded.itp file parsed through the rtp parser\nrequired\n\n\n\n\n\n\n\nutils.get_edissoc_from_atomnames(atomnames, edissoc, residue='_')\nReturns dissociation energy E_dissoc for a set of two atomnames.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\natomnames\nlist[str]\nTwo atomnames as defined in the respective force field\nrequired\n\n\nedissoc\ndict\nParsed file with dissociation energies per bond between two atomtypes or elements\nrequired\n\n\nresidue\nstr\nResidue for which the atomnames are defined\n'_'\n\n\n\n\n\n\n\nutils.get_gmx_dir(gromacs_alias='gmx')\nReturns the path to the gromacs installation\n\n\n\nutils.get_shell_stdout(s)\nRun command in shell and capture stdout.\n\n\n\nutils.morse_transition_rate(r_curr, r_0, dissociation_energy, k_f, frequency_factor=0.288, temperature=300)\nCalculates reaction rate constant for a bond breaking event.\nUses the Morse potential model for this calculation. For an array of bond distances of the same bond, first calculates the forces on the bond, then the minima and maxima of the shifted Morse potential to get an energy barrier and finally a reaction rate constant using the Arrhenius equation. For intramolecular reactions, the reaction rate constant is equal to the reaction rate.\nThe calculation should be according to the derivation in the original KIMMDY paper: DOI: 10.1021/acs.jctc.9b00786\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nr_curr\nlist[float]\nBond distances for a single bond, typically from a time series.\nrequired\n\n\nr_0\nfloat\nEquilibrium bond length of the bond.\nrequired\n\n\ndissociation\n\nDissociation energy of the bond.\nrequired\n\n\nk_f\nfloat\nSpring constant of the bond.\nrequired\n\n\nfrequency_factor\nfloat\nPrefactor of the Arrhenius equation in [1/ps]. Default value from fitting averaged C_a - N data to gromacs data, see original KIMMDY paper Alternatively 1/2pi sqrt(k/m).\n0.288\n\n\ntemperature\nfloat\nTemperature for the Arrhenius equation in GROMACS units.\n300\n\n\n\n\n\n\n\nutils.run_gmx(s, cwd=None)\nRun GROMACS command in shell.\nAdds a ‘-quiet’ flag to the command and checks the return code.\n\n\n\nutils.run_shell_cmd(s, cwd=None)\nRun command in shell.\n\n\n\nutils.truncate_sim_files(files, time, keep_tail=True)\nTruncates latest trr, xtc, edr, and gro to the time to a previous point in time.\nThe files stay in place, the truncated tail is by default kept and renamed to ‘[…xtc].tail’\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nOptional[float]\nTime in ps up to which the data should be truncated.\nrequired\n\n\nfiles\nTaskFiles\nTaskFiles to get the latest files.\nrequired"
  },
  {
    "objectID": "_reference/cmd.html",
    "href": "_reference/cmd.html",
    "title": "cmd",
    "section": "",
    "text": "cmd\nFunctions for starting KIMMDY either from python or the command line. Other entry points such as kimmdy-analysis also live here.\n\n\n\n\n\nName\nDescription\n\n\n\n\nconfigure_logger\nConfigure logging.\n\n\nentry_point_kimmdy\nRun KIMMDY from the command line.\n\n\nget_cmdline_args\nParse command line arguments.\n\n\nkimmdy_run\nRun KIMMDY from python.\n\n\n\n\n\ncmd.configure_logger(config)\nConfigure logging.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconfig\nConfig\nconfiguration that contains log.level and log.file\nrequired\n\n\n\n\n\n\n\ncmd.entry_point_kimmdy()\nRun KIMMDY from the command line.\nThe configuration is gathered from the input file, which is kimmdy.yml by default. See get_cmdline_args or kimmdy --help for the descriptions of the arguments.\n\n\n\ncmd.get_cmdline_args()\nParse command line arguments.\n\n\n\n\n\nType\nDescription\n\n\n\n\nParsed command line arguments\n\n\n\n\n\n\n\n\ncmd.kimmdy_run(input=Path('kimmdy.yml'), loglevel=None, logfile=None, checkpoint='', show_plugins=False, generate_jobscript=False, debug=False, callgraph=False)\nRun KIMMDY from python.\nAlso see See get_cmdline_args or kimmdy --help for the descriptions of the arguments.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nPath\nkimmdy input yml file.\nPath('kimmdy.yml')\n\n\nloglevel\nOptional[str]\nLoglevel. One of [“INFO”, “WARNING”, “MESSAGE”, “DEBUG”]\nNone\n\n\nlogfile\nOptional[Path]\nFile path of the logfile.\nNone\n\n\ncheckpoint\nstr\nFile path of a kimmdy.cpt file to restart KIMMDY from a checkpoint. If a directory is given, the file kimmdy.cpt in that directory is used.\n''\n\n\nshow_plugins\nbool\nShow available plugins and exit.\nFalse\n\n\ngenerate_jobscript\nbool\nInstead of running KIMMDY directly, generate at jobscript.sh for slurm HPC clusters\nFalse"
  },
  {
    "objectID": "_reference/cmd.html#functions",
    "href": "_reference/cmd.html#functions",
    "title": "cmd",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconfigure_logger\nConfigure logging.\n\n\nentry_point_kimmdy\nRun KIMMDY from the command line.\n\n\nget_cmdline_args\nParse command line arguments.\n\n\nkimmdy_run\nRun KIMMDY from python.\n\n\n\n\n\ncmd.configure_logger(config)\nConfigure logging.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconfig\nConfig\nconfiguration that contains log.level and log.file\nrequired\n\n\n\n\n\n\n\ncmd.entry_point_kimmdy()\nRun KIMMDY from the command line.\nThe configuration is gathered from the input file, which is kimmdy.yml by default. See get_cmdline_args or kimmdy --help for the descriptions of the arguments.\n\n\n\ncmd.get_cmdline_args()\nParse command line arguments.\n\n\n\n\n\nType\nDescription\n\n\n\n\nParsed command line arguments\n\n\n\n\n\n\n\n\ncmd.kimmdy_run(input=Path('kimmdy.yml'), loglevel=None, logfile=None, checkpoint='', show_plugins=False, generate_jobscript=False, debug=False, callgraph=False)\nRun KIMMDY from python.\nAlso see See get_cmdline_args or kimmdy --help for the descriptions of the arguments.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nPath\nkimmdy input yml file.\nPath('kimmdy.yml')\n\n\nloglevel\nOptional[str]\nLoglevel. One of [“INFO”, “WARNING”, “MESSAGE”, “DEBUG”]\nNone\n\n\nlogfile\nOptional[Path]\nFile path of the logfile.\nNone\n\n\ncheckpoint\nstr\nFile path of a kimmdy.cpt file to restart KIMMDY from a checkpoint. If a directory is given, the file kimmdy.cpt in that directory is used.\n''\n\n\nshow_plugins\nbool\nShow available plugins and exit.\nFalse\n\n\ngenerate_jobscript\nbool\nInstead of running KIMMDY directly, generate at jobscript.sh for slurm HPC clusters\nFalse"
  },
  {
    "objectID": "_reference/parsing.html",
    "href": "_reference/parsing.html",
    "title": "parsing",
    "section": "",
    "text": "parsing\nAll read_&lt;…&gt; and write_&lt;…&gt; functions.\n\n\n\n\n\nName\nDescription\n\n\n\n\nTopologyDict\nA raw representation of a topology file returned by read_top.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nJSONEncoder\nEncoder that enables writing JSONs with numpy types.\n\n\nPlumed_dict\nDict representation of a plumed.dat file.\n\n\n\n\n\nparsing.JSONEncoder()\nEncoder that enables writing JSONs with numpy types.\n\n\n\nparsing.Plumed_dict()\nDict representation of a plumed.dat file.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nis_not_comment\nReturns whether a string is not a comment.\n\n\nread_distances_dat\nRead a distances.dat plumed output file.\n\n\nread_edissoc\nReads a edissoc file and turns it into a dict.\n\n\nread_json\nReturn JSON file content as dict.\n\n\nread_plumed\nRead a plumed.dat configuration file.\n\n\nread_top\nRead a topology file (.top,.itp,*.rtp) into a raw TopologyDict represenation.\n\n\nresolve_includes\nResolve #include statements in a (top/itp) file.\n\n\nwrite_json\nWrite dict to file according to JSON format.\n\n\nwrite_plumed\nWrite a plumed.dat configuration file.\n\n\nwrite_top\nWrite a TopologyDict to a topology file.\n\n\n\n\n\nparsing.is_not_comment(c)\nReturns whether a string is not a comment.\nUsed for topology like files that use ‘;’ for comments.\n\n\n\nparsing.read_distances_dat(distances_dat)\nRead a distances.dat plumed output file.\n\n\n\nparsing.read_edissoc(path)\nReads a edissoc file and turns it into a dict.\nThe dissociation energy is assigned per pair of atom names. Atom names are unique to a residue, and the dict is nested by residues. The set of bond atoms make up the key, the dissociation energy E_dissoc [kJ mol-1] is the value.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the file. E.g. Path(“edissoc.dat”)\nrequired\n\n\n\n\n\n\n\nparsing.read_json(path)\nReturn JSON file content as dict.\n\n\n\nparsing.read_plumed(path)\nRead a plumed.dat configuration file.\nFollows the plumed naming scheme of label, keyword, action.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the file. E.g. “plumed.dat”\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nPlumed_dict\ndict with keys: ‘distances’ and ‘prints’ Each is a dict/list of dicts containing plumed keywords\n\n\n\n\n\n\n\nparsing.read_top(path, ffdir=None, use_gmx_dir=True)\nRead a topology file (.top,.itp,*.rtp) into a raw TopologyDict represenation.\nAssumptions and limitation:\n\n#include statements will be resolved\ncomments will be removed\nall lines are stripped of leading and trailing whitespace\n#undef is not supported\na section within ifdef may be a subsection of a section that was started outside of the ifdef\n#if..#endif statements only surround a full section or subsection, not individual lines within a section and a section may either be contained within if … else or it may not be, but it can not be duplicated with one part inside and one outside.\nif .. else can’t be nested\n#include s that don’t resolve to a valid file path are silently dropped\nsections that can have subsections can also exist multiple, separate times e.g. moleculetype will appear multiple times and they should not be merged\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the topology file.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nEvery section, apart from ffdir and define,\n\n\n\ncomes with a condition that can be checked against the\n\n\n\ndefines by the helper functions to determine if the content\n\n\n\n(a list of lists) should come from content or else_content.\n\n\n\nSome sections such as moleculetype also come with subsections.\n\n\n\n\n\n\n\nraw_top =\n{'ffdir': PosixPath('/usr/share/gromacs/top/amber99.ff'),\n'define': {'_FF_AMBER': [], '_FF_AMBER99': []},\n'defaults': {'content': [['1', '2', 'yes', '0.5', '0.8333']],\n'else_content': [],\n'extra': [],\n'condition': None},\n'atomtypes': {'content': [\n['C', '6', '12.01', '0.0000', 'A', '3.39967e-01', '3.59824e-01'],\n['MNH3', '0', '0.0000', '0.0000', 'A', '0.00000e+00', '0.00000e+00']],\n'else_content': [],\n'extra': [],\n'condition': None},\n'moleculetype_Urea': {'content': [['Urea', '3']],\n'else_content': [],\n'extra': [],\n'condition': None,\n'subsections': {'atoms': {'content': [['1',\n    'C',\n    '1',\n    'URE',\n    'C',\n    '1',\n    '0.880229',\n    '12.01000'],\n    ['2', 'O', '1', 'URE', 'O', '2', '-0.613359', '16.00000'],\n    ['3', 'N', '1', 'URE', 'N1', '3', '-0.923545', '14.01000'],\n    ['4', 'H', '1', 'URE', 'H11', '4', '0.395055', '1.00800'],\n    ['5', 'H', '1', 'URE', 'H12', '5', '0.395055', '1.00800'],\n    ['6', 'N', '1', 'URE', 'N2', '6', '-0.923545', '14.01000'],\n    ['7', 'H', '1', 'URE', 'H21', '7', '0.395055', '1.00800'],\n    ['8', 'H', '1', 'URE', 'H22', '8', '0.395055', '1.00800']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'bonds': {'content': [['1', '2'],\n    ['1', '3'],\n    ['1', '6'],\n    ['3', '4'],\n    ['3', '5'],\n    ['6', '7'],\n    ['6', '8']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'dihedrals': {'content': [['2', '1', '3', '4', '9'],\n    ['2', '1', '3', '5', '9'],\n    ['2', '1', '6', '7', '9'],\n    ['2', '1', '6', '8', '9'],\n    ['3', '1', '6', '7', '9'],\n    ['3', '1', '6', '8', '9'],\n    ['6', '1', '3', '4', '9'],\n    ['6', '1', '3', '5', '9'],\n    ['3', '6', '1', '2', '4'],\n    ['1', '4', '3', '5', '4'],\n    ['1', '7', '6', '8', '4']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'position_restraints': {'content': [['1', '1', '1000', '1000', '1000'],\n    ['2', '1', '1000', '0', '1000'],\n    ['3', '1', '1000', '0', '0']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'dihedral_restraints': {'content': [['3',\n    '6',\n    '1',\n    '2',\n    '1',\n    '180',\n    '0',\n    '10'],\n    ['1', '4', '3', '5', '1', '180', '0', '10']],\n    'else_content': [],\n    'extra': [],\n    'condition': None}}},\n}\n\n\n\n\nparsing.resolve_includes(path, gmx_builtin_ffs=None)\nResolve #include statements in a (top/itp) file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nFilepath to read.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[str]\nList of lines.\n\n\nOptional[Path]\nPath to the ff directory if one of the includes used a file from it.\n\n\n\n\n\n\n\nparsing.write_json(d, path)\nWrite dict to file according to JSON format.\n\n\n\nparsing.write_plumed(d, path)\nWrite a plumed.dat configuration file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nd\nPlumed_dict\nDictionary containing ‘labeled_action’, ‘other’ and ‘prints’\nrequired\n\n\npath\nPath\nPath to the file. E.g. “plumed.dat”\nrequired\n\n\n\n\n\n\n\nparsing.write_top(top, outfile)\nWrite a TopologyDict to a topology file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntop\nTopologyDict\nRaw dictionary represenation of the topology.\nrequired\n\n\noutfile\nPath\nPath to the topology file to write to.\nrequired"
  },
  {
    "objectID": "_reference/parsing.html#attributes",
    "href": "_reference/parsing.html#attributes",
    "title": "parsing",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nTopologyDict\nA raw representation of a topology file returned by read_top."
  },
  {
    "objectID": "_reference/parsing.html#classes",
    "href": "_reference/parsing.html#classes",
    "title": "parsing",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nJSONEncoder\nEncoder that enables writing JSONs with numpy types.\n\n\nPlumed_dict\nDict representation of a plumed.dat file.\n\n\n\n\n\nparsing.JSONEncoder()\nEncoder that enables writing JSONs with numpy types.\n\n\n\nparsing.Plumed_dict()\nDict representation of a plumed.dat file."
  },
  {
    "objectID": "_reference/parsing.html#functions",
    "href": "_reference/parsing.html#functions",
    "title": "parsing",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nis_not_comment\nReturns whether a string is not a comment.\n\n\nread_distances_dat\nRead a distances.dat plumed output file.\n\n\nread_edissoc\nReads a edissoc file and turns it into a dict.\n\n\nread_json\nReturn JSON file content as dict.\n\n\nread_plumed\nRead a plumed.dat configuration file.\n\n\nread_top\nRead a topology file (.top,.itp,*.rtp) into a raw TopologyDict represenation.\n\n\nresolve_includes\nResolve #include statements in a (top/itp) file.\n\n\nwrite_json\nWrite dict to file according to JSON format.\n\n\nwrite_plumed\nWrite a plumed.dat configuration file.\n\n\nwrite_top\nWrite a TopologyDict to a topology file.\n\n\n\n\n\nparsing.is_not_comment(c)\nReturns whether a string is not a comment.\nUsed for topology like files that use ‘;’ for comments.\n\n\n\nparsing.read_distances_dat(distances_dat)\nRead a distances.dat plumed output file.\n\n\n\nparsing.read_edissoc(path)\nReads a edissoc file and turns it into a dict.\nThe dissociation energy is assigned per pair of atom names. Atom names are unique to a residue, and the dict is nested by residues. The set of bond atoms make up the key, the dissociation energy E_dissoc [kJ mol-1] is the value.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the file. E.g. Path(“edissoc.dat”)\nrequired\n\n\n\n\n\n\n\nparsing.read_json(path)\nReturn JSON file content as dict.\n\n\n\nparsing.read_plumed(path)\nRead a plumed.dat configuration file.\nFollows the plumed naming scheme of label, keyword, action.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the file. E.g. “plumed.dat”\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nPlumed_dict\ndict with keys: ‘distances’ and ‘prints’ Each is a dict/list of dicts containing plumed keywords\n\n\n\n\n\n\n\nparsing.read_top(path, ffdir=None, use_gmx_dir=True)\nRead a topology file (.top,.itp,*.rtp) into a raw TopologyDict represenation.\nAssumptions and limitation:\n\n#include statements will be resolved\ncomments will be removed\nall lines are stripped of leading and trailing whitespace\n#undef is not supported\na section within ifdef may be a subsection of a section that was started outside of the ifdef\n#if..#endif statements only surround a full section or subsection, not individual lines within a section and a section may either be contained within if … else or it may not be, but it can not be duplicated with one part inside and one outside.\nif .. else can’t be nested\n#include s that don’t resolve to a valid file path are silently dropped\nsections that can have subsections can also exist multiple, separate times e.g. moleculetype will appear multiple times and they should not be merged\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nPath to the topology file.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nEvery section, apart from ffdir and define,\n\n\n\ncomes with a condition that can be checked against the\n\n\n\ndefines by the helper functions to determine if the content\n\n\n\n(a list of lists) should come from content or else_content.\n\n\n\nSome sections such as moleculetype also come with subsections.\n\n\n\n\n\n\n\nraw_top =\n{'ffdir': PosixPath('/usr/share/gromacs/top/amber99.ff'),\n'define': {'_FF_AMBER': [], '_FF_AMBER99': []},\n'defaults': {'content': [['1', '2', 'yes', '0.5', '0.8333']],\n'else_content': [],\n'extra': [],\n'condition': None},\n'atomtypes': {'content': [\n['C', '6', '12.01', '0.0000', 'A', '3.39967e-01', '3.59824e-01'],\n['MNH3', '0', '0.0000', '0.0000', 'A', '0.00000e+00', '0.00000e+00']],\n'else_content': [],\n'extra': [],\n'condition': None},\n'moleculetype_Urea': {'content': [['Urea', '3']],\n'else_content': [],\n'extra': [],\n'condition': None,\n'subsections': {'atoms': {'content': [['1',\n    'C',\n    '1',\n    'URE',\n    'C',\n    '1',\n    '0.880229',\n    '12.01000'],\n    ['2', 'O', '1', 'URE', 'O', '2', '-0.613359', '16.00000'],\n    ['3', 'N', '1', 'URE', 'N1', '3', '-0.923545', '14.01000'],\n    ['4', 'H', '1', 'URE', 'H11', '4', '0.395055', '1.00800'],\n    ['5', 'H', '1', 'URE', 'H12', '5', '0.395055', '1.00800'],\n    ['6', 'N', '1', 'URE', 'N2', '6', '-0.923545', '14.01000'],\n    ['7', 'H', '1', 'URE', 'H21', '7', '0.395055', '1.00800'],\n    ['8', 'H', '1', 'URE', 'H22', '8', '0.395055', '1.00800']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'bonds': {'content': [['1', '2'],\n    ['1', '3'],\n    ['1', '6'],\n    ['3', '4'],\n    ['3', '5'],\n    ['6', '7'],\n    ['6', '8']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'dihedrals': {'content': [['2', '1', '3', '4', '9'],\n    ['2', '1', '3', '5', '9'],\n    ['2', '1', '6', '7', '9'],\n    ['2', '1', '6', '8', '9'],\n    ['3', '1', '6', '7', '9'],\n    ['3', '1', '6', '8', '9'],\n    ['6', '1', '3', '4', '9'],\n    ['6', '1', '3', '5', '9'],\n    ['3', '6', '1', '2', '4'],\n    ['1', '4', '3', '5', '4'],\n    ['1', '7', '6', '8', '4']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'position_restraints': {'content': [['1', '1', '1000', '1000', '1000'],\n    ['2', '1', '1000', '0', '1000'],\n    ['3', '1', '1000', '0', '0']],\n    'else_content': [],\n    'extra': [],\n    'condition': None},\n'dihedral_restraints': {'content': [['3',\n    '6',\n    '1',\n    '2',\n    '1',\n    '180',\n    '0',\n    '10'],\n    ['1', '4', '3', '5', '1', '180', '0', '10']],\n    'else_content': [],\n    'extra': [],\n    'condition': None}}},\n}\n\n\n\n\nparsing.resolve_includes(path, gmx_builtin_ffs=None)\nResolve #include statements in a (top/itp) file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npath\nPath\nFilepath to read.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[str]\nList of lines.\n\n\nOptional[Path]\nPath to the ff directory if one of the includes used a file from it.\n\n\n\n\n\n\n\nparsing.write_json(d, path)\nWrite dict to file according to JSON format.\n\n\n\nparsing.write_plumed(d, path)\nWrite a plumed.dat configuration file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nd\nPlumed_dict\nDictionary containing ‘labeled_action’, ‘other’ and ‘prints’\nrequired\n\n\npath\nPath\nPath to the file. E.g. “plumed.dat”\nrequired\n\n\n\n\n\n\n\nparsing.write_top(top, outfile)\nWrite a TopologyDict to a topology file.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntop\nTopologyDict\nRaw dictionary represenation of the topology.\nrequired\n\n\noutfile\nPath\nPath to the topology file to write to.\nrequired"
  },
  {
    "objectID": "_reference/runmanager.html",
    "href": "_reference/runmanager.html",
    "title": "runmanager",
    "section": "",
    "text": "runmanager\nThe Runmanager is the main entry point of the program.\nIt manages the queue of tasks, communicates with the rest of the program and keeps track of global state.\n\n\n\n\n\nName\nDescription\n\n\n\n\nRunManager\nThe Runmanager is the main entry point of the program.\n\n\nState\nState of the system.\n\n\n\n\n\nrunmanager.RunManager(self, config)\nThe Runmanager is the main entry point of the program.\nManages the queue of tasks, communicates with the rest of the program and keeps track of global state.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconfig\nConfig\nThe configuration object.\n\n\nfrom_checkpoint\nbool\nWhether the runmanager was initialized from a checkpoint.\n\n\ntasks\nqueue.Queue[Task]\nTasks from config.\n\n\ncrr_tasks\nqueue.Queue[Task]\nCurrent tasks.\n\n\niteration\nint\nCurrent iteration.\n\n\nstate\nState\nCurrent state of the system.\n\n\nrecipe_collection\nRecipeCollection\nCollection of recipes.\n\n\nlatest_files\ndict[str, Path]\nDictionary of latest files.\n\n\nhistfile\nPath\nPath to history file.\n\n\ncptfile\nPath\nPath to checkpoint file.\n\n\ntop\n\nTopology object.\n\n\nfilehist\nlist[dict[str, TaskFiles]]\nList of dictionaries of TaskFiles.\n\n\ntask_mapping\n\nMapping of task names to runmanager methods.\n\n\nreaction_plugins\nlist[ReactionPlugin]\nList of initialized reaction plugins used in the sequence.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_latest\nReturns path to latest file of given type.\n\n\nwrite_one_checkpoint\nJust write the first checkpoint and then exit\n\n\n\n\n\nrunmanager.RunManager.get_latest(suffix)\nReturns path to latest file of given type.\nFor .dat files (in general ambiguous extensions) use full file name. Errors if file is not found.\n\n\n\nrunmanager.RunManager.write_one_checkpoint()\nJust write the first checkpoint and then exit\nUsed to generate a starting point for jobscripts on hpc clusters that can easily self-submit after a timelimit was exceeded.\n\n\n\n\n\nrunmanager.State()\nState of the system. one of IDLE, MD, REACTION, SETUP, DONE.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_existing_files\nInitialize latest_files with every existing file defined in config\n\n\n\n\n\nrunmanager.get_existing_files(config)\nInitialize latest_files with every existing file defined in config"
  },
  {
    "objectID": "_reference/runmanager.html#classes",
    "href": "_reference/runmanager.html#classes",
    "title": "runmanager",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nRunManager\nThe Runmanager is the main entry point of the program.\n\n\nState\nState of the system.\n\n\n\n\n\nrunmanager.RunManager(self, config)\nThe Runmanager is the main entry point of the program.\nManages the queue of tasks, communicates with the rest of the program and keeps track of global state.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nconfig\nConfig\nThe configuration object.\n\n\nfrom_checkpoint\nbool\nWhether the runmanager was initialized from a checkpoint.\n\n\ntasks\nqueue.Queue[Task]\nTasks from config.\n\n\ncrr_tasks\nqueue.Queue[Task]\nCurrent tasks.\n\n\niteration\nint\nCurrent iteration.\n\n\nstate\nState\nCurrent state of the system.\n\n\nrecipe_collection\nRecipeCollection\nCollection of recipes.\n\n\nlatest_files\ndict[str, Path]\nDictionary of latest files.\n\n\nhistfile\nPath\nPath to history file.\n\n\ncptfile\nPath\nPath to checkpoint file.\n\n\ntop\n\nTopology object.\n\n\nfilehist\nlist[dict[str, TaskFiles]]\nList of dictionaries of TaskFiles.\n\n\ntask_mapping\n\nMapping of task names to runmanager methods.\n\n\nreaction_plugins\nlist[ReactionPlugin]\nList of initialized reaction plugins used in the sequence.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_latest\nReturns path to latest file of given type.\n\n\nwrite_one_checkpoint\nJust write the first checkpoint and then exit\n\n\n\n\n\nrunmanager.RunManager.get_latest(suffix)\nReturns path to latest file of given type.\nFor .dat files (in general ambiguous extensions) use full file name. Errors if file is not found.\n\n\n\nrunmanager.RunManager.write_one_checkpoint()\nJust write the first checkpoint and then exit\nUsed to generate a starting point for jobscripts on hpc clusters that can easily self-submit after a timelimit was exceeded.\n\n\n\n\n\nrunmanager.State()\nState of the system. one of IDLE, MD, REACTION, SETUP, DONE."
  },
  {
    "objectID": "_reference/runmanager.html#functions",
    "href": "_reference/runmanager.html#functions",
    "title": "runmanager",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_existing_files\nInitialize latest_files with every existing file defined in config\n\n\n\n\n\nrunmanager.get_existing_files(config)\nInitialize latest_files with every existing file defined in config"
  },
  {
    "objectID": "_reference/topology.utils.html",
    "href": "_reference/topology.utils.html",
    "title": "topology.utils",
    "section": "",
    "text": "topology.utils\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_is_reactive_predicate_f\nReturns whether a moleculetype name is configured to be recognized as reactive.\n\n\nget_moleculetype_atomics\nGet content of subsections (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\n\n\nget_moleculetype_header\nGet content of the header of a moleculetype from a topology dict.\n\n\nget_protein_section\nGet content of a section in the first moleculetype (protein) from a topology dict.\n\n\nget_reactive_section\nGet content of a section in the Reactive moleculetype from a topology dict.\n\n\nget_residue_fragments\nSplits a residue into fragments after a bond has been broken.\n\n\nget_top_section\nGet content of a section from a topology dict.\n\n\nis_not_solvent_or_ion\nReturns whether a moleculetype name is not solvent or ion.\n\n\nset_moleculetype_atomics\nSet content of the atomics (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\n\n\nset_protein_section\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\nset_reactive_section\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\nset_top_section\nSet content of a section from a topology dict.\n\n\n\n\n\ntopology.utils.get_is_reactive_predicate_f(cfg)\nReturns whether a moleculetype name is configured to be recognized as reactive.\n\n\n\ntopology.utils.get_moleculetype_atomics(top, moleculetype)\nGet content of subsections (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.get_moleculetype_header(top, moleculetype)\nGet content of the header of a moleculetype from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.get_protein_section(top, name)\nGet content of a section in the first moleculetype (protein) from a topology dict.\n\n\n\ntopology.utils.get_reactive_section(top, name)\nGet content of a section in the Reactive moleculetype from a topology dict.\n\n\n\ntopology.utils.get_residue_fragments(top, residue, start1, start2, iterations=20)\nSplits a residue into fragments after a bond has been broken.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntop\nTopology\nTopology\nrequired\n\n\nresidue\nlist[Atom]\nAll atoms of current residue. Ok, when it contains more atoms as long as those are not connected to broken bond.\nrequired\n\n\nstart1\nAtom\nFirst atom with broken bond\nrequired\n\n\nstart2\nAtom\nSecond atom with broken bond\nrequired\n\n\niterations\nint\nMax number of bonds from start atoms to be included when building fragmets, by default 20\n20\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nTwo fragments, or one fragment and empty set in case the\nresidue did not change its size.\n\n\n\n\n\n\n\ntopology.utils.get_top_section(top, name, moleculetype=None)\nGet content of a section from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.is_not_solvent_or_ion(name)\nReturns whether a moleculetype name is not solvent or ion.\n\n\n\ntopology.utils.set_moleculetype_atomics(top, name, atomics, create=False)\nSet content of the atomics (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\nIf create is True, a new section is created if it does not exist.\n\n\n\ntopology.utils.set_protein_section(top, name, value)\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\n\ntopology.utils.set_reactive_section(top, name, value)\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\n\ntopology.utils.set_top_section(top, name, value, moleculetype=None)\nSet content of a section from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result."
  },
  {
    "objectID": "_reference/topology.utils.html#functions",
    "href": "_reference/topology.utils.html#functions",
    "title": "topology.utils",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_is_reactive_predicate_f\nReturns whether a moleculetype name is configured to be recognized as reactive.\n\n\nget_moleculetype_atomics\nGet content of subsections (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\n\n\nget_moleculetype_header\nGet content of the header of a moleculetype from a topology dict.\n\n\nget_protein_section\nGet content of a section in the first moleculetype (protein) from a topology dict.\n\n\nget_reactive_section\nGet content of a section in the Reactive moleculetype from a topology dict.\n\n\nget_residue_fragments\nSplits a residue into fragments after a bond has been broken.\n\n\nget_top_section\nGet content of a section from a topology dict.\n\n\nis_not_solvent_or_ion\nReturns whether a moleculetype name is not solvent or ion.\n\n\nset_moleculetype_atomics\nSet content of the atomics (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\n\n\nset_protein_section\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\nset_reactive_section\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\nset_top_section\nSet content of a section from a topology dict.\n\n\n\n\n\ntopology.utils.get_is_reactive_predicate_f(cfg)\nReturns whether a moleculetype name is configured to be recognized as reactive.\n\n\n\ntopology.utils.get_moleculetype_atomics(top, moleculetype)\nGet content of subsections (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.get_moleculetype_header(top, moleculetype)\nGet content of the header of a moleculetype from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.get_protein_section(top, name)\nGet content of a section in the first moleculetype (protein) from a topology dict.\n\n\n\ntopology.utils.get_reactive_section(top, name)\nGet content of a section in the Reactive moleculetype from a topology dict.\n\n\n\ntopology.utils.get_residue_fragments(top, residue, start1, start2, iterations=20)\nSplits a residue into fragments after a bond has been broken.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntop\nTopology\nTopology\nrequired\n\n\nresidue\nlist[Atom]\nAll atoms of current residue. Ok, when it contains more atoms as long as those are not connected to broken bond.\nrequired\n\n\nstart1\nAtom\nFirst atom with broken bond\nrequired\n\n\nstart2\nAtom\nSecond atom with broken bond\nrequired\n\n\niterations\nint\nMax number of bonds from start atoms to be included when building fragmets, by default 20\n20\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nTwo fragments, or one fragment and empty set in case the\nresidue did not change its size.\n\n\n\n\n\n\n\ntopology.utils.get_top_section(top, name, moleculetype=None)\nGet content of a section from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\n\n\n\ntopology.utils.is_not_solvent_or_ion(name)\nReturns whether a moleculetype name is not solvent or ion.\n\n\n\ntopology.utils.set_moleculetype_atomics(top, name, atomics, create=False)\nSet content of the atomics (atoms/bonds/angles etc.) of a moleculetype from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result.\nIf create is True, a new section is created if it does not exist.\n\n\n\ntopology.utils.set_protein_section(top, name, value)\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\n\ntopology.utils.set_reactive_section(top, name, value)\nSet content of a section in the first moleculetype (protein) from a topology dict.\n\n\n\ntopology.utils.set_top_section(top, name, value, moleculetype=None)\nSet content of a section from a topology dict.\nResolves any #ifdef statements by check in the top[‘define’] dict and chooses the ‘content’ or ‘else_content’ depending on the result."
  },
  {
    "objectID": "guide/tutorials/write-plugin.html",
    "href": "guide/tutorials/write-plugin.html",
    "title": "Write a Reaction Plugin",
    "section": "",
    "text": "By creating a GitHub repository, you have version control for your plugin and can share it with others. To set it up, follow these instructions."
  },
  {
    "objectID": "guide/tutorials/write-plugin.html#creating-a-github-repository",
    "href": "guide/tutorials/write-plugin.html#creating-a-github-repository",
    "title": "Write a Reaction Plugin",
    "section": "",
    "text": "By creating a GitHub repository, you have version control for your plugin and can share it with others. To set it up, follow these instructions."
  },
  {
    "objectID": "guide/tutorials/write-plugin.html#adding-the-functionality-of-the-plugin",
    "href": "guide/tutorials/write-plugin.html#adding-the-functionality-of-the-plugin",
    "title": "Write a Reaction Plugin",
    "section": "Adding the functionality of the plugin",
    "text": "Adding the functionality of the plugin\n\nMain code\nA reaction plugin has to be a derived class from the ReactionPlugin base class. Such a class has the attributes name, runmng and config and the method get_recipe_collection, which takes a TaskFiles object as argument and returns a RecipeCollection.\nThe name is a simple string and may be useful for logging. runmng is the central RunManager of a kimmdy run and has plenty of useful attributes for your plugin, especially the system Topology, which can be accessed via self.runmg.top. config contains the reaction plugin configuration as specified in the kimmdy configuration file (typically named kimmdy.yml). A RecipeCollection contains Recipes with predefined RecipeSteps that can be used to define the modification to the system for the reaction. A Recipe also contains the rates of the specified reaction and the timespans during which the corresponding rates are valid. An example plugin can be seen below.\n\n\nPlugin main code (reaction.py)\nfrom kimmdy.recipe import (\n    Bind,\n    Recipe,\n    RecipeCollection,\n)\nfrom kimmdy.plugins import ReactionPlugin\nfrom kimmdy.tasks import TaskFiles\nfrom kimmdy.utils import (\n    get_atomnrs_from_plumedid,\n)\nfrom kimmdy.parsing import (\n    read_plumed,\n    read_distances_dat,\n)\n\n\nclass BindReaction(ReactionPlugin):\n    \"\"\"Reaction to bind two particles if they are in proximity\n    \"\"\"\n\n    def get_recipe_collection(self, files: TaskFiles):\n        logger = files.logger\n        logger.debug(\"Getting recipe for reaction: Bind\")\n\n        # get cutoff distance from config, unit is [nm]\n        cutoff = self.config.distance\n\n        # Initialization of objects from files\n        distances = read_distances_dat(files.input[\"plumed_out\"])\n        plumed = read_plumed(files.input[\"plumed\"])\n\n        recipes = []\n        # check distances file for values lower than the cutoff\n        for plumedid, dists in distances.items():\n            if plumedid == \"time\":\n                continue\n            # checks only last frame\n            if dists[-1] &lt; cutoff:\n                # get atomnrs from plumedid \n                atomnrs = get_atomnrs_from_plumedid(plumedid, plumed)\n                recipes.append(\n                    Recipe(\n                        recipe_steps=[\n                            Bind(atom_id_1=atomnrs[0], atom_id_2=atomnrs[1]),\n                        ],\n                        rates=[1],\n                        timespans=[(distances[\"time\"][0], distances[\"time\"][-1])],\n                    )\n                )\n\n        return RecipeCollection(recipes)\n\n\n\n\nConfiguration file schema\nA plugin defines which variables it needs in a schema. The schema can contain default values and types of these variables. For a Kimmdy run, reaction plugin variables are defined in the configuration file (kimmdy.yml). An example schema can be seen below.\n\n\nPlugin schema (kimmdy-yaml-schema.json)\n\n\n\nkimmdy-yaml-schema.json\n\n{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"type\": \"object\",\n  \"$id\": \"bind-config\",\n  \"description\": \"Settings for bind reactions\",\n  \"additionalProperties\": false,\n  \"properties\": {\n    \"distance\": {\n      \"description\": \"Cutoff distance for two particles to bind [nm]\",\n      \"type\": \"float\",\n      \"pytype\": \"float\"\n    },\n    \"kmc\": {\n      \"description\": \"KMC algorithm for this reaction.\",\n      \"type\": \"string\",\n      \"pytype\": \"str\",\n      \"enum\": [\"rfkmc\", \"frm\", \"extrande\"],\n      \"default\": \"rfkmc\"\n    }\n  },\n  \"required\": [\"distance\"]\n}"
  },
  {
    "objectID": "guide/tutorials/write-plugin.html#making-a-python-package",
    "href": "guide/tutorials/write-plugin.html#making-a-python-package",
    "title": "Write a Reaction Plugin",
    "section": "Making a python package",
    "text": "Making a python package\nIt is necessary to make the plugin a python package to interface with Kimmdy. For this, package setup configuration files are necessary, for example setup.py and setup.cfg. In setup.cfg dependencies can be specified, which will be installed alongside the plugin. The interface with kimmdy is specified in the [options.entry_points] section. This section needs to refer to the class we created in the plugin main code and assign it to kimmdy.reaction_plugins, i.e. kimmdy.reaction_plugins = bind = &lt;path&gt;.&lt;to&gt;.&lt;main file&gt;:&lt;ClassName&gt;. Also, the directory containing the source code (typically src) is defined in [options.packages.find]. An example for setup.py and setup.cfg can be found below.\n\n\nsetup.py\nfrom setuptools import setup\n\nsetup()\n\n\n\n\nsetup.cfg\n\n\n\nsetup.cfg\n\n[metadata]\nname = kimmdy-reactions\nversion = 0.1\nlicense = GPL-3.0 \ndescription = Reaction template for KIMMDY\nlong_description = file: README.md\nauthor = Eric Hartmann\nauthor_email = eric.Hartmann@h-its.org\nclassifiers=\n        Programming Language :: Python :: 3\n        License :: OSI Approved :: MIT License\n        Operating System :: OS Independent\n\n[options]\npackages = find:\npackage_dir =\n    =src\ninclude_package_data = True\ninstall_requires =\n    MDAnalysis\n\npython_requires = &gt;= 3.9\n\n[options.packages.find]\nwhere=src\n\n[options.entry_points]\nkimmdy.reaction_plugins =\n    bind = bind.reaction:BindReaction\n\n\nThe main code and configuration schema file should then be moved to the specified source directory in a directory that has the name of the reaction plugin, i.e. src/&lt;plugin name&gt;/.\n\n\n\n\n\n\nTip\n\n\n\nBy adding the kimmdy tag on GitHub you can make your plugin discoverable by other users. It will show up in this list"
  },
  {
    "objectID": "guide/tutorials/write-plugin.html#improving-code-quality-and-reproducibility",
    "href": "guide/tutorials/write-plugin.html#improving-code-quality-and-reproducibility",
    "title": "Write a Reaction Plugin",
    "section": "Improving code quality and reproducibility",
    "text": "Improving code quality and reproducibility\nAdding tests will help in ensuring the plugin is working as expected. An example would help users to understand what your plugin does."
  },
  {
    "objectID": "guide/tutorials/index.html",
    "href": "guide/tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "Tutorials to help you get familiar with KIMMDY.\n\n\n\n\n\n\n\n\n  \n\n\n\n\nGet Started\n\n\n\n\n\n\n\nuser\n\n\n\n\n\n\n\n\n\n\n\nJannik Buhr\n\n\n\n\n\n\n  \n\n\n\n\nRun KIMMDY from Colbuilder fibril\n\n\n\n\n\n\n\nuser\n\n\n\n\n\n\n\n\n\n\n\nEric Hartmann\n\n\n\n\n\n\n  \n\n\n\n\nWrite a Reaction Plugin\n\n\n\n\n\n\n\ndeveloper\n\n\n\n\nIn this tutorial, you will learn how to create your own reaction plugin in a GitHub repository.\n\n\n\n\n\n\nEric Hartmann\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "guide/references/cmd_ref.html",
    "href": "guide/references/cmd_ref.html",
    "title": "CLI Arguments",
    "section": "",
    "text": "The prefered method of starting a KIMMDY run is via the command line, though Python entry points are supported as well."
  },
  {
    "objectID": "guide/references/cmd_ref.html#kimmdy",
    "href": "guide/references/cmd_ref.html#kimmdy",
    "title": "CLI Arguments",
    "section": "KIMMDY",
    "text": "KIMMDY\n\n!kimmdy --help\n\nusage: kimmdy [-h] [--input INPUT] [--checkpoint CHECKPOINT]\n              [--loglevel LOGLEVEL] [--logfile LOGFILE] [--show-plugins]\n              [--generate-jobscript] [--version] [--debug] [--callgraph]\n\nWelcome to KIMMDY. `kimmdy` runs KIMMDY, further tools are available as\n`kimmdy-...` commands. These are `-analysis`, `-modify-top` and `-build-\nexamples`. Access their help with `kimmdy-... -h.`\n\noptions:\n  -h, --help            show this help message and exit\n  --input INPUT, -i INPUT\n                        Kimmdy input file. Default `kimmdy.yml`\n  --checkpoint CHECKPOINT, -c CHECKPOINT\n                        File path of a kimmdy.cpt file to restart KIMMDY from\n                        a checkpoint. If a directory is given, the file\n                        kimmdy.cpt in that directory is used.\n  --loglevel LOGLEVEL, -l LOGLEVEL\n                        logging level (CRITICAL, ERROR, WARNING, INFO, DEBUG)\n  --logfile LOGFILE, -f LOGFILE\n                        logfile\n  --show-plugins        List available plugins\n  --generate-jobscript  Instead of running KIMMDY directly, generate at\n                        jobscript.sh for slurm HPC clusters.You can then run\n                        this jobscript with sbatch jobscript.sh\n  --version             show program's version number and exit\n  --debug               on error, drop into debugger\n  --callgraph           Generate visualization of function calls. Mostly\n                        useful for debugging and documentation."
  },
  {
    "objectID": "guide/references/cmd_ref.html#analysis",
    "href": "guide/references/cmd_ref.html#analysis",
    "title": "CLI Arguments",
    "section": "Analysis",
    "text": "Analysis\n\n!kimmdy-analysis --help\n\nusage: kimmdy-analysis [-h] module ...\n\nWelcome to the KIMMDY analysis module. Use this module to analyse existing\nKIMMDY runs.\n\npositional arguments:\n  module\n    trjcat            Concatenate trajectories of a KIMMDY run\n    energy            Plot GROMACS energy for a KIMMDY run\n    radical_population\n                      Plot population of radicals for one or multiple KIMMDY\n                      run(s)\n    rates             Plot rates of all possible reactions after a MD run.\n                      Rates must have been saved!\n    runtime           Plot runtime of the tasks of a kimmdy run.\n\noptions:\n  -h, --help          show this help message and exit"
  },
  {
    "objectID": "guide/references/cmd_ref.html#remove-hydrogen",
    "href": "guide/references/cmd_ref.html#remove-hydrogen",
    "title": "CLI Arguments",
    "section": "Remove Hydrogen",
    "text": "Remove Hydrogen\nThis module builds or restores the example directory in the package.\n\n!kimmdy-modify-top --help\n\nusage: kimmdy-modify-top [-h] [-p] [-r REMOVEH [REMOVEH ...]] [-c GROFILE]\n                         [-t RESIDUETYPES] [-x RADICALS]\n                         top out\n\nWelcome to the KIMMDY modify top module\n\npositional arguments:\n  top                   GROMACS top file\n  out                   Output top file name\n\noptions:\n  -h, --help            show this help message and exit\n  -p, --parameterize    Parameterize topology with grappa. (default: False)\n  -r REMOVEH [REMOVEH ...], --removeH REMOVEH [REMOVEH ...]\n                        Remove one or more hydrogens by atom nrs in the top\n                        file. (default: None)\n  -c GROFILE, --grofile GROFILE\n                        If necessary, also apply actions on gro file to create\n                        a compatible gro/top file pair. (default: None)\n  -t RESIDUETYPES, --residuetypes RESIDUETYPES\n                        GROMACS style residuetypes file. Necessary for\n                        parameterization with non-amber atom types. (default:\n                        None)\n  -x RADICALS, --radicals RADICALS\n                        Radicals in the system PRIOR to removing hydrogens\n                        with the removeH option. (default: )"
  },
  {
    "objectID": "guide/references/cmd_ref.html#examples",
    "href": "guide/references/cmd_ref.html#examples",
    "title": "CLI Arguments",
    "section": "Examples",
    "text": "Examples\nThis module builds or restores the example directory in the package.\n\n!kimmdy-build-examples --help\n\nusage: kimmdy-build-examples [-h] [-r [RESTORE]]\n\nBuild examples for KIMMDY.\n\noptions:\n  -h, --help            show this help message and exit\n  -r [RESTORE], --restore [RESTORE]\n                        Overwrite input files in existing example directories,\n                        use keyword 'hard' to also delete output files."
  },
  {
    "objectID": "guide/how-to/install-ml-plugins.html",
    "href": "guide/how-to/install-ml-plugins.html",
    "title": "Install Machine Learning Plugins",
    "section": "",
    "text": "Warning\n\n\n\nThe following plugins are not yet publicly available. As such, this guide is only for internal use and will be updated once the plugins are ready."
  },
  {
    "objectID": "guide/how-to/install-ml-plugins.html#complete-installation-with-ml-plugins",
    "href": "guide/how-to/install-ml-plugins.html#complete-installation-with-ml-plugins",
    "title": "Install Machine Learning Plugins",
    "section": "Complete Installation with ML Plugins",
    "text": "Complete Installation with ML Plugins\nconda is required for this installation to access the tensorflow and openmm packages. Solving the dependencies of the environment can overflow memory on the original conda solver. So we change the solver to the new libmamba. We also add the conda-forge channel to access the openmm package.\nconda install -n base conda-libmamba-solver\nconda config --set solver libmamba\nconda config --append channels conda-forge\nCreate a new environment.\nconda create -n kimmdy_full python=3.10 tensorflow==2.10 openmm\nconda activate kimmdy_full\nClone all repositories and install them in editable mode for development.\ngit clone git@github.com:hits-mbm-dev/kimmdy.git\ngit clone git@github.com:hits-mbm-dev/kimmdy-reactions.git\ngit clone git@github.com:hits-mbm-dev/kimmdy-grappa.git\ngit clone git@github.com:hits-mbm-dev/HAT_reaction_plugin.git\ngit clone git@github.com:hits-mbm-dev/grappa.git\n\npushd kimmdy\n# installs kimmdy, kimmdy-reactions and kimmdy-grappa\npip install -r requirements.txt\npopd\n\npushd HAT_reaction_plugin\npip install -r requirements.txt\npopd\n\npushd grappa\npip install -e .\npopd\n\nPotential problems when running\n\nopenmm can’t find the correct libstdc++.so.6\n\nsymlink system libstdc++.so.6 to the conda libstdc++.so.6\n\n\npushd $CONDA_PREFIX/lib\nmv libstdc++.so.6 libstdc++.so.6.old\nln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6 libstdc++.so.6\npopd"
  },
  {
    "objectID": "guide/how-to/contribute.html",
    "href": "guide/how-to/contribute.html",
    "title": "Contribute",
    "section": "",
    "text": "KIMMDY uses conventional commits and semantic versioning, automated via release please.\nIf a PR adds multiple commits, we use the squash and merge option to keep the commit history clean. If a PR unavoidably contains changes the message can be edited before merging to ensure release please picks up all changes.\nThe following example message (first line is the title in the GitHub UI, the rest is the body in the window below):\nGenerates the following changelog:"
  },
  {
    "objectID": "guide/how-to/contribute.html#local-testing",
    "href": "guide/how-to/contribute.html#local-testing",
    "title": "Contribute",
    "section": "Local testing",
    "text": "Local testing\nFor developoment, we provide a docker image containing gromacs and multiple python versions to test against.\nTo run the test locally, you must:\n\ninstall docker\ninstall act, easiest option is with github cli\n\ninstall github cli (gh)\ngh extension install https://github.com/nektos/gh-act\n\nrun tests with gh extension exec act -j test --artifact-server-path ./artifacts\n\ncustomize which python versions to test in tox.ini\nhtml coverage report is exported into artifacts"
  },
  {
    "objectID": "guide/how-to/reaction_only.html",
    "href": "guide/how-to/reaction_only.html",
    "title": "Reaction only",
    "section": "",
    "text": "You might want to apply a KIMMDY reaction to an already existing simulation. Here are some important points for doing so."
  },
  {
    "objectID": "guide/how-to/reaction_only.html#kimmdy-yaml",
    "href": "guide/how-to/reaction_only.html#kimmdy-yaml",
    "title": "Reaction only",
    "section": "KIMMDY yaml",
    "text": "KIMMDY yaml\nIf you want to start your sequence of tasks with a reaction, you have to give KIMMDY a trajectory. This, you do with the trr key in the kimmdy.yml file."
  },
  {
    "objectID": "guide/how-to/reaction_only.html#pre-averaged-plumed-input",
    "href": "guide/how-to/reaction_only.html#pre-averaged-plumed-input",
    "title": "Reaction only",
    "section": "Pre-averaged plumed input",
    "text": "Pre-averaged plumed input\nSometimes it is handy to pre-compute the averages of the distances plumed recordes. Usually, the plumed output (distances.dat) contains one line per timestep, each line starting with the time.\nIf you calculate the averages yourself, you end up having only one line, but need to tell KIMMDY how long the timeframe was, which was averaged. To do this, make sure to write the duration of your averaged simulation in the time field like this for a 10ps simulation:\n#! FIELDS time d0 d1 d2 d3 d4\n10.000000 0.142401 0.151588 0.143725 0.156734 0.152581\nYou still need the plumed config file, even if KIMMDY does not execute plumed in the current example, as KIMMDY reads the filename of the plumed output from the plumed config."
  },
  {
    "objectID": "guide/explanation/topology.html",
    "href": "guide/explanation/topology.html",
    "title": "Visualize Topologies",
    "section": "",
    "text": "from kimmdy.parsing import read_top\nfrom kimmdy.topology.topology import Topology\nfrom pathlib import Path\nfrom kimmdy.tools import write_top_as_dot\n\n\nala_top = read_top(Path('../../tests/test_files/test_topology/Ala_R_prm.top'), use_gmx_dir=False)\ntop = Topology(ala_top)\n\nwrite_top_as_dot(top, \"ala-top.dot\")\n\n\n\n\n\n\n\n\n\nG\n\n  \n\n1 CT\n\n 1 CT   \n\n2 HC\n\n 2 HC   \n\n1 CT–2 HC\n\n   \n\n3 HC\n\n 3 HC   \n\n1 CT–3 HC\n\n   \n\n4 HC\n\n 4 HC   \n\n1 CT–4 HC\n\n   \n\n5 C\n\n 5 C   \n\n1 CT–5 C\n\n   \n\n6 O\n\n 6 O   \n\n5 C–6 O\n\n   \n\n7 N\n\n 7 N   \n\n5 C–7 N\n\n   \n\n8 H\n\n 8 H   \n\n7 N–8 H\n\n   \n\n9 CT\n\n 9 CT   \n\n7 N–9 CT\n\n   \n\n10 CT\n\n 10 CT   \n\n9 CT–10 CT\n\n   \n\n14 C\n\n 14 C   \n\n9 CT–14 C\n\n   \n\n11 HC\n\n 11 HC   \n\n10 CT–11 HC\n\n   \n\n12 HC\n\n 12 HC   \n\n10 CT–12 HC\n\n   \n\n13 HC\n\n 13 HC   \n\n10 CT–13 HC\n\n   \n\n15 O\n\n 15 O   \n\n14 C–15 O\n\n   \n\n16 N\n\n 16 N   \n\n14 C–16 N\n\n   \n\n17 H\n\n 17 H   \n\n16 N–17 H\n\n   \n\n18 CT\n\n 18 CT   \n\n16 N–18 CT\n\n   \n\n19 H1\n\n 19 H1   \n\n18 CT–19 H1\n\n   \n\n20 H1\n\n 20 H1   \n\n18 CT–20 H1\n\n   \n\n21 H1\n\n 21 H1   \n\n18 CT–21 H1\n\n  \n\n\nFigure 1: A diagram of the Ala topology"
  },
  {
    "objectID": "guide/explanation/topology.html#capped-alanine-with-a-radical",
    "href": "guide/explanation/topology.html#capped-alanine-with-a-radical",
    "title": "Visualize Topologies",
    "section": "",
    "text": "from kimmdy.parsing import read_top\nfrom kimmdy.topology.topology import Topology\nfrom pathlib import Path\nfrom kimmdy.tools import write_top_as_dot\n\n\nala_top = read_top(Path('../../tests/test_files/test_topology/Ala_R_prm.top'), use_gmx_dir=False)\ntop = Topology(ala_top)\n\nwrite_top_as_dot(top, \"ala-top.dot\")\n\n\n\n\n\n\n\n\n\nG\n\n  \n\n1 CT\n\n 1 CT   \n\n2 HC\n\n 2 HC   \n\n1 CT–2 HC\n\n   \n\n3 HC\n\n 3 HC   \n\n1 CT–3 HC\n\n   \n\n4 HC\n\n 4 HC   \n\n1 CT–4 HC\n\n   \n\n5 C\n\n 5 C   \n\n1 CT–5 C\n\n   \n\n6 O\n\n 6 O   \n\n5 C–6 O\n\n   \n\n7 N\n\n 7 N   \n\n5 C–7 N\n\n   \n\n8 H\n\n 8 H   \n\n7 N–8 H\n\n   \n\n9 CT\n\n 9 CT   \n\n7 N–9 CT\n\n   \n\n10 CT\n\n 10 CT   \n\n9 CT–10 CT\n\n   \n\n14 C\n\n 14 C   \n\n9 CT–14 C\n\n   \n\n11 HC\n\n 11 HC   \n\n10 CT–11 HC\n\n   \n\n12 HC\n\n 12 HC   \n\n10 CT–12 HC\n\n   \n\n13 HC\n\n 13 HC   \n\n10 CT–13 HC\n\n   \n\n15 O\n\n 15 O   \n\n14 C–15 O\n\n   \n\n16 N\n\n 16 N   \n\n14 C–16 N\n\n   \n\n17 H\n\n 17 H   \n\n16 N–17 H\n\n   \n\n18 CT\n\n 18 CT   \n\n16 N–18 CT\n\n   \n\n19 H1\n\n 19 H1   \n\n18 CT–19 H1\n\n   \n\n20 H1\n\n 20 H1   \n\n18 CT–20 H1\n\n   \n\n21 H1\n\n 21 H1   \n\n18 CT–21 H1\n\n  \n\n\nFigure 1: A diagram of the Ala topology"
  },
  {
    "objectID": "guide/explanation/topology.html#multiple-molecules",
    "href": "guide/explanation/topology.html#multiple-molecules",
    "title": "Visualize Topologies",
    "section": "Multiple molecules",
    "text": "Multiple molecules\n\nurea_dict = read_top(Path('../../tests/test_files/test_topology/urea.top'), use_gmx_dir=False)\nurea = Topology(urea_dict)\nwrite_top_as_dot(urea, \"urea-top.dot\")\n\n\n\n\n\n\n\n\n\nG\n\n  \n\n1 C\n\n 1 C   \n\n2 O\n\n 2 O   \n\n1 C–2 O\n\n   \n\n3 N\n\n 3 N   \n\n1 C–3 N\n\n   \n\n6 N\n\n 6 N   \n\n1 C–6 N\n\n   \n\n4 H\n\n 4 H   \n\n3 N–4 H\n\n   \n\n5 H\n\n 5 H   \n\n3 N–5 H\n\n   \n\n7 H\n\n 7 H   \n\n6 N–7 H\n\n   \n\n8 H\n\n 8 H   \n\n6 N–8 H\n\n  \n\n\nFigure 2: Topology of one molecule of urea\n\n\n\n\nWhen we want to run reactions within molecules that are either separate moleculetypes or multiples of the same moleculetype, KIMMDY can combine those into a single moleculetype and make multiples explicit.\ni.e. if we have a topology with two molecules of urea defined as:\n[ system ]\nUrea in Water\n\n[ molecules ]\n;molecule name   nr.\nUrea             2\nSOL              1000\n\nurea_dict = read_top(Path('../../tests/test_files/test_topology/urea-times-2.top'), use_gmx_dir=False)\nurea = Topology(urea_dict)\nwrite_top_as_dot(urea, \"urea-2-top.dot\")\n\nWe end up with\n\n\n\n\n\n\n\n\nG\n\n  \n\n1 C\n\n 1 C   \n\n2 O\n\n 2 O   \n\n1 C–2 O\n\n   \n\n3 N\n\n 3 N   \n\n1 C–3 N\n\n   \n\n6 N\n\n 6 N   \n\n1 C–6 N\n\n   \n\n4 H\n\n 4 H   \n\n3 N–4 H\n\n   \n\n5 H\n\n 5 H   \n\n3 N–5 H\n\n   \n\n7 H\n\n 7 H   \n\n6 N–7 H\n\n   \n\n8 H\n\n 8 H   \n\n6 N–8 H\n\n   \n\n9 C\n\n 9 C   \n\n10 O\n\n 10 O   \n\n9 C–10 O\n\n   \n\n11 N\n\n 11 N   \n\n9 C–11 N\n\n   \n\n14 N\n\n 14 N   \n\n9 C–14 N\n\n   \n\n12 H\n\n 12 H   \n\n11 N–12 H\n\n   \n\n13 H\n\n 13 H   \n\n11 N–13 H\n\n   \n\n15 H\n\n 15 H   \n\n14 N–15 H\n\n   \n\n16 H\n\n 16 H   \n\n14 N–16 H\n\n  \n\n\nFigure 3: A diagram of the two urea molecules topology\n\n\n\n\nThis way, explicit atom numbers match up with the atom numbers in the coordinate file (or rather, line numbers - 2, since the numbers in the actual atomnr column can overflow due to the fixed-width file format)."
  }
]