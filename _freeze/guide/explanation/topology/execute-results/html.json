{
  "hash": "fdd5b0cf31b6db54ea6c666d2f949488",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Visualize Topologies\nmermaid-format: svg\n---\n\n\n\n\n## Capped Alanine with a radical\n\n::: {#b9413d2b .cell execution_count=1}\n``` {.python .cell-code}\nfrom kimmdy.parsing import read_top\nfrom kimmdy.topology.topology import Topology\nfrom pathlib import Path\nfrom kimmdy.tools import write_top_as_dot\nimport copy\n```\n:::\n\n\nThis is the same reaction that would occur in the naive alanine HAT example (and integration test) if\nif where used with the `dummy_first` kmc method instead of standard `rfkmc`.\n\n::: {#12f71256 .cell execution_count=2}\n``` {.python .cell-code}\npath_a = read_top(Path('../../tests/test_files/test_integration/alanine_hat_naive/Ala_out.top'), use_gmx_dir=False)\ntop = Topology(path_a)\ntop_a = copy.deepcopy(top)\ntop_b = top\n\ntop_b.break_bond(('7', '8'))\ntop_b.bind_bond(('8', '9'))\n\nwrite_top_as_dot(top_a, \"ala-top-a.dot\")\nwrite_top_as_dot(top_b, \"ala-top-b.dot\")\n```\n:::\n\n\n:::{layout-ncol=2}\n\n\n\n```{dot}\n//| echo: false\n//| label: fig-ala\n//| fig-cap: \"A diagram of the Ala topology\"\n//| fig-width: 100%\n//| file: ala-top-a.dot\n```\n\n```{dot}\n//| echo: false\n//| label: fig-ala\n//| fig-cap: \"A diagram of the Ala topology after HAT\"\n//| fig-width: 100%\n//| file: ala-top-b.dot\n```\n\n\n\n:::\n\nOr we can look at a different HAT used in the unit tests:\n\n::: {#60e690b1 .cell execution_count=3}\n``` {.python .cell-code}\npath_a = read_top(Path('../../tests/test_files/test_integration/alanine_hat_naive/Ala_out.top'), use_gmx_dir=False)\ntop = Topology(path_a)\n\n# move the radical to N16 before we start the reaction\ntop.break_bond((\"16\", \"17\"))\ntop.bind_bond((\"9\", \"17\"))\ntop_a = copy.deepcopy(top)\ntop_b = top\n\ntop_b.break_bond((\"18\", \"21\"))\ntop_b.bind_bond((\"16\", \"21\"))\n\nwrite_top_as_dot(top_a, \"ala-top-2-a.dot\")\nwrite_top_as_dot(top_b, \"ala-top-2-b.dot\")\n```\n:::\n\n\n:::{layout-ncol=2}\n\n\n\n```{dot}\n//| echo: false\n//| label: fig-ala\n//| fig-cap: \"A diagram of the Ala topology\"\n//| fig-width: 100%\n//| file: ala-top-2-a.dot\n```\n\n```{dot}\n//| echo: false\n//| label: fig-ala\n//| fig-cap: \"A diagram of the Ala topology after HAT\"\n//| fig-width: 100%\n//| file: ala-top-2-b.dot\n```\n\n\n\n:::\n\n\n\n## Multiple molecules\n\n::: {#8a41d695 .cell execution_count=4}\n``` {.python .cell-code}\nurea_dict = read_top(Path('../../tests/test_files/test_topology/urea.top'), use_gmx_dir=False)\nurea = Topology(urea_dict)\nwrite_top_as_dot(urea, \"urea-top.dot\")\n```\n:::\n\n\n```{dot}\n//| echo: false\n//| label: fig-ala\n//| fig-cap: \"Topology of one molecule of urea\"\n//| file: urea-top.dot\n```\n\n\n\n\nWhen we want to run reactions within molecules that are either\nseparate moleculetypes or multiples of the same moleculetype,\nKIMMDY can combine those into a single moleculetype and\nmake multiples explicit.\n\ni.e. if we have a topology with two molecules of urea\ndefined as:\n\n```ini\n[ system ]\nUrea in Water\n\n[ molecules ]\n;molecule name   nr.\nUrea             2\nSOL              1000\n```\n\n::: {#8725e8c5 .cell execution_count=5}\n``` {.python .cell-code}\nurea_dict = read_top(Path('../../tests/test_files/test_topology/urea-times-2.top'), use_gmx_dir=False)\nurea = Topology(urea_dict)\nwrite_top_as_dot(urea, \"urea-2-top.dot\")\n```\n:::\n\n\nWe end up with\n\n\n\n\n```{dot}\n//| echo: false\n//| label: fig-ala\n//| fig-cap: \"A diagram of the two urea molecules topology\"\n//| file: urea-2-top.dot\n```\n\n\n\n\nThis way, explicit atom numbers match up with the atom numbers\nin the coordinate file (or rather, line numbers - 2, since the\nnumbers in the actual `atomnr` column can overflow due to the fixed-width file format).\n\n",
    "supporting": [
      "topology_files"
    ],
    "filters": [],
    "includes": {}
  }
}